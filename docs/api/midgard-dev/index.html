<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>midgard.dev - Midgard</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../..">Midgard</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../..">Home</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">How-to <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../howto/testing/">Testing</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">API <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../midgard/">midgard</a>
</li>
                                    
<li >
    <a href="../midgard-collections/">midgard.collections</a>
</li>
                                    
<li >
    <a href="../midgard-config/">midgard.config</a>
</li>
                                    
<li >
    <a href="../midgard-coords/">midgard.coords</a>
</li>
                                    
<li class="active">
    <a href="./">midgard.dev</a>
</li>
                                    
<li >
    <a href="../midgard-files/">midgard.files</a>
</li>
                                    
<li >
    <a href="../midgard-ionosphere/">midgard.ionosphere</a>
</li>
                                    
<li >
    <a href="../midgard-math/">midgard.math</a>
</li>
                                    
<li >
    <a href="../midgard-parsers/">midgard.parsers</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../midgard-coords/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../midgard-files/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#midgarddevconsole">midgard.dev.console</a></li>
            <li><a href="#columns">columns()</a></li>
            <li><a href="#dedent">dedent()</a></li>
            <li><a href="#fill">fill()</a></li>
            <li><a href="#indent">indent()</a></li>
            <li><a href="#lines">lines()</a></li>
            <li><a href="#num_leading_spaces">num_leading_spaces()</a></li>
        <li class="main "><a href="#midgarddevexceptions">midgard.dev.exceptions</a></li>
            <li><a href="#fielddoesnotexisterror">FieldDoesNotExistError</a></li>
            <li><a href="#fieldexistserror">FieldExistsError</a></li>
            <li><a href="#initializationerror">InitializationError</a></li>
            <li><a href="#midgardexception">MidgardException</a></li>
            <li><a href="#midgardexit">MidgardExit</a></li>
            <li><a href="#missingconfigurationerror">MissingConfigurationError</a></li>
            <li><a href="#missingdataerror">MissingDataError</a></li>
            <li><a href="#missingentryerror">MissingEntryError</a></li>
            <li><a href="#missingsectionerror">MissingSectionError</a></li>
            <li><a href="#parsererror">ParserError</a></li>
            <li><a href="#timernotrunning">TimerNotRunning</a></li>
            <li><a href="#timerrunning">TimerRunning</a></li>
            <li><a href="#uniterror">UnitError</a></li>
            <li><a href="#unknownenumerror">UnknownEnumError</a></li>
            <li><a href="#unknownpackageerror">UnknownPackageError</a></li>
            <li><a href="#unknownpluginerror">UnknownPluginError</a></li>
        <li class="main "><a href="#midgarddevlibrary">midgard.dev.library</a></li>
            <li><a href="#simplemock">SimpleMock</a></li>
            <li><a href="#load_name">load_name()</a></li>
            <li><a href="#load_path">load_path()</a></li>
        <li class="main "><a href="#midgarddevoptional">midgard.dev.optional</a></li>
            <li><a href="#emptystringmock">EmptyStringMock</a></li>
            <li><a href="#simplemock_1">SimpleMock</a></li>
            <li><a href="#optional_import">optional_import()</a></li>
        <li class="main "><a href="#midgarddevplugins">midgard.dev.plugins</a></li>
            <li><a href="#plugin">Plugin</a></li>
            <li><a href="#add_alias">add_alias()</a></li>
            <li><a href="#call">call()</a></li>
            <li><a href="#call_all">call_all()</a></li>
            <li><a href="#doc">doc()</a></li>
            <li><a href="#doc_all">doc_all()</a></li>
            <li><a href="#exists">exists()</a></li>
            <li><a href="#get">get()</a></li>
            <li><a href="#load">load()</a></li>
            <li><a href="#names">names()</a></li>
            <li><a href="#parts">parts()</a></li>
            <li><a href="#register">register()</a></li>
            <li><a href="#register_named">register_named()</a></li>
            <li><a href="#register_ordered">register_ordered()</a></li>
            <li><a href="#signature">signature()</a></li>
        <li class="main "><a href="#midgarddevprofiler">midgard.dev.profiler</a></li>
            <li><a href="#cprofile">CProfile</a></li>
            <li><a href="#lineprofiler">LineProfiler</a></li>
            <li><a href="#profiler">Profiler</a></li>
        <li class="main "><a href="#midgarddevtimer">midgard.dev.timer</a></li>
            <li><a href="#accumulatedtimer">AccumulatedTimer</a></li>
            <li><a href="#timer">Timer</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="midgarddevconsole">midgard.dev.console</h1>
<p>Simpler dealing with the console</p>
<p><strong>Description:</strong></p>
<p>Utilities for using the console. Mainly wrappers around other libraries to make them easier and more intuitive to use.</p>
<p>Size of console: The two functions <code>lines()</code> and <code>columns()</code> report the current size of the console.</p>
<p>Textwrapping: The function <code>fill()</code> can be used to rewrap a text-string so that it fits inside the console.</p>
<p>Color: The sub-module <code>color</code> can be used to set the foreground and background colors. Note that the color
functionality depends on the external package <code>colorama</code>. If <code>colorama</code> is not installed, color gracefully falls back
to not showing any color.</p>
<p><strong>Examples:</strong></p>
<pre><code>&gt;&gt;&gt; from midgard.dev import console
&gt;&gt;&gt; console.columns()  # doctest: +SKIP
86

&gt;&gt;&gt; print(console.fill(a_very_long_string))  # doctest: +SKIP
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras tempus eleifend feugiat.
Maecenas vitae posuere metus. Sed sit amet fermentum velit. Aenean vitae turpis at
risus sollicitudin fringilla in in nisi. Maecenas vitae ante libero. Aenean ut eros
consequat, ornare erat at, tempus arcu. Suspendisse velit leo, eleifend eget mi non,
vehicula ultricies erat. Vestibulum id nisi eget nisl venenatis dignissim. Duis cursus
quam dui, vel hendrerit nibh lacinia id.

&gt;&gt;&gt; print(console.color.Fore.YELLOW + console.color.Back.BLUE + 'I am YELLOW text on BLUE backdrop!')  # doctest: +SKIP
I am YELLOW text on a BLUE background!
</code></pre>
<h2 id="columns"><strong>columns</strong>()</h2>
<p>Full name: <code>midgard.dev.console.columns</code></p>
<p>Signature: <code>() -&gt; int</code></p>
<p>The width of the console</p>
<p><strong>Returns:</strong></p>
<p>The width of the console in characters.</p>
<h2 id="dedent"><strong>dedent</strong>()</h2>
<p>Full name: <code>midgard.dev.console.dedent</code></p>
<p>Signature: <code>(text:str, num_spaces:Union[int, NoneType]=None) -&gt; str</code></p>
<p>Wrapper around textwrap.dedent</p>
<p>Dedents at most num_spaces. If num_spaces is not specified, dedents as much as possible.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>text</code>:        Text that will be dedented.</li>
<li><code>num_spaces</code>:  Number of spaces that will be used for dedentation.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dedented string.</p>
<h2 id="fill"><strong>fill</strong>()</h2>
<p>Full name: <code>midgard.dev.console.fill</code></p>
<p>Signature: <code>(text:str, *, width:Union[int, NoneType]=None, hanging:Union[int, NoneType]=None, **tw_args:Any) -&gt; str</code></p>
<p>Wrapper around textwrap.fill</p>
<p>The <code>tw_args</code> are passed on to textwrap.fill. See textwrap.TextWrapper for available keyword arguments.</p>
<p>The default value for <code>width</code> is console.columns(), while the new argument <code>hanging</code>, if defined, will try
to set (although not override) the textwrap-arguments <code>initial_indent</code> and <code>subsequent_indent</code> to create a hanging
indent (no indent on the first line) of <code>hanging</code> spaces.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>text</code>:     Text that will be wrapped.</li>
<li><code>width</code>:    The maximum width (in characters) of wrapped lines.</li>
<li><code>hanging</code>:  Number of characters used for hanging indent.</li>
<li><code>tw_args</code>:  Arguments passed on to <code>textwrap.fill</code>.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Wrapped string.</p>
<h2 id="indent"><strong>indent</strong>()</h2>
<p>Full name: <code>midgard.dev.console.indent</code></p>
<p>Signature: <code>(text:str, num_spaces:int, **tw_args:Any) -&gt; str</code></p>
<p>Wrapper around textwrap.indent</p>
<p>The <code>tw_args</code> are passed on to textwrap.indent.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>text</code>:        Text that will be indented.</li>
<li><code>num_spaces</code>:  Number of spaces that will be used for indentation.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Indented string.</p>
<h2 id="lines"><strong>lines</strong>()</h2>
<p>Full name: <code>midgard.dev.console.lines</code></p>
<p>Signature: <code>() -&gt; int</code></p>
<p>The height of the console</p>
<p><strong>Returns:</strong></p>
<p>The heigth of the console in characters.</p>
<h2 id="num_leading_spaces"><strong>num_leading_spaces</strong>()</h2>
<p>Full name: <code>midgard.dev.console.num_leading_spaces</code></p>
<p>Signature: <code>(text:str, space_char:str=' ') -&gt; int</code></p>
<p>Count number of leading spaces in a string</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>text</code>:        String to count.</li>
<li><code>space_char</code>:  Which characters count as spaces.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Number of leading spaces.</p>
<h1 id="midgarddevexceptions">midgard.dev.exceptions</h1>
<p>Definition of Midgard-specific exceptions</p>
<p><strong>Description:</strong></p>
<p>Custom exceptions used by Midgard for more specific error messages and handling.</p>
<h2 id="fielddoesnotexisterror"><strong>FieldDoesNotExistError</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.FieldDoesNotExistError</code></p>
<p>Signature: <code>()</code></p>
<h2 id="fieldexistserror"><strong>FieldExistsError</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.FieldExistsError</code></p>
<p>Signature: <code>()</code></p>
<h2 id="initializationerror"><strong>InitializationError</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.InitializationError</code></p>
<p>Signature: <code>()</code></p>
<h2 id="midgardexception"><strong>MidgardException</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.MidgardException</code></p>
<p>Signature: <code>()</code></p>
<h2 id="midgardexit"><strong>MidgardExit</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.MidgardExit</code></p>
<p>Signature: <code>()</code></p>
<h2 id="missingconfigurationerror"><strong>MissingConfigurationError</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.MissingConfigurationError</code></p>
<p>Signature: <code>()</code></p>
<h2 id="missingdataerror"><strong>MissingDataError</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.MissingDataError</code></p>
<p>Signature: <code>()</code></p>
<h2 id="missingentryerror"><strong>MissingEntryError</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.MissingEntryError</code></p>
<p>Signature: <code>()</code></p>
<h2 id="missingsectionerror"><strong>MissingSectionError</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.MissingSectionError</code></p>
<p>Signature: <code>()</code></p>
<h2 id="parsererror"><strong>ParserError</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.ParserError</code></p>
<p>Signature: <code>()</code></p>
<h2 id="timernotrunning"><strong>TimerNotRunning</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.TimerNotRunning</code></p>
<p>Signature: <code>()</code></p>
<h2 id="timerrunning"><strong>TimerRunning</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.TimerRunning</code></p>
<p>Signature: <code>()</code></p>
<h2 id="uniterror"><strong>UnitError</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.UnitError</code></p>
<p>Signature: <code>()</code></p>
<h2 id="unknownenumerror"><strong>UnknownEnumError</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.UnknownEnumError</code></p>
<p>Signature: <code>()</code></p>
<h2 id="unknownpackageerror"><strong>UnknownPackageError</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.UnknownPackageError</code></p>
<p>Signature: <code>()</code></p>
<h2 id="unknownpluginerror"><strong>UnknownPluginError</strong></h2>
<p>Full name: <code>midgard.dev.exceptions.UnknownPluginError</code></p>
<p>Signature: <code>()</code></p>
<h1 id="midgarddevlibrary">midgard.dev.library</h1>
<p>Python wrapper around C-libraries</p>
<p><strong>Description:</strong></p>
<p>Loads a C-library. If a library is missing, a mock library is returned. If this
mock is used for anything, a warning will be printed. This is done to avoid
dependencies to all the C/C++-libraries for Python programs only using some of
them.</p>
<h2 id="simplemock"><strong>SimpleMock</strong></h2>
<p>Full name: <code>midgard.dev.library.SimpleMock</code></p>
<p>Signature: <code>(name, raise_error=True)</code></p>
<p>Class that can stand in for any other object</p>
<p>The SimpleMock is used to stand in for any library that can not be
imported. The mock object simply returns itself whenever it is called, or
any attributes are looked up on the object. This is done, to avoid
ImportErrors when a library is imported, but never used (typically because
a plugin is loaded but never called).</p>
<p>Instead the ImportError is raised when the SimpleMock is used in any
way. The ImportError will only be raised once for any SimpleMock-object
(which is only important if the ImportError is caught and the program
carries on).</p>
<h2 id="load_name"><strong>load_name</strong>()</h2>
<p>Full name: <code>midgard.dev.library.load_name</code></p>
<p>Signature: <code>(library_name, func_specs=None, name_patterns=None)</code></p>
<p>Load the given shared C-library</p>
<p>See <code>load_path</code> for an explanation of the <code>func_specs</code> and
<code>name_patterns</code>-arguments.</p>
<p><strong>Args:</strong></p>
<p>library_name (String): The name of the library.
func_specs (Dict):     Specification of types in lib (see load_path).
name_patterns (List):  Name mangling patterns (see load_path).</p>
<p><strong>Returns:</strong></p>
<p>ctypes.CDLL:   Representation of the shared library.</p>
<h2 id="load_path"><strong>load_path</strong>()</h2>
<p>Full name: <code>midgard.dev.library.load_path</code></p>
<p>Signature: <code>(library_path, func_specs=None, name_patterns=None)</code></p>
<p>Load the given shared C-library</p>
<p>The optional func_specs-dictionary can be used to specify argument and
return types of functions in the library (see the ctypes documentation for
information about argtypes and restype). The dictionary should be on the
form::</p>
<pre><code>func_spec = {'func_1': dict(func_name='name_of_func_1_in_lib',
                            argtypes=[ ... argtypes of func_1 ... ],
                            restype=... restype of func_1 ...),
             'func_2': ...
            }
</code></pre>
<p>If the library is not found, a mock library is returned instead. The mock
library will print a warning if it is used.</p>
<p>For some libraries, name mangling is used and this might be different
depending on operating system and how the library is compiled. For
instance, in a Fortran library the function <code>Test</code> might be represented as
<code>__Test</code> on a Windows system and <code>test_</code> (with lower-case <code>t</code>) on a Linux
system. This can be handled by providing a list of possible patterns. The
above example can be handled by::</p>
<pre><code>name_patterns = ('__{func_name}', '{func_name_lower}_')
</code></pre>
<p>In this case, each function in func_specs is looked up by testing each
pattern in turn until a match is found.</p>
<p><strong>Args:</strong></p>
<p>library_path (String): The path to the library.
func_specs (Dict):     Specification of types in library (see above).
name_patterns (List):  Name mangling patterns (see above).</p>
<p><strong>Returns:</strong></p>
<p>ctypes.CDLL:   Representation of the shared library.</p>
<h1 id="midgarddevoptional">midgard.dev.optional</h1>
<p>Midgard library module for handling optional dependencies</p>
<p><strong>Description:</strong></p>
<p>Import dependencies that are only necessary for specific parts of Midgard. Using this module will delay raising an
ImportError until the dependency is actually used. This means that if one for instance only wants to run a GNSS
analysis (or only use a Rinex-parser) installing special libraries only used for VLBI is not necessary.</p>
<p><strong>Examples:</strong></p>
<p>The optional import is typically used as follows::</p>
<pre><code>from midgard.lib import optional
netCDF4 = optional.optional_import('netCDF4')
</code></pre>
<h2 id="emptystringmock"><strong>EmptyStringMock</strong></h2>
<p>Full name: <code>midgard.dev.optional.EmptyStringMock</code></p>
<p>Signature: <code>(name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None, error_msg:Union[str, NoneType]=None) -&gt; None</code></p>
<p>A mock object whose properties are all empty strings</p>
<h2 id="simplemock_1"><strong>SimpleMock</strong></h2>
<p>Full name: <code>midgard.dev.optional.SimpleMock</code></p>
<p>Signature: <code>(name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None, error_msg:Union[str, NoneType]=None) -&gt; None</code></p>
<p>Class that can stand in for any other object</p>
<p>The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself
whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a
library is imported, but never used (for instance if a plugin is loaded but never called).</p>
<p>Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once
for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on).</p>
<p>The exception is if any attributes (<code>attrs</code>) are explicitly defined on the mock. No exception is raised if those
attributes are looked up.</p>
<h2 id="optional_import"><strong>optional_import</strong>()</h2>
<p>Full name: <code>midgard.dev.optional.optional_import</code></p>
<p>Signature: <code>(module_name:str, raise_error:bool=True, mock_cls:type=&lt;class 'midgard.dev.optional.SimpleMock'&gt;, attrs:Union[Dict[str, Any], NoneType]=None) -&gt; Union[Any, midgard.dev.optional.SimpleMock]</code></p>
<p>Try to import an optional module</p>
<p>If the module does not exist, a SimpleMock-object is returned instead. If this SimpleMock-object is later used, an
ImportError will be raised then (if <code>raise_error</code> is True, which is default).</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>module_name</code>:   Name of module to import.</li>
<li><code>raise_error</code>:   Whether an ImportError should be raised if the module does not exist, but is used.</li>
<li><code>attrs</code>:         Attributes that should be added to the SimpleMock used if the module does not exist.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Imported module object, or a SimpleMock-object if the module can not be imported.</p>
<h1 id="midgarddevplugins">midgard.dev.plugins</h1>
<p>Set up a plug-in architecture for Midgard</p>
<p><strong>Description:</strong></p>
<p>In order to be able to add models, parsers, data sources etc without needing to
hardcode names, but rather pick them from configuration files, we use a simple
plug-in architecture. The plug-in mechanism is based on the different plug-ins
registering themselves using the <code>register</code> decorator:</p>
<pre><code>from midgard.dev import plugins

@plugins.register
def simple_model(rundate, tech, dset):
    ...
</code></pre>
<p>Plug-ins are registered based on the name of the module (file) they are defined
in, as well as the package (directory) which contains them. Typically all
plug-ins of a given type are collected in a package, e.g. models, techniques,
parsers, etc. To list all plug-ins in a package use <code>names</code>:</p>
<pre><code>&gt; from midgard.dev import plugins
&gt; plugins.names('midgard.models')
['model_one', 'model_three', 'model_two']
</code></pre>
<p>If the optional parameter <code>config_key</code> is given, then only plug-ins listed in
the corresponding section in the current configuration file is listed. For
instance, if the configuration file contains a line saying</p>
<pre><code>ham_models = model_three, model_one
</code></pre>
<p>then we can list only the <code>ham_models</code> as follows:</p>
<pre><code>&gt; from midgard.dev import plugins
&gt; plugins.names('midgard.models', config_key='ham_models')
['model_one', 'model_three']
</code></pre>
<p>Note that the plug-ins by default are sorted alphabetically.</p>
<p>To run the plug-ins, use either <code>call_all</code> or <code>call_one</code>. The former calls all
plug-ins and returns a dictionary containing the result from each plug-in. As
with <code>names</code> the optional parameter <code>config_key</code> may be given:</p>
<pre><code>&gt; from midgard.dev import plugins
&gt; plugins.call_all('midgard.models', config_key='ham_models', arg_to_plugin='hello')
{'model_three': &lt;result from model_three&gt;, 'model_one': &lt;result from model_one&gt;}
</code></pre>
<p>Arguments to the plug-ins should be passed as named arguments to <code>call_all</code>.</p>
<p>Similarly, one plug-in may be called explicitly using <code>call_one</code>:</p>
<pre><code>&gt; from midgard.dev import plugins
&gt; plugins.call_one('midgard.models', plugin_name='model_one', arg_to_plugin='hello')
&lt;result from model_one&gt;
</code></pre>
<p>There may be more than one function in each plug-in that is decorated by
<code>register</code>. In this case, the default behaviour is that only the first function
will be called. To call the other registered functions one should use the
<code>list_parts</code> function to get a list of these functions and call them explicitly
using the <code>part</code> optional parameter to <code>call_one</code>:</p>
<pre><code>&gt; from midgard.dev import plugins
&gt; plugins.list_parts('midgard.techniques', plugin_name='vlbi')
['read', 'edit', 'calculate', 'estimate', 'write_result'])
&gt; for part in plugins.list_parts('midgard.techniques', plugin_name='vlbi'):
...   plugins.call_one('midgard.techniques', plugin_name='vlbi', part=part, ...)
</code></pre>
<h2 id="plugin"><strong>Plugin</strong></h2>
<p>Full name: <code>midgard.dev.plugins.Plugin</code></p>
<p>Signature: <code>(name:str, function:Callable, file_path:pathlib.Path, sort_value:int)</code></p>
<p>Information about a plug-in</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>name</code>:        Name of the plug-in.</li>
<li><code>function</code>:    The plug-in.</li>
<li><code>file_path</code>:   Path to the source code of the plug-in, may be used to add the source as a dependency.</li>
<li><code>sort_value</code>:  Value used when sorting plug-ins in order to control the order they are called.</li>
</ul>
<h2 id="add_alias"><strong>add_alias</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.add_alias</code></p>
<p>Signature: <code>(package_name:str, alias:str) -&gt; None</code></p>
<p>Add alias to plug-in package</p>
<p>This allows one package of plug-ins to be spread over several directories</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>package_name</code>:  Name of package containing plug-ins.</li>
<li><code>directory</code>:     Additional plug-in directory.</li>
</ul>
<h2 id="call"><strong>call</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.call</code></p>
<p>Signature: <code>(package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -&gt; Any</code></p>
<p>Call one plug-in</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>package_name</code>:   Name of package containing plug-ins.</li>
<li><code>plugin_name</code>:    Name of the plug-in, i.e. the module containing the plug-in.</li>
<li><code>part</code>:           Name of function to call within the plug-in (optional).</li>
<li><code>prefix</code>:         Prefix of the plug-in name, used if the plug-in name is not found (optional).</li>
<li><code>plugin_logger</code>:  Function used for logging (optional).</li>
<li><code>plugin_args</code>:    Named arguments passed on to the plug-in.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Return value of the plug-in.</p>
<h2 id="call_all"><strong>call_all</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.call_all</code></p>
<p>Signature: <code>(package_name:str, plugins:Union[List[str], NoneType]=None, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -&gt; Dict[str, Any]</code></p>
<p>Call all plug-ins in a package</p>
<p>If <code>plugins</code> is given, it should be a list of names of plug-ins.  If a
plug-in listed in the <code>plugins</code>-list or in the config file does not exist,
an UnknownPluginError is raised.</p>
<p>If <code>plugins</code> is not given, all available plugins will be called. Do note,
however, that this will import all python files in the package.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>package_name</code>:   Name of package containing plug-ins.</li>
<li><code>plugins</code>:        List of plug-in names that should be used (optional).</li>
<li><code>part</code>:           Name of function to call within the plug-ins (optional).</li>
<li><code>prefix</code>:         Prefix of the plug-in names, used for a plug-in if it is not found (optional).</li>
<li><code>plugin_logger</code>:  Function used for logging (optional).</li>
<li><code>plugin_args</code>:    Named arguments passed on to all the plug-ins.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary of all results from the plug-ins.</p>
<h2 id="doc"><strong>doc</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.doc</code></p>
<p>Signature: <code>(package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False, use_module:bool=False) -&gt; str</code></p>
<p>Document one plug-in</p>
<p>If the plug-in is not part of the package an UnknownPluginError is raised.</p>
<p>If there are several functions registered in a plug-in and <code>part</code> is not
specified, then the first function registered in the plug-in will be
documented.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>package_name</code>:     Name of package containing plug-ins.</li>
<li><code>plugin_name</code>:      Name of the plug-in, i.e. the module containing the plug-in.</li>
<li><code>part</code>:             Name of function to call within the plug-in (optional).</li>
<li><code>prefix</code>:           Prefix of the plug-in name, used if the plug-in name is unknown (optional).</li>
<li><code>long_doc</code>:         Whether to return the long doc-string or the short one-line string (optional).</li>
<li><code>include_details</code>:  Whether to include development details like parameters and return values (optional).</li>
<li><code>use_module</code>:       Whether to use module doc-string instead of plug-in doc-string (optional).</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Documentation of the plug-in.</p>
<h2 id="doc_all"><strong>doc_all</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.doc_all</code></p>
<p>Signature: <code>(package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False, use_module:bool=False) -&gt; Dict[str, str]</code></p>
<p>Call all plug-ins in a package</p>
<p>If <code>plugins</code> is given, it should be a list of names of plug-ins. If a
plug-in listed in the <code>plugins</code>-list does not exist, an UnknownPluginError
is raised.</p>
<p>If <code>plugins</code> is not given, all available plugins will be called. Do note,
however, that this will import all python files in the package.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>package_name</code>:     Name of package containing plug-ins.</li>
<li><code>plugins</code>:          List of plug-ins that should be used (optional).</li>
<li><code>prefix</code>:           Prefix of the plug-in names, used if any of the plug-ins are unknown (optional).</li>
<li><code>long_doc</code>:         Whether to return the long doc-string or the short one-line string (optional).</li>
<li><code>include_details</code>:  Whether to include development details like parameters and return values (optional).</li>
<li><code>use_module</code>:       Whether to use module doc-string instead of plug-in doc-string (optional).</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary of all doc-strings from the plug-ins.</p>
<h2 id="exists"><strong>exists</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.exists</code></p>
<p>Signature: <code>(package_name:str, plugin_name:str) -&gt; bool</code></p>
<p>Check whether or not a plug-in exists in a package</p>
<p>Tries to import the given plug-in.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>package_name</code>:  Name of package containing plug-ins.</li>
<li><code>plugin_name</code>:   Name of the plug-in (module).</li>
</ul>
<p><strong>Returns:</strong></p>
<p>True if plug-in exists, False otherwise.</p>
<h2 id="get"><strong>get</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.get</code></p>
<p>Signature: <code>(package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None) -&gt; midgard.dev.plugins.Plugin</code></p>
<p>Get a specific plugin-object</p>
<p>If the plug-in is not part of the package an UnknownPluginError is raised.</p>
<p>If there are several functions registered in a plug-in and <code>part</code> is not
specified, then the first function registered in the plug-in will be
called.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>package_name</code>:  Name of package containing plug-ins.</li>
<li><code>plugin_name</code>:   Name of the plug-in, i.e. the module containing the plug-in.</li>
<li><code>part</code>:          Name of function to call within the plug-in (optional).</li>
<li><code>prefix</code>:        Prefix of the plug-in name, used if the plug-in name is not found (optional).</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Plugin-namedtuple representing the plug-in.</p>
<h2 id="load"><strong>load</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.load</code></p>
<p>Signature: <code>(package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -&gt; str</code></p>
<p>Load one plug-in from a package</p>
<p>First tries to load the plugin with the given name. If that fails, it tries
to load {prefix}_{plugin_name} instead.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>package_name</code>:  Name of package containing plug-ins.</li>
<li><code>plugin_name</code>:   Name of the plug-in (module).</li>
<li><code>prefix</code>:        Prefix of the plug-in name, used if the plug-in name is unknown (optional).</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Actual name of plug-in (with or without prefix).</p>
<h2 id="names"><strong>names</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.names</code></p>
<p>Signature: <code>(package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None) -&gt; List[str]</code></p>
<p>List plug-ins in a package</p>
<p>If <code>plugins</code> is given, it should be a list of names of plug-ins.  If a
plug-in listed in the <code>plugins</code>-list does not exist, an UnknownPluginError
is raised.</p>
<p>If <code>plugins</code> is not given, all available plugins will be listed. Do note,
however, that this will import all python files in the package.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>package_name</code>:  Name of package containing plug-ins.</li>
<li><code>plugins</code>:       List of plug-ins that should be used (optional).</li>
<li><code>prefix</code>:        Prefix of the plug-in names, used if any of the plug-in names are unknown (optional).</li>
</ul>
<p><strong>Returns:</strong></p>
<p>List of strings with names of plug-ins.</p>
<h2 id="parts"><strong>parts</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.parts</code></p>
<p>Signature: <code>(package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -&gt; List[str]</code></p>
<p>List all parts of one plug-in</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>package_name</code>:  Name of package containing plug-ins.</li>
<li><code>plugin_name</code>:   Name of the plug-in.</li>
<li><code>prefix</code>:        Prefix of the plug-in name, used if the plug-in name is unknown (optional).</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>List</code>: Strings with names of parts.</li>
</ul>
<h2 id="register"><strong>register</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.register</code></p>
<p>Signature: <code>(func:Callable, name:Union[str, NoneType]=None, sort_value:int=0) -&gt; Callable</code></p>
<p>Decorator used to register a plug-in</p>
<p>Plug-ins are registered based on the name of the module (file) they are
defined in, as well as the package (directory) which contains
them. Typically all plug-ins of a given type are collected in a package,
e.g. models, techniques, parsers, etc. The path to the source code file is
also stored. This is used to be able to add the source code as a dependency
file when the plug-in is called.</p>
<p>If <code>name</code> is given, the plug-in is registered based on this name instead of
the name of the module. The name of the module is still registered as a
part that can be used to distinguish between similar plug-ins in different
files (see for instance how <code>session</code> is used in <code>midgard.pipelines</code>).</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>func</code>:        The function that is being registered.</li>
<li><code>name</code>:        Alternative name of plug-in. Used by <code>register_named</code>.</li>
<li><code>sort_value</code>:  The value used when sorting plug-ins. Used by <code>register_ordered</code>.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>The function that is being registered.</p>
<h2 id="register_named"><strong>register_named</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.register_named</code></p>
<p>Signature: <code>(name:str) -&gt; Callable</code></p>
<p>Decorator used to register a named plug-in</p>
<p>This allows for overriding the name used to register the plug-in. See
<code>register</code> for more details.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>name</code>:   Name used for plug-in instead of module name.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Decorator that registers a named function.</p>
<h2 id="register_ordered"><strong>register_ordered</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.register_ordered</code></p>
<p>Signature: <code>(sort_value:int) -&gt; Callable</code></p>
<p>Decorator used to register a plug-in with a specific sort order</p>
<p>The sort value should be a number. Lower numbers are sorted first, higher
numbers last. Plug-ins without an explicit sort_order gets the sort value
of 0.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>sort_value</code>:   The value used when sorting plug-ins.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Decorator that registers an ordered function.</p>
<h2 id="signature"><strong>signature</strong>()</h2>
<p>Full name: <code>midgard.dev.plugins.signature</code></p>
<p>Signature: <code>(package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None) -&gt; inspect.Signature</code></p>
<p>Get signature of a plug-in</p>
<p>If the plug-in is not part of the package an UnknownPluginError is raised.</p>
<p>If there are several functions registered in a plug-in and <code>part</code> is not
specified, then the first function registered in the plug-in will be
documented.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>package_name</code>:     Name of package containing plug-ins.</li>
<li><code>plugin_name</code>:      Name of the plug-in, i.e. the module containing the plug-in.</li>
<li><code>part</code>:             Name of function to call within the plug-in (optional).</li>
<li><code>prefix</code>:           Prefix of the plug-in name, used if the plug-in name is unknown (optional).</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Signature of the plugin</p>
<h1 id="midgarddevprofiler">midgard.dev.profiler</h1>
<p>Add a profiler when running</p>
<p>Supports several profilers including cprofile, line_profiler, memprof and memory_profiler.</p>
<h2 id="cprofile"><strong>CProfile</strong></h2>
<p>Full name: <code>midgard.dev.profiler.CProfile</code></p>
<p>Signature: <code>()</code></p>
<p>cprofile is used for profiling the whole program</p>
<h3 id="cprofileend">CProfile.<strong>end</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.end</code></p>
<p>Signature: <code>(self)</code></p>
<p>Stop profiler</p>
<h3 id="cprofileextension-notimplementedtype">CProfile.extension (NotImplementedType)</h3>
<p><code>extension = NotImplemented</code></p>
<h3 id="cprofileoption-str">CProfile.option (str)</h3>
<p><code>option = '--profiler'</code></p>
<h3 id="cprofilepip_name-str">CProfile.pip_name (str)</h3>
<p><code>pip_name = 'cprofile'</code></p>
<h3 id="cprofilesetup">CProfile.<strong>setup</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.setup</code></p>
<p>Signature: <code>(self, options)</code></p>
<p>Set up profiler</p>
<h3 id="cprofileshow">CProfile.<strong>show</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.show</code></p>
<p>Signature: <code>(self)</code></p>
<p>Show results of profiler session in console</p>
<h3 id="cprofilestart">CProfile.<strong>start</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.start</code></p>
<p>Signature: <code>(self)</code></p>
<h3 id="cprofilewrite">CProfile.<strong>write</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.write</code></p>
<p>Signature: <code>(self)</code></p>
<p>Write results of profiler session to disk</p>
<h2 id="lineprofiler"><strong>LineProfiler</strong></h2>
<p>Full name: <code>midgard.dev.profiler.LineProfiler</code></p>
<p>Signature: <code>()</code></p>
<p>line_profiler is used to profile one or a few functions in detail</p>
<h3 id="lineprofilerend">LineProfiler.<strong>end</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.end</code></p>
<p>Signature: <code>(self)</code></p>
<p>Stop profiler</p>
<h3 id="lineprofilerextension-notimplementedtype">LineProfiler.extension (NotImplementedType)</h3>
<p><code>extension = NotImplemented</code></p>
<h3 id="lineprofileroption-str">LineProfiler.option (str)</h3>
<p><code>option = '--line_profiler'</code></p>
<h3 id="lineprofilerpip_name-str">LineProfiler.pip_name (str)</h3>
<p><code>pip_name = 'line_profiler'</code></p>
<h3 id="lineprofilersetup">LineProfiler.<strong>setup</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.setup</code></p>
<p>Signature: <code>(self, options)</code></p>
<p>Set up profiler</p>
<h3 id="lineprofilershow">LineProfiler.<strong>show</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.show</code></p>
<p>Signature: <code>(self)</code></p>
<p>Show results of profiler session in console</p>
<h3 id="lineprofilerstart">LineProfiler.<strong>start</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.start</code></p>
<p>Signature: <code>(self)</code></p>
<p>Start profiler</p>
<h3 id="lineprofilerwrite">LineProfiler.<strong>write</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.write</code></p>
<p>Signature: <code>(self)</code></p>
<p>Write results of profiler session to disk</p>
<h2 id="profiler"><strong>Profiler</strong></h2>
<p>Full name: <code>midgard.dev.profiler.Profiler</code></p>
<p>Signature: <code>()</code></p>
<p>Base class for profilers</p>
<h3 id="profilerend">Profiler.<strong>end</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.end</code></p>
<p>Signature: <code>(self)</code></p>
<p>Stop profiler</p>
<h3 id="profilerextension-notimplementedtype">Profiler.extension (NotImplementedType)</h3>
<p><code>extension = NotImplemented</code></p>
<h3 id="profileroption-notimplementedtype">Profiler.option (NotImplementedType)</h3>
<p><code>option = NotImplemented</code></p>
<h3 id="profilerpip_name-notimplementedtype">Profiler.pip_name (NotImplementedType)</h3>
<p><code>pip_name = NotImplemented</code></p>
<h3 id="profilersetup">Profiler.<strong>setup</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.setup</code></p>
<p>Signature: <code>(self, options)</code></p>
<p>Set up profiler</p>
<h3 id="profilershow">Profiler.<strong>show</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.show</code></p>
<p>Signature: <code>(self)</code></p>
<p>Show results of profiler session in console</p>
<h3 id="profilerstart">Profiler.<strong>start</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.start</code></p>
<p>Signature: <code>(self)</code></p>
<p>Start profiler</p>
<h3 id="profilerwrite">Profiler.<strong>write</strong>()</h3>
<p>Full name: <code>midgard.dev.profiler.write</code></p>
<p>Signature: <code>(self)</code></p>
<p>Write results of profiler session to disk</p>
<h1 id="midgarddevtimer">midgard.dev.timer</h1>
<p>Class for timing the running time of functions and code blocks</p>
<p><strong>Description:</strong></p>
<p>The <code>dev.timer</code> can be used to log the running time of functions and general
code blocks. Typically, you will import the <code>Timer</code>-class from within the
module:</p>
<pre><code>from midgard.dev.timer import Timer
</code></pre>
<p>The Timer can then be used in three different ways:</p>
<ol>
<li>
<p>As a decorator to time one function:</p>
<pre><code>@Timer('The time to execute some_function was')
def some_function(some_argument, some_other_argument=some_value):
    pass
</code></pre>
</li>
<li>
<p>As a context manager together with <code>with</code> to time a code block:</p>
<pre><code>with Timer('Finish doing stuff in', logger=logger.debug) as t:
    do_something()
    do_something_else()
</code></pre>
</li>
<li>
<p>With explicit <code>start</code>- and <code>end</code>-statements:</p>
<pre><code>t = Timer()
t.start()
do_something()
do_something_else()
t.end()
</code></pre>
</li>
</ol>
<p>As can be seen in the examples above, <code>Timer()</code> may be called with several
optional parameters, including the text to report when the timer ends and which
logger is used to report the timing. See <code>Timer.__init__</code> for more details.</p>
<h2 id="accumulatedtimer"><strong>AccumulatedTimer</strong></h2>
<p>Full name: <code>midgard.dev.timer.AccumulatedTimer</code></p>
<p>Signature: <code>(text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;) -&gt; None</code></p>
<h3 id="accumulatedtimerelapsed">AccumulatedTimer.<strong>elapsed</strong>()</h3>
<p>Full name: <code>midgard.dev.timer.elapsed</code></p>
<p>Signature: <code>(self) -&gt; float</code></p>
<p>Log the time elapsed</p>
<p>Can be used explicitly to log the time since a timer started without
ending the timer.</p>
<p><strong>Returns:</strong></p>
<p>The time elapsed in seconds.</p>
<h3 id="accumulatedtimerend">AccumulatedTimer.<strong>end</strong>()</h3>
<p>Full name: <code>midgard.dev.timer.end</code></p>
<p>Signature: <code>(self) -&gt; float</code></p>
<p>End the timer and log the time elapsed</p>
<p><strong>Returns:</strong></p>
<p>The time elapsed in seconds.</p>
<h3 id="accumulatedtimerpause">AccumulatedTimer.<strong>pause</strong>()</h3>
<p>Full name: <code>midgard.dev.timer.pause</code></p>
<p>Signature: <code>(self) -&gt; float</code></p>
<p>Pause the timer without logging. Use .start() to restart the timer</p>
<h3 id="accumulatedtimerreset">AccumulatedTimer.<strong>reset</strong>()</h3>
<p>Full name: <code>midgard.dev.timer.reset</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Reset the timer back to 0</p>
<h3 id="accumulatedtimerstart">AccumulatedTimer.<strong>start</strong>()</h3>
<p>Full name: <code>midgard.dev.timer.start</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Start the timer</p>
<h3 id="accumulatedtimertimer">AccumulatedTimer.<strong>timer</strong>()</h3>
<p>Full name: <code>midgard.dev.timer.timer</code></p>
<p>Signature: <code>() -&gt; float</code></p>
<p>Get current value of timer</p>
<p>Using the built-in <code>time.perf_counter</code> to do the timing.</p>
<p><strong>Returns:</strong></p>
<p>Current value of timer.</p>
<h2 id="timer"><strong>Timer</strong></h2>
<p>Full name: <code>midgard.dev.timer.Timer</code></p>
<p>Signature: <code>(text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;) -&gt; None</code></p>
<p>Class for timing running time of functions and code blocks.</p>
<h3 id="timerelapsed">Timer.<strong>elapsed</strong>()</h3>
<p>Full name: <code>midgard.dev.timer.elapsed</code></p>
<p>Signature: <code>(self) -&gt; float</code></p>
<p>Log the time elapsed</p>
<p>Can be used explicitly to log the time since a timer started without
ending the timer.</p>
<p><strong>Returns:</strong></p>
<p>The time elapsed in seconds.</p>
<h3 id="timerend">Timer.<strong>end</strong>()</h3>
<p>Full name: <code>midgard.dev.timer.end</code></p>
<p>Signature: <code>(self) -&gt; float</code></p>
<p>End the timer and log the time elapsed</p>
<p><strong>Returns:</strong></p>
<p>The time elapsed in seconds.</p>
<h3 id="timerpause">Timer.<strong>pause</strong>()</h3>
<p>Full name: <code>midgard.dev.timer.pause</code></p>
<p>Signature: <code>(self) -&gt; float</code></p>
<p>Pause the timer without logging. Use .start() to restart the timer</p>
<h3 id="timerstart">Timer.<strong>start</strong>()</h3>
<p>Full name: <code>midgard.dev.timer.start</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Start the timer</p>
<h3 id="timertimer">Timer.<strong>timer</strong>()</h3>
<p>Full name: <code>midgard.dev.timer.timer</code></p>
<p>Signature: <code>() -&gt; float</code></p>
<p>Get current value of timer</p>
<p>Using the built-in <code>time.perf_counter</code> to do the timing.</p>
<p><strong>Returns:</strong></p>
<p>Current value of timer.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
