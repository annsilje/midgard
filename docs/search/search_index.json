{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Midgard, the Python Geodesy library Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting. Installing Midgard Midgard is available at PyPI . You can install it by simply running python -m pip install midgard Installing Midgard from source Midgard depends on several other brilliant Python packages, like for instance numpy, scipy, astropy etc. We recommend using the Anaconda distribution to ease the installation of these dependencies. Install Anaconda Go to www.anaconda.com/download , and download Anaconda for Python 3. Download the Midgard source code If you have not already done so, download the Midgard source code from Github: github.com/kartverket/midgard . Then enter the main midgard directory before running the install command below. cd midgard Install dependencies You should now install the necessary dependencies using the environment.yml -file. You can do this either in your current conda environment, or choose to create a new midgard -environment. In order to use midgard in other projects you need to install midgard in the same environment as those projects. To install midgard in your current environment, do conda env update -f environment.yml To install midgard in a new environment named midgard and activate it, do conda env create -n midgard -f environment.yml conda activate midgard Install the Midgard package To do the actual installation of Midgard, use the flit packaging tool: python -m flit install --dep production If you want to develop the Midgard package, install it in editable mode using python -m flit install -s On Windows, you can install in editable mode using python -m flit install --pth-file Using Midgard Midgard comes organized into different subpackages. To see info about the different subpackages, use the Python help system: >>> import midgard >>> help(midgard) Information about individual subpackages is also available on the Midgard website .","title":"Home"},{"location":"#midgard-the-python-geodesy-library","text":"Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting.","title":"Midgard, the Python Geodesy library"},{"location":"#installing-midgard","text":"Midgard is available at PyPI . You can install it by simply running python -m pip install midgard","title":"Installing Midgard"},{"location":"#installing-midgard-from-source","text":"Midgard depends on several other brilliant Python packages, like for instance numpy, scipy, astropy etc. We recommend using the Anaconda distribution to ease the installation of these dependencies.","title":"Installing Midgard from source"},{"location":"#install-anaconda","text":"Go to www.anaconda.com/download , and download Anaconda for Python 3.","title":"Install Anaconda"},{"location":"#download-the-midgard-source-code","text":"If you have not already done so, download the Midgard source code from Github: github.com/kartverket/midgard . Then enter the main midgard directory before running the install command below. cd midgard","title":"Download the Midgard source code"},{"location":"#install-dependencies","text":"You should now install the necessary dependencies using the environment.yml -file. You can do this either in your current conda environment, or choose to create a new midgard -environment. In order to use midgard in other projects you need to install midgard in the same environment as those projects. To install midgard in your current environment, do conda env update -f environment.yml To install midgard in a new environment named midgard and activate it, do conda env create -n midgard -f environment.yml conda activate midgard","title":"Install dependencies"},{"location":"#install-the-midgard-package","text":"To do the actual installation of Midgard, use the flit packaging tool: python -m flit install --dep production If you want to develop the Midgard package, install it in editable mode using python -m flit install -s On Windows, you can install in editable mode using python -m flit install --pth-file","title":"Install the Midgard package"},{"location":"#using-midgard","text":"Midgard comes organized into different subpackages. To see info about the different subpackages, use the Python help system: >>> import midgard >>> help(midgard) Information about individual subpackages is also available on the Midgard website .","title":"Using Midgard"},{"location":"api/midgard-collections/","text":"midgard.collections midgard.collections.enums Framework for working with enumerations Description: Custom enumerations used for structured names. You can add your own enumerations in your own application by importing register_enum and using that to register your own enums. Example: Create your own enumeration: from midgard.collections.enums import register_enum @register_enum(\"reference_ellipsoid\") class ReferenceEllipsoid(enum.IntEnum): wgs84 = 1 grs80 = 2 wgs72 = 3 Use enumerations in your code: from midgard.collections import enums enums.get_value(\"gnss_freq_G\", \"L1\") enums.get_value(\"gnss_freq_G\", \"L1\") + 1 enums.get_enum(\"gnss_freq_G\") enums.get_enum(\"gnss_freq_G\").L1 enums.get_enum(\"gnss_freq_G\").L1 + 1 enums.gnss_freq_G.L1 enums.gnss_freq_G.L1 * 2 GPSFrequency Full name: midgard.collections.enums.GPSFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies GPSFrequency.L1 (GPSFrequency) L1 = <GPSFrequency.L1: 1575420000.0> GPSFrequency.L2 (GPSFrequency) L2 = <GPSFrequency.L2: 1227600000.0> GPSFrequency.L5 (GPSFrequency) L5 = <GPSFrequency.L5: 1176450000.0> LogColor Full name: midgard.collections.enums.LogColor Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging LogColor.error (LogColor) error = <LogColor.error: '\\x1b[31m'> LogColor.fatal (LogColor) fatal = <LogColor.fatal: '\\x1b[1m\\x1b[31m'> LogColor.warn (LogColor) warn = <LogColor.warn: '\\x1b[33m'> LogLevel Full name: midgard.collections.enums.LogLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show LogLevel.all (LogLevel) all = <LogLevel.all: 1> LogLevel.debug (LogLevel) debug = <LogLevel.debug: 2> LogLevel.error (LogLevel) error = <LogLevel.error: 5> LogLevel.fatal (LogLevel) fatal = <LogLevel.fatal: 6> LogLevel.info (LogLevel) info = <LogLevel.info: 3> LogLevel.none (LogLevel) none = <LogLevel.none: 7> LogLevel.warn (LogLevel) warn = <LogLevel.warn: 4> NotGiven Full name: midgard.collections.enums.NotGiven Signature: () Dummy class used as a marker for a argument not given, used instead of None because None is valid value WriteLevel Full name: midgard.collections.enums.WriteLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk WriteLevel.analysis (WriteLevel) analysis = <WriteLevel.analysis: 2> WriteLevel.detail (WriteLevel) detail = <WriteLevel.detail: 1> WriteLevel.operational (WriteLevel) operational = <WriteLevel.operational: 3> enums () Full name: midgard.collections.enums.enums Signature: () -> List[str] Return a list of available enums Returns: Names of available enums. get_enum () Full name: midgard.collections.enums.get_enum Signature: (name:str) -> enum.EnumMeta Return a named Enumeration Names are defined by the @register_enum-decorator. If the name-parameter is not a valid enum, the function will raise an UnknownEnumError and list the available enumerations. Args: name : Name used for Enumeration. Returns: Enumeration with the given name. get_value () Full name: midgard.collections.enums.get_value Signature: (name:str, value:str, default:Any=<class 'midgard.collections.enums.NotGiven'>) -> enum.Enum Return the value of a named Enumeration Names are defined by the @register_enum-decorator. Args: name : Name used for Enumeration. value : Value of Enumeration. default : Optional object returned if enumeration does not contain value Returns: Value of enumeration with the given name. gnss_freq_G Full name: midgard.collections.enums.gnss_freq_G Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies gnss_freq_G.L1 (GPSFrequency) L1 = <GPSFrequency.L1: 1575420000.0> gnss_freq_G.L2 (GPSFrequency) L2 = <GPSFrequency.L2: 1227600000.0> gnss_freq_G.L5 (GPSFrequency) L5 = <GPSFrequency.L5: 1176450000.0> has_value () Full name: midgard.collections.enums.has_value Signature: (name:str, value:str) -> bool Check whether a named Enumeration defines a given value Args: name : Name used for Enumeration. value : Value of Enumeration. Returns: True if Enumeration defines value, False otherwise log_color Full name: midgard.collections.enums.log_color Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging log_color.error (LogColor) error = <LogColor.error: '\\x1b[31m'> log_color.fatal (LogColor) fatal = <LogColor.fatal: '\\x1b[1m\\x1b[31m'> log_color.warn (LogColor) warn = <LogColor.warn: '\\x1b[33m'> log_level Full name: midgard.collections.enums.log_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show log_level.all (LogLevel) all = <LogLevel.all: 1> log_level.debug (LogLevel) debug = <LogLevel.debug: 2> log_level.error (LogLevel) error = <LogLevel.error: 5> log_level.fatal (LogLevel) fatal = <LogLevel.fatal: 6> log_level.info (LogLevel) info = <LogLevel.info: 3> log_level.none (LogLevel) none = <LogLevel.none: 7> log_level.warn (LogLevel) warn = <LogLevel.warn: 4> register_enum () Full name: midgard.collections.enums.register_enum Signature: (name:str) -> Callable[[enum.EnumMeta], enum.EnumMeta] Register a named Enumeration This allows for getting Enumerations with the get_enum-function. Args: name : Name used for Enumeration. Returns: Decorator that registers an Enumeration. write_level Full name: midgard.collections.enums.write_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk write_level.analysis (WriteLevel) analysis = <WriteLevel.analysis: 2> write_level.detail (WriteLevel) detail = <WriteLevel.detail: 1> write_level.operational (WriteLevel) operational = <WriteLevel.operational: 3>","title":"midgard.collections"},{"location":"api/midgard-collections/#midgardcollections","text":"","title":"midgard.collections"},{"location":"api/midgard-collections/#midgardcollectionsenums","text":"Framework for working with enumerations Description: Custom enumerations used for structured names. You can add your own enumerations in your own application by importing register_enum and using that to register your own enums. Example: Create your own enumeration: from midgard.collections.enums import register_enum @register_enum(\"reference_ellipsoid\") class ReferenceEllipsoid(enum.IntEnum): wgs84 = 1 grs80 = 2 wgs72 = 3 Use enumerations in your code: from midgard.collections import enums enums.get_value(\"gnss_freq_G\", \"L1\") enums.get_value(\"gnss_freq_G\", \"L1\") + 1 enums.get_enum(\"gnss_freq_G\") enums.get_enum(\"gnss_freq_G\").L1 enums.get_enum(\"gnss_freq_G\").L1 + 1 enums.gnss_freq_G.L1 enums.gnss_freq_G.L1 * 2","title":"midgard.collections.enums"},{"location":"api/midgard-collections/#gpsfrequency","text":"Full name: midgard.collections.enums.GPSFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies","title":"GPSFrequency"},{"location":"api/midgard-collections/#gpsfrequencyl1-gpsfrequency","text":"L1 = <GPSFrequency.L1: 1575420000.0>","title":"GPSFrequency.L1 (GPSFrequency)"},{"location":"api/midgard-collections/#gpsfrequencyl2-gpsfrequency","text":"L2 = <GPSFrequency.L2: 1227600000.0>","title":"GPSFrequency.L2 (GPSFrequency)"},{"location":"api/midgard-collections/#gpsfrequencyl5-gpsfrequency","text":"L5 = <GPSFrequency.L5: 1176450000.0>","title":"GPSFrequency.L5 (GPSFrequency)"},{"location":"api/midgard-collections/#logcolor","text":"Full name: midgard.collections.enums.LogColor Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging","title":"LogColor"},{"location":"api/midgard-collections/#logcolorerror-logcolor","text":"error = <LogColor.error: '\\x1b[31m'>","title":"LogColor.error (LogColor)"},{"location":"api/midgard-collections/#logcolorfatal-logcolor","text":"fatal = <LogColor.fatal: '\\x1b[1m\\x1b[31m'>","title":"LogColor.fatal (LogColor)"},{"location":"api/midgard-collections/#logcolorwarn-logcolor","text":"warn = <LogColor.warn: '\\x1b[33m'>","title":"LogColor.warn (LogColor)"},{"location":"api/midgard-collections/#loglevel","text":"Full name: midgard.collections.enums.LogLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show","title":"LogLevel"},{"location":"api/midgard-collections/#loglevelall-loglevel","text":"all = <LogLevel.all: 1>","title":"LogLevel.all (LogLevel)"},{"location":"api/midgard-collections/#logleveldebug-loglevel","text":"debug = <LogLevel.debug: 2>","title":"LogLevel.debug (LogLevel)"},{"location":"api/midgard-collections/#loglevelerror-loglevel","text":"error = <LogLevel.error: 5>","title":"LogLevel.error (LogLevel)"},{"location":"api/midgard-collections/#loglevelfatal-loglevel","text":"fatal = <LogLevel.fatal: 6>","title":"LogLevel.fatal (LogLevel)"},{"location":"api/midgard-collections/#loglevelinfo-loglevel","text":"info = <LogLevel.info: 3>","title":"LogLevel.info (LogLevel)"},{"location":"api/midgard-collections/#loglevelnone-loglevel","text":"none = <LogLevel.none: 7>","title":"LogLevel.none (LogLevel)"},{"location":"api/midgard-collections/#loglevelwarn-loglevel","text":"warn = <LogLevel.warn: 4>","title":"LogLevel.warn (LogLevel)"},{"location":"api/midgard-collections/#notgiven","text":"Full name: midgard.collections.enums.NotGiven Signature: () Dummy class used as a marker for a argument not given, used instead of None because None is valid value","title":"NotGiven"},{"location":"api/midgard-collections/#writelevel","text":"Full name: midgard.collections.enums.WriteLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk","title":"WriteLevel"},{"location":"api/midgard-collections/#writelevelanalysis-writelevel","text":"analysis = <WriteLevel.analysis: 2>","title":"WriteLevel.analysis (WriteLevel)"},{"location":"api/midgard-collections/#writeleveldetail-writelevel","text":"detail = <WriteLevel.detail: 1>","title":"WriteLevel.detail (WriteLevel)"},{"location":"api/midgard-collections/#writeleveloperational-writelevel","text":"operational = <WriteLevel.operational: 3>","title":"WriteLevel.operational (WriteLevel)"},{"location":"api/midgard-collections/#enums","text":"Full name: midgard.collections.enums.enums Signature: () -> List[str] Return a list of available enums Returns: Names of available enums.","title":"enums()"},{"location":"api/midgard-collections/#get_enum","text":"Full name: midgard.collections.enums.get_enum Signature: (name:str) -> enum.EnumMeta Return a named Enumeration Names are defined by the @register_enum-decorator. If the name-parameter is not a valid enum, the function will raise an UnknownEnumError and list the available enumerations. Args: name : Name used for Enumeration. Returns: Enumeration with the given name.","title":"get_enum()"},{"location":"api/midgard-collections/#get_value","text":"Full name: midgard.collections.enums.get_value Signature: (name:str, value:str, default:Any=<class 'midgard.collections.enums.NotGiven'>) -> enum.Enum Return the value of a named Enumeration Names are defined by the @register_enum-decorator. Args: name : Name used for Enumeration. value : Value of Enumeration. default : Optional object returned if enumeration does not contain value Returns: Value of enumeration with the given name.","title":"get_value()"},{"location":"api/midgard-collections/#gnss_freq_g","text":"Full name: midgard.collections.enums.gnss_freq_G Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies","title":"gnss_freq_G"},{"location":"api/midgard-collections/#gnss_freq_gl1-gpsfrequency","text":"L1 = <GPSFrequency.L1: 1575420000.0>","title":"gnss_freq_G.L1 (GPSFrequency)"},{"location":"api/midgard-collections/#gnss_freq_gl2-gpsfrequency","text":"L2 = <GPSFrequency.L2: 1227600000.0>","title":"gnss_freq_G.L2 (GPSFrequency)"},{"location":"api/midgard-collections/#gnss_freq_gl5-gpsfrequency","text":"L5 = <GPSFrequency.L5: 1176450000.0>","title":"gnss_freq_G.L5 (GPSFrequency)"},{"location":"api/midgard-collections/#has_value","text":"Full name: midgard.collections.enums.has_value Signature: (name:str, value:str) -> bool Check whether a named Enumeration defines a given value Args: name : Name used for Enumeration. value : Value of Enumeration. Returns: True if Enumeration defines value, False otherwise","title":"has_value()"},{"location":"api/midgard-collections/#log_color","text":"Full name: midgard.collections.enums.log_color Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging","title":"log_color"},{"location":"api/midgard-collections/#log_colorerror-logcolor","text":"error = <LogColor.error: '\\x1b[31m'>","title":"log_color.error (LogColor)"},{"location":"api/midgard-collections/#log_colorfatal-logcolor","text":"fatal = <LogColor.fatal: '\\x1b[1m\\x1b[31m'>","title":"log_color.fatal (LogColor)"},{"location":"api/midgard-collections/#log_colorwarn-logcolor","text":"warn = <LogColor.warn: '\\x1b[33m'>","title":"log_color.warn (LogColor)"},{"location":"api/midgard-collections/#log_level","text":"Full name: midgard.collections.enums.log_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show","title":"log_level"},{"location":"api/midgard-collections/#log_levelall-loglevel","text":"all = <LogLevel.all: 1>","title":"log_level.all (LogLevel)"},{"location":"api/midgard-collections/#log_leveldebug-loglevel","text":"debug = <LogLevel.debug: 2>","title":"log_level.debug (LogLevel)"},{"location":"api/midgard-collections/#log_levelerror-loglevel","text":"error = <LogLevel.error: 5>","title":"log_level.error (LogLevel)"},{"location":"api/midgard-collections/#log_levelfatal-loglevel","text":"fatal = <LogLevel.fatal: 6>","title":"log_level.fatal (LogLevel)"},{"location":"api/midgard-collections/#log_levelinfo-loglevel","text":"info = <LogLevel.info: 3>","title":"log_level.info (LogLevel)"},{"location":"api/midgard-collections/#log_levelnone-loglevel","text":"none = <LogLevel.none: 7>","title":"log_level.none (LogLevel)"},{"location":"api/midgard-collections/#log_levelwarn-loglevel","text":"warn = <LogLevel.warn: 4>","title":"log_level.warn (LogLevel)"},{"location":"api/midgard-collections/#register_enum","text":"Full name: midgard.collections.enums.register_enum Signature: (name:str) -> Callable[[enum.EnumMeta], enum.EnumMeta] Register a named Enumeration This allows for getting Enumerations with the get_enum-function. Args: name : Name used for Enumeration. Returns: Decorator that registers an Enumeration.","title":"register_enum()"},{"location":"api/midgard-collections/#write_level","text":"Full name: midgard.collections.enums.write_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk","title":"write_level"},{"location":"api/midgard-collections/#write_levelanalysis-writelevel","text":"analysis = <WriteLevel.analysis: 2>","title":"write_level.analysis (WriteLevel)"},{"location":"api/midgard-collections/#write_leveldetail-writelevel","text":"detail = <WriteLevel.detail: 1>","title":"write_level.detail (WriteLevel)"},{"location":"api/midgard-collections/#write_leveloperational-writelevel","text":"operational = <WriteLevel.operational: 3>","title":"write_level.operational (WriteLevel)"},{"location":"api/midgard-config/","text":"midgard.config midgard.config.config Midgard library module for handling of configuration settings Description: A Configuration consists of one or several sections. Each ConfigurationSection consists of one or more entries. Each ConfigurationEntry consists of a key and a value. Examples: For basic use, an entry is looked up by simple attribute access. For instance if cfg is a Configuration with the section midgard which has an entry foo = bar : >>> cfg = Configuration(\"config_name\") >>> cfg.update(\"midgard\", \"foo\", \"bar\") >>> cfg.midgard.foo ConfigurationEntry(key='foo', value='bar') ConfigurationEntry has several access methods that convert the entry to a given data type: >>> cfg.update(\"midgard\", \"foo_pi\", 3.14, source=\"command line\") >>> cfg.midgard.foo_pi ConfigurationEntry(key='foo_pi', value='3.14') >>> cfg.midgard.foo_pi.float 3.14 >>> cfg.midgard.foo_pi.str '3.14' >>> cfg.midgard.foo_pi.tuple ('3.14',) Sources: Each configuration entry records its source. That is, where that entry was defined. Examples include read from file, set as a command line option, or programmatically from a dictionary. The source can be looked up on an individual entry, or for all entries in a configuration. >>> cfg.midgard.foo_pi.source 'command line' >>> cfg.sources # doctest: +SKIP {'/home/midgard/midgard.conf', 'command line'} Profiles: Fallback Configuration: Master Section: Replacement Variables: Help text and Type hints: CasedConfigParser Full name: midgard.config.config.CasedConfigParser Signature: (defaults=None, dict_type=<class 'collections.OrderedDict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x7f1507871200>, converters=<object object at 0x7f1507871200>) ConfigParser with case-sensitive keys CasedConfigParser.BOOLEAN_STATES (dict) BOOLEAN_STATES = {'1': True, 'yes': True, 'true': True, 'on': True, '0': False, 'no': False, 'false': False, 'off': False} CasedConfigParser.NONSPACECRE (SRE_Pattern) NONSPACECRE = re.compile('\\\\S') CasedConfigParser.OPTCRE (SRE_Pattern) OPTCRE = re.compile('\\n (?P<option>.*?) # very permissive!\\n \\\\s*(?P<vi>=|:)\\\\s* # any number of space/tab,\\n # followed by any of t, re.VERBOSE) CasedConfigParser.OPTCRE_NV (SRE_Pattern) OPTCRE_NV = re.compile('\\n (?P<option>.*?) # very permissive!\\n \\\\s*(?: # any number of space/tab,\\n (?P<vi>=|:)\\\\s* # optionally followed , re.VERBOSE) CasedConfigParser.SECTCRE (SRE_Pattern) SECTCRE = re.compile('\\n \\\\[ # [\\n (?P<header>[^]]+) # very permissive!\\n \\\\] # ]\\n ', re.VERBOSE) CasedConfigParser. optionxform () Full name: midgard.config.config.optionxform Signature: (self, optionstr:str) -> str Do not turn optionstr (key) into lowercase Configuration Full name: midgard.config.config.Configuration Signature: (name:str) -> None Represents a Configuration Configuration. as_dict () Full name: midgard.config.config.as_dict Signature: (self, getters:Union[Dict[str, Dict[str, str]], NoneType]=None, default_getter:str='str') -> Dict[str, Dict[str, Any]] The configuration represented as a dictionary Args: getters : How to get the value of each entry in each section. default_getter : How to get the value of entries not specified in getters. Returns: Representation of the configuration as a nested dictionary. Configuration. as_str () Full name: midgard.config.config.as_str Signature: (self, width:Union[int, NoneType]=None, key_width:int=30, only_used:bool=False, metadata:bool=True) -> str The configuration represented as a string This is simililar to what is shown by str(configuration) (and implemented by __str__ ), but has more flexibility. Args: width : Width of text for wrapping. Default is width of console. key_width : Width of the key column. Default is 30 characters. only_used : Only include configuration entries that has been used so far. metadata : Include metadata like type and help text. Returns: String representation of the configuration. Configuration. clear () Full name: midgard.config.config.clear Signature: (self) -> None Clear the configuration Configuration. clear_vars () Full name: midgard.config.config.clear_vars Signature: (self) -> None Clear the configuration variables Configuration. exists () Full name: midgard.config.config.exists Signature: (self, key:str, section:Union[str, NoneType]=None) -> bool Check if a configuration entry exists Args: key : Name of option (key in the configuration entry). section : Section in the configuration in which to look up the key. Returns: True if the configuration entry exists, otherwise False. Configuration. get () Full name: midgard.config.config.get Signature: (self, key:str, value:Union[str, NoneType]=None, section:Union[str, NoneType]=None, default:Union[str, NoneType]=None) -> 'ConfigurationEntry' Get an entry from a configuration with possibility for override and default value A value for an entry is found using the following priorities: 1. An explicit value given in `value`. None is used as a marker for no value. 2. Looked up in the current configuration. 3. Looked up in any fallback confiurations that are defined. 4. The default value is used. If value is not None, that value is simply returned as a ConfigurationEntry . If default is not given (is None), and a value is not found in any other way, a MissingEntryError is raised. Args: key : Name of option (key in the configuration entry). value : Value of entry. Used for overriding the configuration. section : Section in the configuration in which to look up the key. default : Default value that is returned if value is not found any other way. Returns: Entry representing the value. Configuration. read_from_file () Full name: midgard.config.config.read_from_file Signature: (cfg_name:str, *file_paths:Union[str, pathlib.Path]) -> 'Configuration' Read a configuration from one or more files Args: file_paths : File(s) that will be read. Returns: A Configuration representing the file(s). Configuration. update () Full name: midgard.config.config.update Signature: (self, section:str, key:str, value:str, *, profile:Union[str, NoneType]=None, source:str='unknown', meta:Union[Dict[str, str], NoneType]=None, allow_new:bool=True, _update_sections:bool=True) -> None Update a configuration section with a configuration entry If allow_new is False, the configuration entry must already exist. If it is True the update is allowed to create a new section and a new entry is necessary. The _update_sections flag can be used to not update the sections of the configuration, only the profiles. This should typically not be done, but is used by some of the other update methods which update the sections themselves. Args: section : Section to update. key : Key of entry. value : Value of entry. profile : Profile to update. source : Source of the update. meta : Metadata like help text and type hints for the entry. allow_new : Whether to allow the creation of a new section and entry. Configuration. update_from_config_section () Full name: midgard.config.config.update_from_config_section Signature: (self, other_section:'ConfigurationSection', section:Union[str, NoneType]=None, allow_new:bool=True) -> None Configuration. update_from_dict () Full name: midgard.config.config.update_from_dict Signature: (self, cfg_dict:Dict[str, Any], section:Union[str, NoneType]=None, source:str='dictionary', allow_new:bool=True) -> None Configuration. update_from_file () Full name: midgard.config.config.update_from_file Signature: (self, file_path:Union[str, pathlib.Path], allow_new:bool=True, interpolate:bool=False, case_sensitive:bool=False) -> None Update the configuration from a configuration file The Python ConfigParser is used to read the file. The file format that is supported is described at https://docs.python.org/library/configparser.html Different profiles in a configuration file are denoted by double underscores in the sections names. For instance will the following configuration have a foo profile in the spam section (in addition to the default profile): [spam] ... [spam__foo] ... The file may contain a special section called __replace__ which may contain key-value pairs which will replace format-style strings in keys and values in the rest of the file. Additionally, the file may contain a special section called __vars__ . The key-value pairs from this section will be added to the dictionary of the configuration. If interpolate is set to True, ExtendedInterpolation of variables in the configuration file is used. This means that variables of the form ${key:section} can be used for references within the file. See https://docs.python.org/library/configparser.html#configparser.ExtendedInterpolation for details. Args: file_path : Path to the configuration file. allow_new : Whether to allow the creation of new sections and entries. interpolate : Whether to interpolate variables in the configuration file. case_sensitive : Whether to read keys as case sensitive (or convert to lower case). Configuration. update_from_options () Full name: midgard.config.config.update_from_options Signature: (self, options:Union[List[str], NoneType]=None, profile:Union[str, NoneType]=None, source:str='command line', allow_new:bool=False) -> None Configuration. update_on_file () Full name: midgard.config.config.update_on_file Signature: (file_path:Union[str, pathlib.Path], **as_str_args:Any) -> Generator Context manager for updating a configuration on file Configuration. update_vars () Full name: midgard.config.config.update_vars Signature: (self, new_vars:Dict[str, str]) -> None Update the configuration variables Configuration. write_to_file () Full name: midgard.config.config.write_to_file Signature: (self, file_path:Union[str, pathlib.Path], **as_str_args:Any) -> None Write the configuration to a file In addition to the file path, arguments can be specified and will be passed on to the as_str() function. See as_str() for more information. Todo: Use files.open_path ConfigurationEntry Full name: midgard.config.config.ConfigurationEntry Signature: (key:str, value:Any, *, source:str='', meta:Union[Dict[str, str], NoneType]=None, vars_dict:Union[Dict[str, str], NoneType]=None, _used_as:Union[Set[str], NoneType]=None) -> None ConfigurationEntry. as_bool () Full name: midgard.config.config.as_bool Signature: (self) -> bool Value of ConfigurationEntry converted to a boolean The conversion is done by looking up the string value of the entry in _BOOLEAN_STATES. ConfigurationEntry. as_date () Full name: midgard.config.config.as_date Signature: (self, format:str='%Y-%m-%d') -> datetime.date Value of ConfigurationEntry converted to a date object Args: format (String): Format string, see strftime for information about the string. Returns: Date : Value of entry. ConfigurationEntry. as_datetime () Full name: midgard.config.config.as_datetime Signature: (self, format:str='%Y-%m-%d %H:%M:%S') -> datetime.datetime Value of ConfigurationEntry converted to a datetime object Args: format (String): Format string, see strftime for information about the string. Returns: Datetime : Value of entry. ConfigurationEntry. as_dict () Full name: midgard.config.config.as_dict Signature: (self, item_split_re:str='[\\\\s,]', key_value_split_re:str='[:]', convert:Callable=<class 'str'>, maxsplit:int=0) -> Dict[str, Any] Value of ConfigurationEntry converted to a dictionary By default the dictionary is created by splitting items at commas and whitespace, and key from value at colons. Args: item_split_re : Regular expression used to split entry into items. key_value_split_re : Regular expression used to split items into keys and values. convert : Function used to convert each value in the dictionary. maxsplit : If nonzero, at most maxsplit splits occur when splitting entry into items. Returns: Value of entry as dict. ConfigurationEntry. as_enum () Full name: midgard.config.config.as_enum Signature: (self, enum:str) -> enum.Enum Value of ConfigurationEntry converted to an enumeration Args: enum (String): Name of Enum. Returns: Enum : Value of entry as Enum. ConfigurationEntry. as_float () Full name: midgard.config.config.as_float Signature: (self) -> float Value of ConfigurationEntry converted to a float ConfigurationEntry. as_int () Full name: midgard.config.config.as_int Signature: (self) -> int Value of ConfigurationEntry converted to an integer ConfigurationEntry. as_list () Full name: midgard.config.config.as_list Signature: (self, split_re:str='[\\\\s,]', convert:Callable=<class 'str'>, maxsplit:int=0) -> List[Any] Value of ConfigurationEntry converted to a list The entry is converted to a list by using the split_re -regular expression. By default the entry will be split at commas and whitespace. Args: split_re : Regular expression used to split entry into list. convert : Function used to convert each element of the list. maxsplit : If nonzero, at most maxsplit splits occur. Returns: Value of entry as list. ConfigurationEntry. as_list_of_lists () Full name: midgard.config.config.as_list_of_lists Signature: (self, split_res:Tuple[str, ...]=('[\\\\s,]', '[^_\\\\w]'), num_elements:Union[int, NoneType]=None, convert:Callable=<class 'str'>) -> List[List[Any]] ConfigurationEntry. as_path () Full name: midgard.config.config.as_path Signature: (self) -> pathlib.Path Value of ConfigurationEntry interpreted as a path string ConfigurationEntry. as_str () Full name: midgard.config.config.as_str Signature: (self) -> str Value of ConfigurationEntry as string ConfigurationEntry. as_tuple () Full name: midgard.config.config.as_tuple Signature: (self, split_re:str='[\\\\s,]', convert:Callable=<class 'str'>, maxsplit:int=0) -> Tuple[Any, ...] Value of ConfigurationEntry converted to a tuple The entry is converted to a tuple by using the split_re -regular expression. By default the entry will be split at commas and whitespace. Args: split_re : Regular expression used to split entry into tuple. convert : Function used to convert each element of the tuple. maxsplit : If nonzero, at most maxsplit splits occur. Returns: Value of entry as tuple. ConfigurationEntry. entry_as_str () Full name: midgard.config.config.entry_as_str Signature: (self, width:Union[int, NoneType]=None, key_width:int=30, metadata:bool=True) -> str The configuration entry represented as a string This is simililar to what is shown by str(entry) (and implemented by __str__ ), but has more flexibility. Args: width : Width of text for wrapping. Default is width of console. key_width : Width of the key column. Default is 30 characters. metadata : Include metadata like type and help text. Returns: String representation of the configuration entry. ConfigurationEntry. replace () Full name: midgard.config.config.replace Signature: (self, default:Union[str, NoneType]=None, **replace_vars:str) -> 'ConfigurationEntry' ConfigurationSection Full name: midgard.config.config.ConfigurationSection Signature: (name:str) -> None ConfigurationSection. as_dict () Full name: midgard.config.config.as_dict Signature: (self, getters:Dict[str, str]=None, default_getter:str='str') -> Dict[str, Any] The configuration section represented as a dictionary Args: getters : How to get the value of each entry in the section. default_getter : How to get the value of entries not specified in getters. Returns: Representation of the configuration section as a dictionary. ConfigurationSection. as_list () Full name: midgard.config.config.as_list Signature: (self) -> List[str] List of keys of entries in configuration section Returns: List of keys of entries in configuration section. ConfigurationSection. as_str () Full name: midgard.config.config.as_str Signature: (self, width:Union[int, NoneType]=None, key_width:int=30, only_used:bool=False, metadata:bool=True) -> str The configuration section represented as a string This is simililar to what is shown by str(section) (and implemented by __str__ ), but has more flexibility. Args: width : Width of text for wrapping. Default is width of console. key_width : Width of the key column. Default is 30 characters. only_used : Only include configuration entries that has been used so far. metadata : Include metadata like type and help text. Returns: String representation of the configuration section. ConfigurationSection. exists () Full name: midgard.config.config.exists Signature: (self, key:str) -> bool Check if key exists in section Args: key : Name of configuration key. Returns: True if key is in section, False otherwise. FMT_date (str) FMT_date = '%Y-%m-%d' FMT_datetime (str) FMT_datetime = '%Y-%m-%d %H:%M:%S' FMT_dt_file (str) FMT_dt_file = '%Y%m%d-%H%M%S' midgard.config.files Midgard library module for opening files based on a special configuration Example: from midgard.config import files with files.open('eopc04_iau', mode='rt') as fid: for line in fid: print(line.strip()) Description: This module handles opening of files registered in a special configuration, typically a configuration file. The cfg.files.open and cfg.files.open_path methods are both wrappers around the built-in open function, and behave mainly similar. In particular, they accept all the same keyword arguments (like for instance mode). Furthermore, to make sure files are properly closed they should normally be used with a context manager as in the example above. FileConfiguration Full name: midgard.config.files.FileConfiguration Signature: (name:str) -> None Configuration for handling files FileConfiguration. download_file () Full name: midgard.config.files.download_file Signature: (self, file_key:str, file_vars:Union[Dict[str, str], NoneType]=None, file_path:Union[pathlib.Path, NoneType]=None, create_dirs:bool=True, **path_args:Any) -> Union[pathlib.Path, NoneType] Download a file from the web and save it to disk Use pycurl (libcurl) to do the actual downloading. Requests might be nicer for this, but turned out to be much slower (and in practice unusable for bigger files) and also not really supporting ftp-downloads. Args: file_key : File key that should be downloaded. file_vars : File variables used to find path from file_key. file_path : Path where file will be saved, default is to read from configuration. create_dirs : Create directories as necessary before downloading file. path_args : Arguments passed on to .path() to find file_path. Returns: Path to downloaded file, None if no file was downloaded. FileConfiguration.download_missing (bool) download_missing = True FileConfiguration. encoding () Full name: midgard.config.files.encoding Signature: (self, file_key) Look up the encoding for a given file key Args: file_key (String): Key that is looked up in the configuration. Returns: String : Name of encoding. If encoding is not specified None is returned. FileConfiguration. glob_paths () Full name: midgard.config.files.glob_paths Signature: (self, file_key:str, file_vars:Union[Dict[str, str], NoneType]=None, is_zipped:Union[bool, NoneType]=None) -> List[pathlib.Path] Find all filepaths matching a filename pattern Using pathlib.Path.glob() here is not trivial because we need to split into a base directory to start searching from and a pattern which may include directories. With glob.glob() this is trivial. The downside is that it only returns strings and not pathlib.Paths. FileConfiguration. glob_variable () Full name: midgard.config.files.glob_variable Signature: (self, file_key, variable, pattern, file_vars=None) Find all possible values of variable FileConfiguration. is_path_zipped () Full name: midgard.config.files.is_path_zipped Signature: (file_path) Indicate whether a path is to a gzipped file or not For now, this simply checks whether the path ends in .gz or not. Args: file_path (Path): Path to a file. Returns: Boolean : True if path is to a gzipped file, False otherwise. FileConfiguration. open () Full name: midgard.config.files.open Signature: (self, file_key:str, file_vars:Dict[str, str]=None, create_dirs:bool=False, is_zipped:Union[bool, NoneType]=None, download_missing:bool=True, use_aliases:bool=True, logger:Union[Callable, NoneType]=None, **open_args:Any) -> Iterator Open a file based on information in a configuration Open a file based on file key which is looked up in the configuration. The method automatically handles reading from gzipped files if the filename is specified with the special {gz}-ending (including the curly braces) in the file list. In that case, the mode should be specified to be 'rt' if the contents of the file should be treated as text. If both a zipped and an unzipped version is available, the zipped version is used. This can be overridden by specifying True or False for the is_zipped-parameter. This function behaves similar to the built-in open-function, and should typically be used with a context manager as follows: Example: with cfg.open('eopc04_iau', mode='rt') as fid: for line in fid: print(line.strip()) Args: file_key : String that is looked up in the configuration file list. file_vars : Dict, extra variables used to replace variables in file name and path. create_dirs : True or False, if True missing directories are created. iz_zipped : None, True, or False. Whether the file open_args : All keyword arguments are passed on to open_path. Returns: File object representing the file. FileConfiguration. path () Full name: midgard.config.files.path Signature: (self, file_key:str, file_vars:Union[Dict[str, str], NoneType]=None, default:Union[str, NoneType]=None, is_zipped:Union[bool, NoneType]=None, download_missing:bool=False, use_aliases:bool=True) -> pathlib.Path Construct a filepath for a given file with variables If is_zipped is None, and the file_path contains <filename>{gz} , the file will be assumed to be a gzip-file if there exists a file named <filename>.gz . When setting use_aliases to True, the aliases as specified in the files configuration file represent alternative filenames. In particular: - if directory / file_name exists it is returned - otherwise the first directory / alias that exists is returned - if none of these exist, directory / file_name is returned Args: file_key (String): Key that is looked up in the configuration. file_vars (Dict): Values used to replace variables in file name and path. default (String): Value to use for variables that are not in file_vars. is_zipped (Bool/None): True, False or None. If True, open with gzip. If None automatically decide. download_missing (Bool): Whether to try to download missing files. use_aliases (Bool): Fall back on aliases if file does not exist. Return: Path: Full path with replaced variables in file name and path. FileConfiguration. url () Full name: midgard.config.files.url Signature: (self, file_key, file_vars=None, default=None, is_zipped=None, use_aliases=False) Construct a URL for a given file with variables If is_zipped is None, and the url contains <filename>{gz} , the url will be assumed to point to a gzip-file if there exists a file named <filename>.gz on the server. Args: file_key : Key that is looked up in the configuration. file_vars : Values used to replace variables in file name and path. default : Value to use for variables that are not in file_vars. is_zipped : True, False or None. If True, open with gzip. If None automatically decide. use_aliases : Fall back on aliases if URL does not exist - may be slow. Return: String: Full URL with replaced variables in file name and url.","title":"midgard.config"},{"location":"api/midgard-config/#midgardconfig","text":"","title":"midgard.config"},{"location":"api/midgard-config/#midgardconfigconfig","text":"Midgard library module for handling of configuration settings Description: A Configuration consists of one or several sections. Each ConfigurationSection consists of one or more entries. Each ConfigurationEntry consists of a key and a value. Examples: For basic use, an entry is looked up by simple attribute access. For instance if cfg is a Configuration with the section midgard which has an entry foo = bar : >>> cfg = Configuration(\"config_name\") >>> cfg.update(\"midgard\", \"foo\", \"bar\") >>> cfg.midgard.foo ConfigurationEntry(key='foo', value='bar') ConfigurationEntry has several access methods that convert the entry to a given data type: >>> cfg.update(\"midgard\", \"foo_pi\", 3.14, source=\"command line\") >>> cfg.midgard.foo_pi ConfigurationEntry(key='foo_pi', value='3.14') >>> cfg.midgard.foo_pi.float 3.14 >>> cfg.midgard.foo_pi.str '3.14' >>> cfg.midgard.foo_pi.tuple ('3.14',) Sources: Each configuration entry records its source. That is, where that entry was defined. Examples include read from file, set as a command line option, or programmatically from a dictionary. The source can be looked up on an individual entry, or for all entries in a configuration. >>> cfg.midgard.foo_pi.source 'command line' >>> cfg.sources # doctest: +SKIP {'/home/midgard/midgard.conf', 'command line'} Profiles: Fallback Configuration: Master Section: Replacement Variables: Help text and Type hints:","title":"midgard.config.config"},{"location":"api/midgard-config/#casedconfigparser","text":"Full name: midgard.config.config.CasedConfigParser Signature: (defaults=None, dict_type=<class 'collections.OrderedDict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x7f1507871200>, converters=<object object at 0x7f1507871200>) ConfigParser with case-sensitive keys","title":"CasedConfigParser"},{"location":"api/midgard-config/#casedconfigparserboolean_states-dict","text":"BOOLEAN_STATES = {'1': True, 'yes': True, 'true': True, 'on': True, '0': False, 'no': False, 'false': False, 'off': False}","title":"CasedConfigParser.BOOLEAN_STATES (dict)"},{"location":"api/midgard-config/#casedconfigparsernonspacecre-sre_pattern","text":"NONSPACECRE = re.compile('\\\\S')","title":"CasedConfigParser.NONSPACECRE (SRE_Pattern)"},{"location":"api/midgard-config/#casedconfigparseroptcre-sre_pattern","text":"OPTCRE = re.compile('\\n (?P<option>.*?) # very permissive!\\n \\\\s*(?P<vi>=|:)\\\\s* # any number of space/tab,\\n # followed by any of t, re.VERBOSE)","title":"CasedConfigParser.OPTCRE (SRE_Pattern)"},{"location":"api/midgard-config/#casedconfigparseroptcre_nv-sre_pattern","text":"OPTCRE_NV = re.compile('\\n (?P<option>.*?) # very permissive!\\n \\\\s*(?: # any number of space/tab,\\n (?P<vi>=|:)\\\\s* # optionally followed , re.VERBOSE)","title":"CasedConfigParser.OPTCRE_NV (SRE_Pattern)"},{"location":"api/midgard-config/#casedconfigparsersectcre-sre_pattern","text":"SECTCRE = re.compile('\\n \\\\[ # [\\n (?P<header>[^]]+) # very permissive!\\n \\\\] # ]\\n ', re.VERBOSE)","title":"CasedConfigParser.SECTCRE (SRE_Pattern)"},{"location":"api/midgard-config/#casedconfigparseroptionxform","text":"Full name: midgard.config.config.optionxform Signature: (self, optionstr:str) -> str Do not turn optionstr (key) into lowercase","title":"CasedConfigParser.optionxform()"},{"location":"api/midgard-config/#configuration","text":"Full name: midgard.config.config.Configuration Signature: (name:str) -> None Represents a Configuration","title":"Configuration"},{"location":"api/midgard-config/#configurationas_dict","text":"Full name: midgard.config.config.as_dict Signature: (self, getters:Union[Dict[str, Dict[str, str]], NoneType]=None, default_getter:str='str') -> Dict[str, Dict[str, Any]] The configuration represented as a dictionary Args: getters : How to get the value of each entry in each section. default_getter : How to get the value of entries not specified in getters. Returns: Representation of the configuration as a nested dictionary.","title":"Configuration.as_dict()"},{"location":"api/midgard-config/#configurationas_str","text":"Full name: midgard.config.config.as_str Signature: (self, width:Union[int, NoneType]=None, key_width:int=30, only_used:bool=False, metadata:bool=True) -> str The configuration represented as a string This is simililar to what is shown by str(configuration) (and implemented by __str__ ), but has more flexibility. Args: width : Width of text for wrapping. Default is width of console. key_width : Width of the key column. Default is 30 characters. only_used : Only include configuration entries that has been used so far. metadata : Include metadata like type and help text. Returns: String representation of the configuration.","title":"Configuration.as_str()"},{"location":"api/midgard-config/#configurationclear","text":"Full name: midgard.config.config.clear Signature: (self) -> None Clear the configuration","title":"Configuration.clear()"},{"location":"api/midgard-config/#configurationclear_vars","text":"Full name: midgard.config.config.clear_vars Signature: (self) -> None Clear the configuration variables","title":"Configuration.clear_vars()"},{"location":"api/midgard-config/#configurationexists","text":"Full name: midgard.config.config.exists Signature: (self, key:str, section:Union[str, NoneType]=None) -> bool Check if a configuration entry exists Args: key : Name of option (key in the configuration entry). section : Section in the configuration in which to look up the key. Returns: True if the configuration entry exists, otherwise False.","title":"Configuration.exists()"},{"location":"api/midgard-config/#configurationget","text":"Full name: midgard.config.config.get Signature: (self, key:str, value:Union[str, NoneType]=None, section:Union[str, NoneType]=None, default:Union[str, NoneType]=None) -> 'ConfigurationEntry' Get an entry from a configuration with possibility for override and default value A value for an entry is found using the following priorities: 1. An explicit value given in `value`. None is used as a marker for no value. 2. Looked up in the current configuration. 3. Looked up in any fallback confiurations that are defined. 4. The default value is used. If value is not None, that value is simply returned as a ConfigurationEntry . If default is not given (is None), and a value is not found in any other way, a MissingEntryError is raised. Args: key : Name of option (key in the configuration entry). value : Value of entry. Used for overriding the configuration. section : Section in the configuration in which to look up the key. default : Default value that is returned if value is not found any other way. Returns: Entry representing the value.","title":"Configuration.get()"},{"location":"api/midgard-config/#configurationread_from_file","text":"Full name: midgard.config.config.read_from_file Signature: (cfg_name:str, *file_paths:Union[str, pathlib.Path]) -> 'Configuration' Read a configuration from one or more files Args: file_paths : File(s) that will be read. Returns: A Configuration representing the file(s).","title":"Configuration.read_from_file()"},{"location":"api/midgard-config/#configurationupdate","text":"Full name: midgard.config.config.update Signature: (self, section:str, key:str, value:str, *, profile:Union[str, NoneType]=None, source:str='unknown', meta:Union[Dict[str, str], NoneType]=None, allow_new:bool=True, _update_sections:bool=True) -> None Update a configuration section with a configuration entry If allow_new is False, the configuration entry must already exist. If it is True the update is allowed to create a new section and a new entry is necessary. The _update_sections flag can be used to not update the sections of the configuration, only the profiles. This should typically not be done, but is used by some of the other update methods which update the sections themselves. Args: section : Section to update. key : Key of entry. value : Value of entry. profile : Profile to update. source : Source of the update. meta : Metadata like help text and type hints for the entry. allow_new : Whether to allow the creation of a new section and entry.","title":"Configuration.update()"},{"location":"api/midgard-config/#configurationupdate_from_config_section","text":"Full name: midgard.config.config.update_from_config_section Signature: (self, other_section:'ConfigurationSection', section:Union[str, NoneType]=None, allow_new:bool=True) -> None","title":"Configuration.update_from_config_section()"},{"location":"api/midgard-config/#configurationupdate_from_dict","text":"Full name: midgard.config.config.update_from_dict Signature: (self, cfg_dict:Dict[str, Any], section:Union[str, NoneType]=None, source:str='dictionary', allow_new:bool=True) -> None","title":"Configuration.update_from_dict()"},{"location":"api/midgard-config/#configurationupdate_from_file","text":"Full name: midgard.config.config.update_from_file Signature: (self, file_path:Union[str, pathlib.Path], allow_new:bool=True, interpolate:bool=False, case_sensitive:bool=False) -> None Update the configuration from a configuration file The Python ConfigParser is used to read the file. The file format that is supported is described at https://docs.python.org/library/configparser.html Different profiles in a configuration file are denoted by double underscores in the sections names. For instance will the following configuration have a foo profile in the spam section (in addition to the default profile): [spam] ... [spam__foo] ... The file may contain a special section called __replace__ which may contain key-value pairs which will replace format-style strings in keys and values in the rest of the file. Additionally, the file may contain a special section called __vars__ . The key-value pairs from this section will be added to the dictionary of the configuration. If interpolate is set to True, ExtendedInterpolation of variables in the configuration file is used. This means that variables of the form ${key:section} can be used for references within the file. See https://docs.python.org/library/configparser.html#configparser.ExtendedInterpolation for details. Args: file_path : Path to the configuration file. allow_new : Whether to allow the creation of new sections and entries. interpolate : Whether to interpolate variables in the configuration file. case_sensitive : Whether to read keys as case sensitive (or convert to lower case).","title":"Configuration.update_from_file()"},{"location":"api/midgard-config/#configurationupdate_from_options","text":"Full name: midgard.config.config.update_from_options Signature: (self, options:Union[List[str], NoneType]=None, profile:Union[str, NoneType]=None, source:str='command line', allow_new:bool=False) -> None","title":"Configuration.update_from_options()"},{"location":"api/midgard-config/#configurationupdate_on_file","text":"Full name: midgard.config.config.update_on_file Signature: (file_path:Union[str, pathlib.Path], **as_str_args:Any) -> Generator Context manager for updating a configuration on file","title":"Configuration.update_on_file()"},{"location":"api/midgard-config/#configurationupdate_vars","text":"Full name: midgard.config.config.update_vars Signature: (self, new_vars:Dict[str, str]) -> None Update the configuration variables","title":"Configuration.update_vars()"},{"location":"api/midgard-config/#configurationwrite_to_file","text":"Full name: midgard.config.config.write_to_file Signature: (self, file_path:Union[str, pathlib.Path], **as_str_args:Any) -> None Write the configuration to a file In addition to the file path, arguments can be specified and will be passed on to the as_str() function. See as_str() for more information. Todo: Use files.open_path","title":"Configuration.write_to_file()"},{"location":"api/midgard-config/#configurationentry","text":"Full name: midgard.config.config.ConfigurationEntry Signature: (key:str, value:Any, *, source:str='', meta:Union[Dict[str, str], NoneType]=None, vars_dict:Union[Dict[str, str], NoneType]=None, _used_as:Union[Set[str], NoneType]=None) -> None","title":"ConfigurationEntry"},{"location":"api/midgard-config/#configurationentryas_bool","text":"Full name: midgard.config.config.as_bool Signature: (self) -> bool Value of ConfigurationEntry converted to a boolean The conversion is done by looking up the string value of the entry in _BOOLEAN_STATES.","title":"ConfigurationEntry.as_bool()"},{"location":"api/midgard-config/#configurationentryas_date","text":"Full name: midgard.config.config.as_date Signature: (self, format:str='%Y-%m-%d') -> datetime.date Value of ConfigurationEntry converted to a date object Args: format (String): Format string, see strftime for information about the string. Returns: Date : Value of entry.","title":"ConfigurationEntry.as_date()"},{"location":"api/midgard-config/#configurationentryas_datetime","text":"Full name: midgard.config.config.as_datetime Signature: (self, format:str='%Y-%m-%d %H:%M:%S') -> datetime.datetime Value of ConfigurationEntry converted to a datetime object Args: format (String): Format string, see strftime for information about the string. Returns: Datetime : Value of entry.","title":"ConfigurationEntry.as_datetime()"},{"location":"api/midgard-config/#configurationentryas_dict","text":"Full name: midgard.config.config.as_dict Signature: (self, item_split_re:str='[\\\\s,]', key_value_split_re:str='[:]', convert:Callable=<class 'str'>, maxsplit:int=0) -> Dict[str, Any] Value of ConfigurationEntry converted to a dictionary By default the dictionary is created by splitting items at commas and whitespace, and key from value at colons. Args: item_split_re : Regular expression used to split entry into items. key_value_split_re : Regular expression used to split items into keys and values. convert : Function used to convert each value in the dictionary. maxsplit : If nonzero, at most maxsplit splits occur when splitting entry into items. Returns: Value of entry as dict.","title":"ConfigurationEntry.as_dict()"},{"location":"api/midgard-config/#configurationentryas_enum","text":"Full name: midgard.config.config.as_enum Signature: (self, enum:str) -> enum.Enum Value of ConfigurationEntry converted to an enumeration Args: enum (String): Name of Enum. Returns: Enum : Value of entry as Enum.","title":"ConfigurationEntry.as_enum()"},{"location":"api/midgard-config/#configurationentryas_float","text":"Full name: midgard.config.config.as_float Signature: (self) -> float Value of ConfigurationEntry converted to a float","title":"ConfigurationEntry.as_float()"},{"location":"api/midgard-config/#configurationentryas_int","text":"Full name: midgard.config.config.as_int Signature: (self) -> int Value of ConfigurationEntry converted to an integer","title":"ConfigurationEntry.as_int()"},{"location":"api/midgard-config/#configurationentryas_list","text":"Full name: midgard.config.config.as_list Signature: (self, split_re:str='[\\\\s,]', convert:Callable=<class 'str'>, maxsplit:int=0) -> List[Any] Value of ConfigurationEntry converted to a list The entry is converted to a list by using the split_re -regular expression. By default the entry will be split at commas and whitespace. Args: split_re : Regular expression used to split entry into list. convert : Function used to convert each element of the list. maxsplit : If nonzero, at most maxsplit splits occur. Returns: Value of entry as list.","title":"ConfigurationEntry.as_list()"},{"location":"api/midgard-config/#configurationentryas_list_of_lists","text":"Full name: midgard.config.config.as_list_of_lists Signature: (self, split_res:Tuple[str, ...]=('[\\\\s,]', '[^_\\\\w]'), num_elements:Union[int, NoneType]=None, convert:Callable=<class 'str'>) -> List[List[Any]]","title":"ConfigurationEntry.as_list_of_lists()"},{"location":"api/midgard-config/#configurationentryas_path","text":"Full name: midgard.config.config.as_path Signature: (self) -> pathlib.Path Value of ConfigurationEntry interpreted as a path string","title":"ConfigurationEntry.as_path()"},{"location":"api/midgard-config/#configurationentryas_str","text":"Full name: midgard.config.config.as_str Signature: (self) -> str Value of ConfigurationEntry as string","title":"ConfigurationEntry.as_str()"},{"location":"api/midgard-config/#configurationentryas_tuple","text":"Full name: midgard.config.config.as_tuple Signature: (self, split_re:str='[\\\\s,]', convert:Callable=<class 'str'>, maxsplit:int=0) -> Tuple[Any, ...] Value of ConfigurationEntry converted to a tuple The entry is converted to a tuple by using the split_re -regular expression. By default the entry will be split at commas and whitespace. Args: split_re : Regular expression used to split entry into tuple. convert : Function used to convert each element of the tuple. maxsplit : If nonzero, at most maxsplit splits occur. Returns: Value of entry as tuple.","title":"ConfigurationEntry.as_tuple()"},{"location":"api/midgard-config/#configurationentryentry_as_str","text":"Full name: midgard.config.config.entry_as_str Signature: (self, width:Union[int, NoneType]=None, key_width:int=30, metadata:bool=True) -> str The configuration entry represented as a string This is simililar to what is shown by str(entry) (and implemented by __str__ ), but has more flexibility. Args: width : Width of text for wrapping. Default is width of console. key_width : Width of the key column. Default is 30 characters. metadata : Include metadata like type and help text. Returns: String representation of the configuration entry.","title":"ConfigurationEntry.entry_as_str()"},{"location":"api/midgard-config/#configurationentryreplace","text":"Full name: midgard.config.config.replace Signature: (self, default:Union[str, NoneType]=None, **replace_vars:str) -> 'ConfigurationEntry'","title":"ConfigurationEntry.replace()"},{"location":"api/midgard-config/#configurationsection","text":"Full name: midgard.config.config.ConfigurationSection Signature: (name:str) -> None","title":"ConfigurationSection"},{"location":"api/midgard-config/#configurationsectionas_dict","text":"Full name: midgard.config.config.as_dict Signature: (self, getters:Dict[str, str]=None, default_getter:str='str') -> Dict[str, Any] The configuration section represented as a dictionary Args: getters : How to get the value of each entry in the section. default_getter : How to get the value of entries not specified in getters. Returns: Representation of the configuration section as a dictionary.","title":"ConfigurationSection.as_dict()"},{"location":"api/midgard-config/#configurationsectionas_list","text":"Full name: midgard.config.config.as_list Signature: (self) -> List[str] List of keys of entries in configuration section Returns: List of keys of entries in configuration section.","title":"ConfigurationSection.as_list()"},{"location":"api/midgard-config/#configurationsectionas_str","text":"Full name: midgard.config.config.as_str Signature: (self, width:Union[int, NoneType]=None, key_width:int=30, only_used:bool=False, metadata:bool=True) -> str The configuration section represented as a string This is simililar to what is shown by str(section) (and implemented by __str__ ), but has more flexibility. Args: width : Width of text for wrapping. Default is width of console. key_width : Width of the key column. Default is 30 characters. only_used : Only include configuration entries that has been used so far. metadata : Include metadata like type and help text. Returns: String representation of the configuration section.","title":"ConfigurationSection.as_str()"},{"location":"api/midgard-config/#configurationsectionexists","text":"Full name: midgard.config.config.exists Signature: (self, key:str) -> bool Check if key exists in section Args: key : Name of configuration key. Returns: True if key is in section, False otherwise.","title":"ConfigurationSection.exists()"},{"location":"api/midgard-config/#fmt_date-str","text":"FMT_date = '%Y-%m-%d'","title":"FMT_date (str)"},{"location":"api/midgard-config/#fmt_datetime-str","text":"FMT_datetime = '%Y-%m-%d %H:%M:%S'","title":"FMT_datetime (str)"},{"location":"api/midgard-config/#fmt_dt_file-str","text":"FMT_dt_file = '%Y%m%d-%H%M%S'","title":"FMT_dt_file (str)"},{"location":"api/midgard-config/#midgardconfigfiles","text":"Midgard library module for opening files based on a special configuration Example: from midgard.config import files with files.open('eopc04_iau', mode='rt') as fid: for line in fid: print(line.strip()) Description: This module handles opening of files registered in a special configuration, typically a configuration file. The cfg.files.open and cfg.files.open_path methods are both wrappers around the built-in open function, and behave mainly similar. In particular, they accept all the same keyword arguments (like for instance mode). Furthermore, to make sure files are properly closed they should normally be used with a context manager as in the example above.","title":"midgard.config.files"},{"location":"api/midgard-config/#fileconfiguration","text":"Full name: midgard.config.files.FileConfiguration Signature: (name:str) -> None Configuration for handling files","title":"FileConfiguration"},{"location":"api/midgard-config/#fileconfigurationdownload_file","text":"Full name: midgard.config.files.download_file Signature: (self, file_key:str, file_vars:Union[Dict[str, str], NoneType]=None, file_path:Union[pathlib.Path, NoneType]=None, create_dirs:bool=True, **path_args:Any) -> Union[pathlib.Path, NoneType] Download a file from the web and save it to disk Use pycurl (libcurl) to do the actual downloading. Requests might be nicer for this, but turned out to be much slower (and in practice unusable for bigger files) and also not really supporting ftp-downloads. Args: file_key : File key that should be downloaded. file_vars : File variables used to find path from file_key. file_path : Path where file will be saved, default is to read from configuration. create_dirs : Create directories as necessary before downloading file. path_args : Arguments passed on to .path() to find file_path. Returns: Path to downloaded file, None if no file was downloaded.","title":"FileConfiguration.download_file()"},{"location":"api/midgard-config/#fileconfigurationdownload_missing-bool","text":"download_missing = True","title":"FileConfiguration.download_missing (bool)"},{"location":"api/midgard-config/#fileconfigurationencoding","text":"Full name: midgard.config.files.encoding Signature: (self, file_key) Look up the encoding for a given file key Args: file_key (String): Key that is looked up in the configuration. Returns: String : Name of encoding. If encoding is not specified None is returned.","title":"FileConfiguration.encoding()"},{"location":"api/midgard-config/#fileconfigurationglob_paths","text":"Full name: midgard.config.files.glob_paths Signature: (self, file_key:str, file_vars:Union[Dict[str, str], NoneType]=None, is_zipped:Union[bool, NoneType]=None) -> List[pathlib.Path] Find all filepaths matching a filename pattern Using pathlib.Path.glob() here is not trivial because we need to split into a base directory to start searching from and a pattern which may include directories. With glob.glob() this is trivial. The downside is that it only returns strings and not pathlib.Paths.","title":"FileConfiguration.glob_paths()"},{"location":"api/midgard-config/#fileconfigurationglob_variable","text":"Full name: midgard.config.files.glob_variable Signature: (self, file_key, variable, pattern, file_vars=None) Find all possible values of variable","title":"FileConfiguration.glob_variable()"},{"location":"api/midgard-config/#fileconfigurationis_path_zipped","text":"Full name: midgard.config.files.is_path_zipped Signature: (file_path) Indicate whether a path is to a gzipped file or not For now, this simply checks whether the path ends in .gz or not. Args: file_path (Path): Path to a file. Returns: Boolean : True if path is to a gzipped file, False otherwise.","title":"FileConfiguration.is_path_zipped()"},{"location":"api/midgard-config/#fileconfigurationopen","text":"Full name: midgard.config.files.open Signature: (self, file_key:str, file_vars:Dict[str, str]=None, create_dirs:bool=False, is_zipped:Union[bool, NoneType]=None, download_missing:bool=True, use_aliases:bool=True, logger:Union[Callable, NoneType]=None, **open_args:Any) -> Iterator Open a file based on information in a configuration Open a file based on file key which is looked up in the configuration. The method automatically handles reading from gzipped files if the filename is specified with the special {gz}-ending (including the curly braces) in the file list. In that case, the mode should be specified to be 'rt' if the contents of the file should be treated as text. If both a zipped and an unzipped version is available, the zipped version is used. This can be overridden by specifying True or False for the is_zipped-parameter. This function behaves similar to the built-in open-function, and should typically be used with a context manager as follows: Example: with cfg.open('eopc04_iau', mode='rt') as fid: for line in fid: print(line.strip()) Args: file_key : String that is looked up in the configuration file list. file_vars : Dict, extra variables used to replace variables in file name and path. create_dirs : True or False, if True missing directories are created. iz_zipped : None, True, or False. Whether the file open_args : All keyword arguments are passed on to open_path. Returns: File object representing the file.","title":"FileConfiguration.open()"},{"location":"api/midgard-config/#fileconfigurationpath","text":"Full name: midgard.config.files.path Signature: (self, file_key:str, file_vars:Union[Dict[str, str], NoneType]=None, default:Union[str, NoneType]=None, is_zipped:Union[bool, NoneType]=None, download_missing:bool=False, use_aliases:bool=True) -> pathlib.Path Construct a filepath for a given file with variables If is_zipped is None, and the file_path contains <filename>{gz} , the file will be assumed to be a gzip-file if there exists a file named <filename>.gz . When setting use_aliases to True, the aliases as specified in the files configuration file represent alternative filenames. In particular: - if directory / file_name exists it is returned - otherwise the first directory / alias that exists is returned - if none of these exist, directory / file_name is returned Args: file_key (String): Key that is looked up in the configuration. file_vars (Dict): Values used to replace variables in file name and path. default (String): Value to use for variables that are not in file_vars. is_zipped (Bool/None): True, False or None. If True, open with gzip. If None automatically decide. download_missing (Bool): Whether to try to download missing files. use_aliases (Bool): Fall back on aliases if file does not exist. Return: Path: Full path with replaced variables in file name and path.","title":"FileConfiguration.path()"},{"location":"api/midgard-config/#fileconfigurationurl","text":"Full name: midgard.config.files.url Signature: (self, file_key, file_vars=None, default=None, is_zipped=None, use_aliases=False) Construct a URL for a given file with variables If is_zipped is None, and the url contains <filename>{gz} , the url will be assumed to point to a gzip-file if there exists a file named <filename>.gz on the server. Args: file_key : Key that is looked up in the configuration. file_vars : Values used to replace variables in file name and path. default : Value to use for variables that are not in file_vars. is_zipped : True, False or None. If True, open with gzip. If None automatically decide. use_aliases : Fall back on aliases if URL does not exist - may be slow. Return: String: Full URL with replaced variables in file name and url.","title":"FileConfiguration.url()"},{"location":"api/midgard-data/","text":"midgard.data midgard.data._h5utils Simple utilities used by Dataset when dealing with HDF5 files dict2h5attr () Full name: midgard.data._h5utils.dict2h5attr Signature: (dct:Dict[str, str]) -> str Convert a dictionary to a string that can be stored as an HDF5 attribute h5attr2dict () Full name: midgard.data._h5utils.h5attr2dict Signature: (attr:str) -> List[str] Convert an HDF5 attribute to a dictionary of strings h5attr2list () Full name: midgard.data._h5utils.h5attr2list Signature: (attr:str) -> List[str] Convert an HDF5 attribute to a list of strings h5attr2tuple () Full name: midgard.data._h5utils.h5attr2tuple Signature: (attr:str) -> Tuple[str, ...] Convert an HDF5 attribute to a list of strings sequence2h5attr () Full name: midgard.data._h5utils.sequence2h5attr Signature: (lst:Sequence[str]) -> str Convert a list to a string that can be stored as an HDF5 attribute midgard.data._position Array with positions LlhPosition Full name: midgard.data._position.LlhPosition Signature: (val, **pos_args) LlhPosition. aberrated_direction_to () Full name: midgard.data._position.aberrated_direction_to Signature: (self, other) LlhPosition. aberrated_elevation_to () Full name: midgard.data._position.aberrated_elevation_to Signature: (self, other) LlhPosition. aberration_to () Full name: midgard.data._position.aberration_to Signature: (self, other) LlhPosition. azimuth_to () Full name: midgard.data._position.azimuth_to Signature: (self, other) LlhPosition.column_names (tuple) column_names = ('lat', 'lon', 'height') LlhPosition. create () Full name: midgard.data._position.create Signature: (val:numpy.ndarray, system:str, **pos_args:Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system. LlhPosition. direction_to () Full name: midgard.data._position.direction_to Signature: (self, other) LlhPosition. distance_to () Full name: midgard.data._position.distance_to Signature: (self, other) Distance to other positions in current system Args: other : Other position array Returns: Array of distances to other position array. LlhPosition. elevation_to () Full name: midgard.data._position.elevation_to Signature: (self, other) LlhPosition. from_position () Full name: midgard.data._position.from_position Signature: (val:numpy.ndarray, other:'PositionArray') -> 'PositionArray' Create a new position with given values and same attributes as other position Factory method for creating a new position array with the given values. Attributes will be copied from the other position. LlhPosition.system (str) system = 'llh' LlhPosition. to_system () Full name: midgard.data._position.to_system Signature: (self, system:str) -> 'PositionArray' Convert position to a different system Returns a new PositionArray with the same position in the new system. Args: system : Name of new system. Returns: PositionArray representing the same positions in the new system. LlhPosition. unit () Full name: midgard.data._position.unit Signature: (field:str='') -> Tuple[str, ...] Unit of field LlhPosition. vector_to () Full name: midgard.data._position.vector_to Signature: (self, other:'PositionArray') -> numpy.ndarray Vector to other positions in current system Args: other : Other position array. Returns: Array of vectors to other position array. LlhPosition. zenith_distance_to () Full name: midgard.data._position.zenith_distance_to Signature: (self, other) PositionArray Full name: midgard.data._position.PositionArray Signature: (val, **pos_args) Base class for Position arrays This PositionArray should not be instatiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function. PositionArray. aberrated_direction_to () Full name: midgard.data._position.aberrated_direction_to Signature: (self, other) PositionArray. aberrated_elevation_to () Full name: midgard.data._position.aberrated_elevation_to Signature: (self, other) PositionArray. aberration_to () Full name: midgard.data._position.aberration_to Signature: (self, other) PositionArray. azimuth_to () Full name: midgard.data._position.azimuth_to Signature: (self, other) PositionArray.column_names (NoneType) column_names = None PositionArray. create () Full name: midgard.data._position.create Signature: (val:numpy.ndarray, system:str, **pos_args:Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system. PositionArray. direction_to () Full name: midgard.data._position.direction_to Signature: (self, other) PositionArray. distance_to () Full name: midgard.data._position.distance_to Signature: (self, other) Distance to other positions in current system Args: other : Other position array Returns: Array of distances to other position array. PositionArray. elevation_to () Full name: midgard.data._position.elevation_to Signature: (self, other) PositionArray. from_position () Full name: midgard.data._position.from_position Signature: (val:numpy.ndarray, other:'PositionArray') -> 'PositionArray' Create a new position with given values and same attributes as other position Factory method for creating a new position array with the given values. Attributes will be copied from the other position. PositionArray.system (NoneType) system = None PositionArray. to_system () Full name: midgard.data._position.to_system Signature: (self, system:str) -> 'PositionArray' Convert position to a different system Returns a new PositionArray with the same position in the new system. Args: system : Name of new system. Returns: PositionArray representing the same positions in the new system. PositionArray. unit () Full name: midgard.data._position.unit Signature: (field:str='') -> Tuple[str, ...] Unit of field PositionArray. vector_to () Full name: midgard.data._position.vector_to Signature: (self, other:'PositionArray') -> numpy.ndarray Vector to other positions in current system Args: other : Other position array. Returns: Array of vectors to other position array. PositionArray. zenith_distance_to () Full name: midgard.data._position.zenith_distance_to Signature: (self, other) TrsPosition Full name: midgard.data._position.TrsPosition Signature: (val, **pos_args) TrsPosition. aberrated_direction_to () Full name: midgard.data._position.aberrated_direction_to Signature: (self, other) TrsPosition. aberrated_elevation_to () Full name: midgard.data._position.aberrated_elevation_to Signature: (self, other) TrsPosition. aberration_to () Full name: midgard.data._position.aberration_to Signature: (self, other) TrsPosition. azimuth_to () Full name: midgard.data._position.azimuth_to Signature: (self, other) TrsPosition.column_names (tuple) column_names = ('x', 'y', 'z') TrsPosition. create () Full name: midgard.data._position.create Signature: (val:numpy.ndarray, system:str, **pos_args:Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system. TrsPosition. direction_to () Full name: midgard.data._position.direction_to Signature: (self, other) TrsPosition. distance_to () Full name: midgard.data._position.distance_to Signature: (self, other) Distance to other positions in current system Args: other : Other position array Returns: Array of distances to other position array. TrsPosition. elevation_to () Full name: midgard.data._position.elevation_to Signature: (self, other) TrsPosition. from_position () Full name: midgard.data._position.from_position Signature: (val:numpy.ndarray, other:'PositionArray') -> 'PositionArray' Create a new position with given values and same attributes as other position Factory method for creating a new position array with the given values. Attributes will be copied from the other position. TrsPosition.system (str) system = 'trs' TrsPosition. to_system () Full name: midgard.data._position.to_system Signature: (self, system:str) -> 'PositionArray' Convert position to a different system Returns a new PositionArray with the same position in the new system. Args: system : Name of new system. Returns: PositionArray representing the same positions in the new system. TrsPosition. unit () Full name: midgard.data._position.unit Signature: (field:str='') -> Tuple[str, ...] Unit of field TrsPosition. vector_to () Full name: midgard.data._position.vector_to Signature: (self, other:'PositionArray') -> numpy.ndarray Vector to other positions in current system Args: other : Other position array. Returns: Array of vectors to other position array. TrsPosition. zenith_distance_to () Full name: midgard.data._position.zenith_distance_to Signature: (self, other) register_attribute () Full name: midgard.data._position.register_attribute Signature: (name:str) -> None Function used to register new attributes on position arrays The registered attributes will be available as attributes on PositionArray and its subclasses. In addition, each attribute can be given as a parameter when creating a PositionArray. The reason for using this register-function instead of a regular attribute is to allow additional attributes to be added on all position systems. Args: name : Name of attribute register_field () Full name: midgard.data._position.register_field Signature: (units:List[str]) -> Callable Decorator used to register fields and their units register_system () Full name: midgard.data._position.register_system Signature: (convert_to:Dict[str, Callable]=None, convert_from:Dict[str, Callable]=None) -> Callable[[Callable], Callable] Decorator used to register new position systems The system name is read from the .system attribute of the Position class. Args: convert_to : Functions used to convert to other systems. convert_from : Functions used to convert from other systems. Returns: Decorator registering system. midgard.data._position_delta Array with positions EnuPositionDelta Full name: midgard.data._position_delta.EnuPositionDelta Signature: (val, ref_pos, **delta_args) EnuPositionDelta.column_names (tuple) column_names = ('east', 'north', 'up') EnuPositionDelta. create () Full name: midgard.data._position_delta.create Signature: (val:numpy.ndarray, system:str, ref_pos, **delta_args:Any) -> 'PositionDeltaArray' Factory for creating PositionDeltaArrays for different systems See each position delta class for exact optional parameters. Args: val : Array of position deltas. system : Name of position system. ref_pos : Array of reference positions. delta_args : Additional arguments used to create the PositionDeltaArray. Returns: Array with positions in the given system. EnuPositionDelta.system (str) system = 'enu' EnuPositionDelta. to_system () Full name: midgard.data._position_delta.to_system Signature: (self, system:str) -> 'PositionDeltaArray' Convert position to a different system Returns a new PositionDeltaArray with the same position in the new system. Args: system : Name of new system. Returns: PositionDeltaArray representing the same positions in the new system. PositionDeltaArray Full name: midgard.data._position_delta.PositionDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position deltas This PositionDeltaArray should not be instatiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function. PositionDeltaArray.column_names (NoneType) column_names = None PositionDeltaArray. create () Full name: midgard.data._position_delta.create Signature: (val:numpy.ndarray, system:str, ref_pos, **delta_args:Any) -> 'PositionDeltaArray' Factory for creating PositionDeltaArrays for different systems See each position delta class for exact optional parameters. Args: val : Array of position deltas. system : Name of position system. ref_pos : Array of reference positions. delta_args : Additional arguments used to create the PositionDeltaArray. Returns: Array with positions in the given system. PositionDeltaArray.system (NoneType) system = None PositionDeltaArray. to_system () Full name: midgard.data._position_delta.to_system Signature: (self, system:str) -> 'PositionDeltaArray' Convert position to a different system Returns a new PositionDeltaArray with the same position in the new system. Args: system : Name of new system. Returns: PositionDeltaArray representing the same positions in the new system. TrsPositionDelta Full name: midgard.data._position_delta.TrsPositionDelta Signature: (val, ref_pos, **delta_args) TrsPositionDelta.column_names (tuple) column_names = ('x', 'y', 'z') TrsPositionDelta. create () Full name: midgard.data._position_delta.create Signature: (val:numpy.ndarray, system:str, ref_pos, **delta_args:Any) -> 'PositionDeltaArray' Factory for creating PositionDeltaArrays for different systems See each position delta class for exact optional parameters. Args: val : Array of position deltas. system : Name of position system. ref_pos : Array of reference positions. delta_args : Additional arguments used to create the PositionDeltaArray. Returns: Array with positions in the given system. TrsPositionDelta.system (str) system = 'trs' TrsPositionDelta. to_system () Full name: midgard.data._position_delta.to_system Signature: (self, system:str) -> 'PositionDeltaArray' Convert position to a different system Returns a new PositionDeltaArray with the same position in the new system. Args: system : Name of new system. Returns: PositionDeltaArray representing the same positions in the new system. delta_enu2trs () Full name: midgard.data._position_delta.delta_enu2trs Signature: (enu:'EnuPositionDelta') -> numpy.ndarray Convert position deltas from ENU to TRS delta_trs2enu () Full name: midgard.data._position_delta.delta_trs2enu Signature: (trs:'TrsPositionDelta') -> numpy.ndarray Convert position deltas from TRS to ENU register_system () Full name: midgard.data._position_delta.register_system Signature: (convert_to:Dict[str, Callable]=None, convert_from:Dict[str, Callable]=None) -> Callable[[Callable], Callable] Decorator used to register new position systems The system name is read from the .system attribute of the Position class. Args: convert_to : Functions used to convert to other systems. convert_from : Functions used to convert from other systems. Returns: Decorator registering system. midgard.data._time Array with time epochs TimeArray Full name: midgard.data._time.TimeArray Signature: (val, val2=None, format='', _jd1=None, _jd2=None) TimeArray. create () Full name: midgard.data._time.create Signature: (val:numpy.ndarray, scale:str, format:str, val2:Union[numpy.ndarray, NoneType]=None) -> 'TimeArray' Factory for creating TimeArrays for different scales See each time class for exact optional parameters. Args: val : Array of time values. scale : Name of time scale. pos_args : Additional arguments used to create the TimeArray. Returns: Array with times in the given scale. TimeArray. from_jds () Full name: midgard.data._time.from_jds Signature: (jd1:numpy.ndarray, jd2:numpy.ndarray, format:str) -> 'TimeArray' Create a new time array with given Julian dates and format, keep scale TimeArray. now () Full name: midgard.data._time.now Signature: (scale='utc', format='datetime') -> 'TimeArray' Create a new time representing now TimeArray.scale (NoneType) scale = None TimeArray. to_scale () Full name: midgard.data._time.to_scale Signature: (self, scale:str) -> 'TimeArray' Convert time to a different scale Returns a new TimeArray with the same time in the new scale. Args: scale : Name of new scale. Returns: TimeArray representing the same times in the new scale. TimeArray. unit () Full name: midgard.data._time.unit Signature: (self, field:str='') -> Tuple[str, ...] Unit of field register_scale () Full name: midgard.data._time.register_scale Signature: (convert_to:Dict[str, Callable]=None, convert_from:Dict[str, Callable]=None) -> Callable[[Callable], Callable] Decorator used to register new time scales The scale name is read from the .scale attribute of the Time class. Args: convert_to : Functions used to convert to other scales. convert_from : Functions used to convert from other scales. Returns: Decorator registering scale. midgard.data._time_formats Array with time epochs TimeDateTime Full name: midgard.data._time_formats.TimeDateTime Signature: (val, val2=None) TimeDateTime.day2seconds (float) day2seconds = 86400.0 TimeDateTime.format (str) format = 'datetime' TimeDateTime. from_jds () Full name: midgard.data._time_formats.from_jds Signature: (jd1, jd2) TimeDateTime. to_jds () Full name: midgard.data._time_formats.to_jds Signature: (val, val2=None) TimeDateTime.unit (NoneType) unit = None TimeDateTime.week2days (float) week2days = 6.999999999999998 TimeFormat Full name: midgard.data._time_formats.TimeFormat Signature: (val, val2=None) TimeFormat.day2seconds (float) day2seconds = 86400.0 TimeFormat.format (NoneType) format = None TimeFormat. from_jds () Full name: midgard.data._time_formats.from_jds Signature: (jd1, jd2) Convert Julian days to the right format TimeFormat. to_jds () Full name: midgard.data._time_formats.to_jds Signature: (val, val2) Convert val and val2 to Julian days and set the .jd1 and .jd2 attributes TimeFormat.unit (NoneType) unit = None TimeFormat.week2days (float) week2days = 6.999999999999998 TimeGPSWeekSec Full name: midgard.data._time_formats.TimeGPSWeekSec Signature: (val, val2=None) GPS weeks and seconds. TimeGPSWeekSec.day2seconds (float) day2seconds = 86400.0 TimeGPSWeekSec.format (str) format = 'gps_ws' TimeGPSWeekSec. from_jds () Full name: midgard.data._time_formats.from_jds Signature: (jd1, jd2) TimeGPSWeekSec. to_jds () Full name: midgard.data._time_formats.to_jds Signature: (wwww, sec) TimeGPSWeekSec.unit (tuple) unit = ('week', 'second') TimeGPSWeekSec.week2days (float) week2days = 6.999999999999998 TimeJD Full name: midgard.data._time_formats.TimeJD Signature: (val, val2=None) TimeJD.day2seconds (float) day2seconds = 86400.0 TimeJD.format (str) format = 'jd' TimeJD. from_jds () Full name: midgard.data._time_formats.from_jds Signature: (jd1, jd2) TimeJD. to_jds () Full name: midgard.data._time_formats.to_jds Signature: (val, val2) TimeJD.unit (tuple) unit = ('day',) TimeJD.week2days (float) week2days = 6.999999999999998 TimeMJD Full name: midgard.data._time_formats.TimeMJD Signature: (val, val2=None) Modified Julian Date time format. This represents the number of days since midnight on November 17, 1858. For example, 51544.0 in MJD is midnight on January 1, 2000. TimeMJD.day2seconds (float) day2seconds = 86400.0 TimeMJD.format (str) format = 'mjd' TimeMJD. from_jds () Full name: midgard.data._time_formats.from_jds Signature: (jd1, jd2) TimeMJD. to_jds () Full name: midgard.data._time_formats.to_jds Signature: (val, val2) TimeMJD.unit (tuple) unit = ('day',) TimeMJD.week2days (float) week2days = 6.999999999999998 TimeYear Full name: midgard.data._time_formats.TimeYear Signature: (val, val2=None) Year. TODO: conversion is not correct!!! TimeYear.day2seconds (float) day2seconds = 86400.0 TimeYear.format (str) format = 'decimalyear' TimeYear. from_jds () Full name: midgard.data._time_formats.from_jds Signature: (jds1, jds2) TimeYear. to_jds () Full name: midgard.data._time_formats.to_jds Signature: (val, val2=None) TimeYear.unit (tuple) unit = ('common_year',) TimeYear.week2days (float) week2days = 6.999999999999998 register_format () Full name: midgard.data._time_formats.register_format Signature: (cls:Callable) -> Callable Decorator used to register new time formats The format name is read from the .format attribute of the TimeFormat class. midgard.data._time_scales Time scales and conversions between them GpsTime Full name: midgard.data._time_scales.GpsTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None) GpsTime.scale (str) scale = 'gps' TaiTime Full name: midgard.data._time_scales.TaiTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None) TaiTime.scale (str) scale = 'tai' TtTime Full name: midgard.data._time_scales.TtTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None) TtTime.scale (str) scale = 'tt' UtcTime Full name: midgard.data._time_scales.UtcTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None) UtcTime.scale (str) scale = 'utc' midgard.data.dataset A dataset for handling time series data Description: Dataset Full name: midgard.data.dataset.Dataset Signature: (num_obs:int=0) -> None A dataset representing fields of data arrays Dataset. add_collection () Full name: midgard.data.dataset.add_collection Signature: (self, name, val, unit=None, write_level=None, suffix=None, **field_args) Add a collection field to the dataset Dataset. add_float () Full name: midgard.data.dataset.add_float Signature: (self, name, val, unit=None, write_level=None, suffix=None, **field_args) Add a float field to the dataset Dataset. add_position () Full name: midgard.data.dataset.add_position Signature: (self, name, val, unit=None, write_level=None, suffix=None, **field_args) Add a position field to the dataset Dataset. add_position_delta () Full name: midgard.data.dataset.add_position_delta Signature: (self, name, val, unit=None, write_level=None, suffix=None, **field_args) Add a position_delta field to the dataset Dataset. add_sigma () Full name: midgard.data.dataset.add_sigma Signature: (self, name, val, unit=None, write_level=None, suffix=None, **field_args) Add a sigma field to the dataset Dataset. add_time () Full name: midgard.data.dataset.add_time Signature: (self, name, val, unit=None, write_level=None, suffix=None, **field_args) Add a time field to the dataset Dataset. apply () Full name: midgard.data.dataset.apply Signature: (self, func:Callable, field:str, **filters:Any) -> Any Apply a function to a field Dataset. as_dataframe () Full name: midgard.data.dataset.as_dataframe Signature: (self, fields=None, index=None) -> pandas.core.frame.DataFrame Return a representation of the dataset as a Pandas DataFrame Dataset. as_dict () Full name: midgard.data.dataset.as_dict Signature: (self, fields=None) -> Dict[str, Any] Return a representation of the dataset as a dictionary Dataset. copy_from () Full name: midgard.data.dataset.copy_from Signature: (self, other:'Dataset') -> None Copy observations from another dataset Args: other_dset (Dataset): The other dataset. meta_key (str): Dictionary key for introduction of an additional level in dictionary. Dataset. count () Full name: midgard.data.dataset.count Signature: (self, field:str, **filters:Any) -> int Count the number of unique values in a field Dataset. extend () Full name: midgard.data.dataset.extend Signature: (self, other_dataset:'Dataset') -> None Add observations from another dataset to the end of this dataset Dataset. filter () Full name: midgard.data.dataset.filter Signature: (self, idx=None, **filters) -> <built-in function array> Filter observations TODO: default_field_suffix Dataset. for_each () Full name: midgard.data.dataset.for_each Signature: (self, key) Do something for each suffix Dataset. mean () Full name: midgard.data.dataset.mean Signature: (self, field:str, **filters:Any) -> float Calculate mean of a field Dataset. num () Full name: midgard.data.dataset.num Signature: (self, **filters:Any) -> int Number of observations satisfying the filters Dataset. plot_values () Full name: midgard.data.dataset.plot_values Signature: (self, field:str) -> <built-in function array> Return values of a field in a form that can be plotted Dataset. read () Full name: midgard.data.dataset.read Signature: (file_path:Union[str, pathlib.Path]) -> 'Dataset' Read a dataset from file Dataset. rms () Full name: midgard.data.dataset.rms Signature: (self, field:str, **filters:Any) -> float Calculate Root Mean Square of a field Dataset. subset () Full name: midgard.data.dataset.subset Signature: (self, idx:<built-in function array>) -> None Remove observations from all fields based on index Dataset. unique () Full name: midgard.data.dataset.unique Signature: (self, field, **filters) -> <built-in function array> List unique values of a given field TODO: default_field_suffix Dataset. unit () Full name: midgard.data.dataset.unit Signature: (self, field) Unit for values in a given field Dataset.version (str) version = 'Dataset v3.0, Midgard v0.2.0' Dataset. write () Full name: midgard.data.dataset.write Signature: (self, file_path:Union[str, pathlib.Path], write_level:Union[midgard.collections.enums.WriteLevel, NoneType]=None) -> None Write a dataset to file Meta Full name: midgard.data.dataset.Meta Signature: (*args, **kwargs) Meta. add () Full name: midgard.data.dataset.add Signature: (self, section, name, value) Add information to the metaset Meta. add_event () Full name: midgard.data.dataset.add_event Signature: (self, timestamp, event_type, description) Add event to the metaset Meta. copy_from () Full name: midgard.data.dataset.copy_from Signature: (self, other) Meta. get_events () Full name: midgard.data.dataset.get_events Signature: (self, *event_types) Get events from the metaset Meta. read () Full name: midgard.data.dataset.read Signature: (self, h5_group) Meta. write () Full name: midgard.data.dataset.write Signature: (self, h5_group) field_type (str) field_type = 'time' midgard.data.fieldtypes Field types that can be used by Dataset function () Full name: midgard.data.fieldtypes.function Signature: (plugin_name:str) -> Callable Function creating new field names () Full name: midgard.data.fieldtypes.names Signature: () -> List[str] Names of fieldtype plugins midgard.data.fieldtypes._fieldtype Abstract class used to define different types of tables for a Dataset FieldType Full name: midgard.data.fieldtypes._fieldtype.FieldType Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args) Abstract class representing a type of field in the Dataset FieldType. as_dataframe () Full name: midgard.data.fieldtypes._fieldtype.as_dataframe Signature: (self, fields=None, index=None) -> pandas.core.frame.DataFrame Return a representation of the field as a Pandas DataFrame FieldType. as_dict () Full name: midgard.data.fieldtypes._fieldtype.as_dict Signature: (self, fields=None) -> Dict[str, Any] Return a representation of the field as a dictionary FieldType. copy () Full name: midgard.data.fieldtypes._fieldtype.copy Signature: (self) -> 'FieldType' Make a copy of field FieldType. copy_from () Full name: midgard.data.fieldtypes._fieldtype.copy_from Signature: (self, other_field) -> None Copy data from another field FieldType. extend () Full name: midgard.data.fieldtypes._fieldtype.extend Signature: (self, other_field) -> None Add observations from another field FieldType. read () Full name: midgard.data.fieldtypes._fieldtype.read Signature: (h5_group, master) -> 'FieldType' Read a field from a HDF5 data source FieldType. subset () Full name: midgard.data.fieldtypes._fieldtype.subset Signature: (self, idx:<built-in function array>) -> None Remove observations from a field based on index FieldType. unit () Full name: midgard.data.fieldtypes._fieldtype.unit Signature: (self, subfield) Unit(s) of field FieldType. write () Full name: midgard.data.fieldtypes._fieldtype.write Signature: (self, h5_group, write_level:midgard.collections.enums.WriteLevel) -> None Write data to a HDF5 data source midgard.data.fieldtypes.collection A Dataset collection field consisting of other fields Collection Full name: midgard.data.fieldtypes.collection.Collection Signature: () Collection. unit () Full name: midgard.data.fieldtypes.collection.unit Signature: (self, field) Unit for values in a given field CollectionField Full name: midgard.data.fieldtypes.collection.CollectionField Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args) CollectionField. read () Full name: midgard.data.fieldtypes.collection.read Signature: (h5_group, master) CollectionField. write () Full name: midgard.data.fieldtypes.collection.write Signature: (self, h5_group, write_level) Write data to a HDF5 data source midgard.data.fieldtypes.float A Dataset float field FloatField Full name: midgard.data.fieldtypes.float.FloatField Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args) midgard.data.fieldtypes.position A Dataset position field PositionField Full name: midgard.data.fieldtypes.position.PositionField Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args) midgard.data.fieldtypes.position_delta A Dataset position delta field PositionDeltaField Full name: midgard.data.fieldtypes.position_delta.PositionDeltaField Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args) midgard.data.fieldtypes.sigma A Dataset sigma field SigmaField Full name: midgard.data.fieldtypes.sigma.SigmaField Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args) midgard.data.fieldtypes.time A Dataset time field TimeField Full name: midgard.data.fieldtypes.time.TimeField Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args) midgard.data.position Array with positions Position () Full name: midgard.data.position.Position Signature: (val:numpy.ndarray, system:str, **pos_args:Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system. PositionDelta () Full name: midgard.data.position.PositionDelta Signature: (val:numpy.ndarray, system:str, ref_pos:midgard.data._position.PositionArray, **delta_args:Any) -> midgard.data._position_delta.PositionDeltaArray Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system. midgard.data.sigma Array with sigma values See https://docs.scipy.org/doc/numpy/user/basics.subclassing.html for information about subclassing Numpy arrays. SigmaArray is a regular Numpy array with an added field, sigma. SigmaArray Full name: midgard.data.sigma.SigmaArray Signature: (values, sigma=None) midgard.data.time Array with time epochs Time () Full name: midgard.data.time.Time Signature: (val:numpy.ndarray, scale:str, format:str, val2:Union[numpy.ndarray, NoneType]=None) -> 'TimeArray' Factory for creating TimeArrays for different systems See each time class for exact optional parameters. Args: val : Array of time values. val2 : Optional second array for extra precision. scale : Name of time scale. format : Format of values given in val and val2. Returns: Array with epochs in the given time scale and format","title":"midgard.data"},{"location":"api/midgard-data/#midgarddata","text":"","title":"midgard.data"},{"location":"api/midgard-data/#midgarddata_h5utils","text":"Simple utilities used by Dataset when dealing with HDF5 files","title":"midgard.data._h5utils"},{"location":"api/midgard-data/#dict2h5attr","text":"Full name: midgard.data._h5utils.dict2h5attr Signature: (dct:Dict[str, str]) -> str Convert a dictionary to a string that can be stored as an HDF5 attribute","title":"dict2h5attr()"},{"location":"api/midgard-data/#h5attr2dict","text":"Full name: midgard.data._h5utils.h5attr2dict Signature: (attr:str) -> List[str] Convert an HDF5 attribute to a dictionary of strings","title":"h5attr2dict()"},{"location":"api/midgard-data/#h5attr2list","text":"Full name: midgard.data._h5utils.h5attr2list Signature: (attr:str) -> List[str] Convert an HDF5 attribute to a list of strings","title":"h5attr2list()"},{"location":"api/midgard-data/#h5attr2tuple","text":"Full name: midgard.data._h5utils.h5attr2tuple Signature: (attr:str) -> Tuple[str, ...] Convert an HDF5 attribute to a list of strings","title":"h5attr2tuple()"},{"location":"api/midgard-data/#sequence2h5attr","text":"Full name: midgard.data._h5utils.sequence2h5attr Signature: (lst:Sequence[str]) -> str Convert a list to a string that can be stored as an HDF5 attribute","title":"sequence2h5attr()"},{"location":"api/midgard-data/#midgarddata_position","text":"Array with positions","title":"midgard.data._position"},{"location":"api/midgard-data/#llhposition","text":"Full name: midgard.data._position.LlhPosition Signature: (val, **pos_args)","title":"LlhPosition"},{"location":"api/midgard-data/#llhpositionaberrated_direction_to","text":"Full name: midgard.data._position.aberrated_direction_to Signature: (self, other)","title":"LlhPosition.aberrated_direction_to()"},{"location":"api/midgard-data/#llhpositionaberrated_elevation_to","text":"Full name: midgard.data._position.aberrated_elevation_to Signature: (self, other)","title":"LlhPosition.aberrated_elevation_to()"},{"location":"api/midgard-data/#llhpositionaberration_to","text":"Full name: midgard.data._position.aberration_to Signature: (self, other)","title":"LlhPosition.aberration_to()"},{"location":"api/midgard-data/#llhpositionazimuth_to","text":"Full name: midgard.data._position.azimuth_to Signature: (self, other)","title":"LlhPosition.azimuth_to()"},{"location":"api/midgard-data/#llhpositioncolumn_names-tuple","text":"column_names = ('lat', 'lon', 'height')","title":"LlhPosition.column_names (tuple)"},{"location":"api/midgard-data/#llhpositioncreate","text":"Full name: midgard.data._position.create Signature: (val:numpy.ndarray, system:str, **pos_args:Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system.","title":"LlhPosition.create()"},{"location":"api/midgard-data/#llhpositiondirection_to","text":"Full name: midgard.data._position.direction_to Signature: (self, other)","title":"LlhPosition.direction_to()"},{"location":"api/midgard-data/#llhpositiondistance_to","text":"Full name: midgard.data._position.distance_to Signature: (self, other) Distance to other positions in current system Args: other : Other position array Returns: Array of distances to other position array.","title":"LlhPosition.distance_to()"},{"location":"api/midgard-data/#llhpositionelevation_to","text":"Full name: midgard.data._position.elevation_to Signature: (self, other)","title":"LlhPosition.elevation_to()"},{"location":"api/midgard-data/#llhpositionfrom_position","text":"Full name: midgard.data._position.from_position Signature: (val:numpy.ndarray, other:'PositionArray') -> 'PositionArray' Create a new position with given values and same attributes as other position Factory method for creating a new position array with the given values. Attributes will be copied from the other position.","title":"LlhPosition.from_position()"},{"location":"api/midgard-data/#llhpositionsystem-str","text":"system = 'llh'","title":"LlhPosition.system (str)"},{"location":"api/midgard-data/#llhpositionto_system","text":"Full name: midgard.data._position.to_system Signature: (self, system:str) -> 'PositionArray' Convert position to a different system Returns a new PositionArray with the same position in the new system. Args: system : Name of new system. Returns: PositionArray representing the same positions in the new system.","title":"LlhPosition.to_system()"},{"location":"api/midgard-data/#llhpositionunit","text":"Full name: midgard.data._position.unit Signature: (field:str='') -> Tuple[str, ...] Unit of field","title":"LlhPosition.unit()"},{"location":"api/midgard-data/#llhpositionvector_to","text":"Full name: midgard.data._position.vector_to Signature: (self, other:'PositionArray') -> numpy.ndarray Vector to other positions in current system Args: other : Other position array. Returns: Array of vectors to other position array.","title":"LlhPosition.vector_to()"},{"location":"api/midgard-data/#llhpositionzenith_distance_to","text":"Full name: midgard.data._position.zenith_distance_to Signature: (self, other)","title":"LlhPosition.zenith_distance_to()"},{"location":"api/midgard-data/#positionarray","text":"Full name: midgard.data._position.PositionArray Signature: (val, **pos_args) Base class for Position arrays This PositionArray should not be instatiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function.","title":"PositionArray"},{"location":"api/midgard-data/#positionarrayaberrated_direction_to","text":"Full name: midgard.data._position.aberrated_direction_to Signature: (self, other)","title":"PositionArray.aberrated_direction_to()"},{"location":"api/midgard-data/#positionarrayaberrated_elevation_to","text":"Full name: midgard.data._position.aberrated_elevation_to Signature: (self, other)","title":"PositionArray.aberrated_elevation_to()"},{"location":"api/midgard-data/#positionarrayaberration_to","text":"Full name: midgard.data._position.aberration_to Signature: (self, other)","title":"PositionArray.aberration_to()"},{"location":"api/midgard-data/#positionarrayazimuth_to","text":"Full name: midgard.data._position.azimuth_to Signature: (self, other)","title":"PositionArray.azimuth_to()"},{"location":"api/midgard-data/#positionarraycolumn_names-nonetype","text":"column_names = None","title":"PositionArray.column_names (NoneType)"},{"location":"api/midgard-data/#positionarraycreate","text":"Full name: midgard.data._position.create Signature: (val:numpy.ndarray, system:str, **pos_args:Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system.","title":"PositionArray.create()"},{"location":"api/midgard-data/#positionarraydirection_to","text":"Full name: midgard.data._position.direction_to Signature: (self, other)","title":"PositionArray.direction_to()"},{"location":"api/midgard-data/#positionarraydistance_to","text":"Full name: midgard.data._position.distance_to Signature: (self, other) Distance to other positions in current system Args: other : Other position array Returns: Array of distances to other position array.","title":"PositionArray.distance_to()"},{"location":"api/midgard-data/#positionarrayelevation_to","text":"Full name: midgard.data._position.elevation_to Signature: (self, other)","title":"PositionArray.elevation_to()"},{"location":"api/midgard-data/#positionarrayfrom_position","text":"Full name: midgard.data._position.from_position Signature: (val:numpy.ndarray, other:'PositionArray') -> 'PositionArray' Create a new position with given values and same attributes as other position Factory method for creating a new position array with the given values. Attributes will be copied from the other position.","title":"PositionArray.from_position()"},{"location":"api/midgard-data/#positionarraysystem-nonetype","text":"system = None","title":"PositionArray.system (NoneType)"},{"location":"api/midgard-data/#positionarrayto_system","text":"Full name: midgard.data._position.to_system Signature: (self, system:str) -> 'PositionArray' Convert position to a different system Returns a new PositionArray with the same position in the new system. Args: system : Name of new system. Returns: PositionArray representing the same positions in the new system.","title":"PositionArray.to_system()"},{"location":"api/midgard-data/#positionarrayunit","text":"Full name: midgard.data._position.unit Signature: (field:str='') -> Tuple[str, ...] Unit of field","title":"PositionArray.unit()"},{"location":"api/midgard-data/#positionarrayvector_to","text":"Full name: midgard.data._position.vector_to Signature: (self, other:'PositionArray') -> numpy.ndarray Vector to other positions in current system Args: other : Other position array. Returns: Array of vectors to other position array.","title":"PositionArray.vector_to()"},{"location":"api/midgard-data/#positionarrayzenith_distance_to","text":"Full name: midgard.data._position.zenith_distance_to Signature: (self, other)","title":"PositionArray.zenith_distance_to()"},{"location":"api/midgard-data/#trsposition","text":"Full name: midgard.data._position.TrsPosition Signature: (val, **pos_args)","title":"TrsPosition"},{"location":"api/midgard-data/#trspositionaberrated_direction_to","text":"Full name: midgard.data._position.aberrated_direction_to Signature: (self, other)","title":"TrsPosition.aberrated_direction_to()"},{"location":"api/midgard-data/#trspositionaberrated_elevation_to","text":"Full name: midgard.data._position.aberrated_elevation_to Signature: (self, other)","title":"TrsPosition.aberrated_elevation_to()"},{"location":"api/midgard-data/#trspositionaberration_to","text":"Full name: midgard.data._position.aberration_to Signature: (self, other)","title":"TrsPosition.aberration_to()"},{"location":"api/midgard-data/#trspositionazimuth_to","text":"Full name: midgard.data._position.azimuth_to Signature: (self, other)","title":"TrsPosition.azimuth_to()"},{"location":"api/midgard-data/#trspositioncolumn_names-tuple","text":"column_names = ('x', 'y', 'z')","title":"TrsPosition.column_names (tuple)"},{"location":"api/midgard-data/#trspositioncreate","text":"Full name: midgard.data._position.create Signature: (val:numpy.ndarray, system:str, **pos_args:Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system.","title":"TrsPosition.create()"},{"location":"api/midgard-data/#trspositiondirection_to","text":"Full name: midgard.data._position.direction_to Signature: (self, other)","title":"TrsPosition.direction_to()"},{"location":"api/midgard-data/#trspositiondistance_to","text":"Full name: midgard.data._position.distance_to Signature: (self, other) Distance to other positions in current system Args: other : Other position array Returns: Array of distances to other position array.","title":"TrsPosition.distance_to()"},{"location":"api/midgard-data/#trspositionelevation_to","text":"Full name: midgard.data._position.elevation_to Signature: (self, other)","title":"TrsPosition.elevation_to()"},{"location":"api/midgard-data/#trspositionfrom_position","text":"Full name: midgard.data._position.from_position Signature: (val:numpy.ndarray, other:'PositionArray') -> 'PositionArray' Create a new position with given values and same attributes as other position Factory method for creating a new position array with the given values. Attributes will be copied from the other position.","title":"TrsPosition.from_position()"},{"location":"api/midgard-data/#trspositionsystem-str","text":"system = 'trs'","title":"TrsPosition.system (str)"},{"location":"api/midgard-data/#trspositionto_system","text":"Full name: midgard.data._position.to_system Signature: (self, system:str) -> 'PositionArray' Convert position to a different system Returns a new PositionArray with the same position in the new system. Args: system : Name of new system. Returns: PositionArray representing the same positions in the new system.","title":"TrsPosition.to_system()"},{"location":"api/midgard-data/#trspositionunit","text":"Full name: midgard.data._position.unit Signature: (field:str='') -> Tuple[str, ...] Unit of field","title":"TrsPosition.unit()"},{"location":"api/midgard-data/#trspositionvector_to","text":"Full name: midgard.data._position.vector_to Signature: (self, other:'PositionArray') -> numpy.ndarray Vector to other positions in current system Args: other : Other position array. Returns: Array of vectors to other position array.","title":"TrsPosition.vector_to()"},{"location":"api/midgard-data/#trspositionzenith_distance_to","text":"Full name: midgard.data._position.zenith_distance_to Signature: (self, other)","title":"TrsPosition.zenith_distance_to()"},{"location":"api/midgard-data/#register_attribute","text":"Full name: midgard.data._position.register_attribute Signature: (name:str) -> None Function used to register new attributes on position arrays The registered attributes will be available as attributes on PositionArray and its subclasses. In addition, each attribute can be given as a parameter when creating a PositionArray. The reason for using this register-function instead of a regular attribute is to allow additional attributes to be added on all position systems. Args: name : Name of attribute","title":"register_attribute()"},{"location":"api/midgard-data/#register_field","text":"Full name: midgard.data._position.register_field Signature: (units:List[str]) -> Callable Decorator used to register fields and their units","title":"register_field()"},{"location":"api/midgard-data/#register_system","text":"Full name: midgard.data._position.register_system Signature: (convert_to:Dict[str, Callable]=None, convert_from:Dict[str, Callable]=None) -> Callable[[Callable], Callable] Decorator used to register new position systems The system name is read from the .system attribute of the Position class. Args: convert_to : Functions used to convert to other systems. convert_from : Functions used to convert from other systems. Returns: Decorator registering system.","title":"register_system()"},{"location":"api/midgard-data/#midgarddata_position_delta","text":"Array with positions","title":"midgard.data._position_delta"},{"location":"api/midgard-data/#enupositiondelta","text":"Full name: midgard.data._position_delta.EnuPositionDelta Signature: (val, ref_pos, **delta_args)","title":"EnuPositionDelta"},{"location":"api/midgard-data/#enupositiondeltacolumn_names-tuple","text":"column_names = ('east', 'north', 'up')","title":"EnuPositionDelta.column_names (tuple)"},{"location":"api/midgard-data/#enupositiondeltacreate","text":"Full name: midgard.data._position_delta.create Signature: (val:numpy.ndarray, system:str, ref_pos, **delta_args:Any) -> 'PositionDeltaArray' Factory for creating PositionDeltaArrays for different systems See each position delta class for exact optional parameters. Args: val : Array of position deltas. system : Name of position system. ref_pos : Array of reference positions. delta_args : Additional arguments used to create the PositionDeltaArray. Returns: Array with positions in the given system.","title":"EnuPositionDelta.create()"},{"location":"api/midgard-data/#enupositiondeltasystem-str","text":"system = 'enu'","title":"EnuPositionDelta.system (str)"},{"location":"api/midgard-data/#enupositiondeltato_system","text":"Full name: midgard.data._position_delta.to_system Signature: (self, system:str) -> 'PositionDeltaArray' Convert position to a different system Returns a new PositionDeltaArray with the same position in the new system. Args: system : Name of new system. Returns: PositionDeltaArray representing the same positions in the new system.","title":"EnuPositionDelta.to_system()"},{"location":"api/midgard-data/#positiondeltaarray","text":"Full name: midgard.data._position_delta.PositionDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position deltas This PositionDeltaArray should not be instatiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function.","title":"PositionDeltaArray"},{"location":"api/midgard-data/#positiondeltaarraycolumn_names-nonetype","text":"column_names = None","title":"PositionDeltaArray.column_names (NoneType)"},{"location":"api/midgard-data/#positiondeltaarraycreate","text":"Full name: midgard.data._position_delta.create Signature: (val:numpy.ndarray, system:str, ref_pos, **delta_args:Any) -> 'PositionDeltaArray' Factory for creating PositionDeltaArrays for different systems See each position delta class for exact optional parameters. Args: val : Array of position deltas. system : Name of position system. ref_pos : Array of reference positions. delta_args : Additional arguments used to create the PositionDeltaArray. Returns: Array with positions in the given system.","title":"PositionDeltaArray.create()"},{"location":"api/midgard-data/#positiondeltaarraysystem-nonetype","text":"system = None","title":"PositionDeltaArray.system (NoneType)"},{"location":"api/midgard-data/#positiondeltaarrayto_system","text":"Full name: midgard.data._position_delta.to_system Signature: (self, system:str) -> 'PositionDeltaArray' Convert position to a different system Returns a new PositionDeltaArray with the same position in the new system. Args: system : Name of new system. Returns: PositionDeltaArray representing the same positions in the new system.","title":"PositionDeltaArray.to_system()"},{"location":"api/midgard-data/#trspositiondelta","text":"Full name: midgard.data._position_delta.TrsPositionDelta Signature: (val, ref_pos, **delta_args)","title":"TrsPositionDelta"},{"location":"api/midgard-data/#trspositiondeltacolumn_names-tuple","text":"column_names = ('x', 'y', 'z')","title":"TrsPositionDelta.column_names (tuple)"},{"location":"api/midgard-data/#trspositiondeltacreate","text":"Full name: midgard.data._position_delta.create Signature: (val:numpy.ndarray, system:str, ref_pos, **delta_args:Any) -> 'PositionDeltaArray' Factory for creating PositionDeltaArrays for different systems See each position delta class for exact optional parameters. Args: val : Array of position deltas. system : Name of position system. ref_pos : Array of reference positions. delta_args : Additional arguments used to create the PositionDeltaArray. Returns: Array with positions in the given system.","title":"TrsPositionDelta.create()"},{"location":"api/midgard-data/#trspositiondeltasystem-str","text":"system = 'trs'","title":"TrsPositionDelta.system (str)"},{"location":"api/midgard-data/#trspositiondeltato_system","text":"Full name: midgard.data._position_delta.to_system Signature: (self, system:str) -> 'PositionDeltaArray' Convert position to a different system Returns a new PositionDeltaArray with the same position in the new system. Args: system : Name of new system. Returns: PositionDeltaArray representing the same positions in the new system.","title":"TrsPositionDelta.to_system()"},{"location":"api/midgard-data/#delta_enu2trs","text":"Full name: midgard.data._position_delta.delta_enu2trs Signature: (enu:'EnuPositionDelta') -> numpy.ndarray Convert position deltas from ENU to TRS","title":"delta_enu2trs()"},{"location":"api/midgard-data/#delta_trs2enu","text":"Full name: midgard.data._position_delta.delta_trs2enu Signature: (trs:'TrsPositionDelta') -> numpy.ndarray Convert position deltas from TRS to ENU","title":"delta_trs2enu()"},{"location":"api/midgard-data/#register_system_1","text":"Full name: midgard.data._position_delta.register_system Signature: (convert_to:Dict[str, Callable]=None, convert_from:Dict[str, Callable]=None) -> Callable[[Callable], Callable] Decorator used to register new position systems The system name is read from the .system attribute of the Position class. Args: convert_to : Functions used to convert to other systems. convert_from : Functions used to convert from other systems. Returns: Decorator registering system.","title":"register_system()"},{"location":"api/midgard-data/#midgarddata_time","text":"Array with time epochs","title":"midgard.data._time"},{"location":"api/midgard-data/#timearray","text":"Full name: midgard.data._time.TimeArray Signature: (val, val2=None, format='', _jd1=None, _jd2=None)","title":"TimeArray"},{"location":"api/midgard-data/#timearraycreate","text":"Full name: midgard.data._time.create Signature: (val:numpy.ndarray, scale:str, format:str, val2:Union[numpy.ndarray, NoneType]=None) -> 'TimeArray' Factory for creating TimeArrays for different scales See each time class for exact optional parameters. Args: val : Array of time values. scale : Name of time scale. pos_args : Additional arguments used to create the TimeArray. Returns: Array with times in the given scale.","title":"TimeArray.create()"},{"location":"api/midgard-data/#timearrayfrom_jds","text":"Full name: midgard.data._time.from_jds Signature: (jd1:numpy.ndarray, jd2:numpy.ndarray, format:str) -> 'TimeArray' Create a new time array with given Julian dates and format, keep scale","title":"TimeArray.from_jds()"},{"location":"api/midgard-data/#timearraynow","text":"Full name: midgard.data._time.now Signature: (scale='utc', format='datetime') -> 'TimeArray' Create a new time representing now","title":"TimeArray.now()"},{"location":"api/midgard-data/#timearrayscale-nonetype","text":"scale = None","title":"TimeArray.scale (NoneType)"},{"location":"api/midgard-data/#timearrayto_scale","text":"Full name: midgard.data._time.to_scale Signature: (self, scale:str) -> 'TimeArray' Convert time to a different scale Returns a new TimeArray with the same time in the new scale. Args: scale : Name of new scale. Returns: TimeArray representing the same times in the new scale.","title":"TimeArray.to_scale()"},{"location":"api/midgard-data/#timearrayunit","text":"Full name: midgard.data._time.unit Signature: (self, field:str='') -> Tuple[str, ...] Unit of field","title":"TimeArray.unit()"},{"location":"api/midgard-data/#register_scale","text":"Full name: midgard.data._time.register_scale Signature: (convert_to:Dict[str, Callable]=None, convert_from:Dict[str, Callable]=None) -> Callable[[Callable], Callable] Decorator used to register new time scales The scale name is read from the .scale attribute of the Time class. Args: convert_to : Functions used to convert to other scales. convert_from : Functions used to convert from other scales. Returns: Decorator registering scale.","title":"register_scale()"},{"location":"api/midgard-data/#midgarddata_time_formats","text":"Array with time epochs","title":"midgard.data._time_formats"},{"location":"api/midgard-data/#timedatetime","text":"Full name: midgard.data._time_formats.TimeDateTime Signature: (val, val2=None)","title":"TimeDateTime"},{"location":"api/midgard-data/#timedatetimeday2seconds-float","text":"day2seconds = 86400.0","title":"TimeDateTime.day2seconds (float)"},{"location":"api/midgard-data/#timedatetimeformat-str","text":"format = 'datetime'","title":"TimeDateTime.format (str)"},{"location":"api/midgard-data/#timedatetimefrom_jds","text":"Full name: midgard.data._time_formats.from_jds Signature: (jd1, jd2)","title":"TimeDateTime.from_jds()"},{"location":"api/midgard-data/#timedatetimeto_jds","text":"Full name: midgard.data._time_formats.to_jds Signature: (val, val2=None)","title":"TimeDateTime.to_jds()"},{"location":"api/midgard-data/#timedatetimeunit-nonetype","text":"unit = None","title":"TimeDateTime.unit (NoneType)"},{"location":"api/midgard-data/#timedatetimeweek2days-float","text":"week2days = 6.999999999999998","title":"TimeDateTime.week2days (float)"},{"location":"api/midgard-data/#timeformat","text":"Full name: midgard.data._time_formats.TimeFormat Signature: (val, val2=None)","title":"TimeFormat"},{"location":"api/midgard-data/#timeformatday2seconds-float","text":"day2seconds = 86400.0","title":"TimeFormat.day2seconds (float)"},{"location":"api/midgard-data/#timeformatformat-nonetype","text":"format = None","title":"TimeFormat.format (NoneType)"},{"location":"api/midgard-data/#timeformatfrom_jds","text":"Full name: midgard.data._time_formats.from_jds Signature: (jd1, jd2) Convert Julian days to the right format","title":"TimeFormat.from_jds()"},{"location":"api/midgard-data/#timeformatto_jds","text":"Full name: midgard.data._time_formats.to_jds Signature: (val, val2) Convert val and val2 to Julian days and set the .jd1 and .jd2 attributes","title":"TimeFormat.to_jds()"},{"location":"api/midgard-data/#timeformatunit-nonetype","text":"unit = None","title":"TimeFormat.unit (NoneType)"},{"location":"api/midgard-data/#timeformatweek2days-float","text":"week2days = 6.999999999999998","title":"TimeFormat.week2days (float)"},{"location":"api/midgard-data/#timegpsweeksec","text":"Full name: midgard.data._time_formats.TimeGPSWeekSec Signature: (val, val2=None) GPS weeks and seconds.","title":"TimeGPSWeekSec"},{"location":"api/midgard-data/#timegpsweeksecday2seconds-float","text":"day2seconds = 86400.0","title":"TimeGPSWeekSec.day2seconds (float)"},{"location":"api/midgard-data/#timegpsweeksecformat-str","text":"format = 'gps_ws'","title":"TimeGPSWeekSec.format (str)"},{"location":"api/midgard-data/#timegpsweeksecfrom_jds","text":"Full name: midgard.data._time_formats.from_jds Signature: (jd1, jd2)","title":"TimeGPSWeekSec.from_jds()"},{"location":"api/midgard-data/#timegpsweeksecto_jds","text":"Full name: midgard.data._time_formats.to_jds Signature: (wwww, sec)","title":"TimeGPSWeekSec.to_jds()"},{"location":"api/midgard-data/#timegpsweeksecunit-tuple","text":"unit = ('week', 'second')","title":"TimeGPSWeekSec.unit (tuple)"},{"location":"api/midgard-data/#timegpsweeksecweek2days-float","text":"week2days = 6.999999999999998","title":"TimeGPSWeekSec.week2days (float)"},{"location":"api/midgard-data/#timejd","text":"Full name: midgard.data._time_formats.TimeJD Signature: (val, val2=None)","title":"TimeJD"},{"location":"api/midgard-data/#timejdday2seconds-float","text":"day2seconds = 86400.0","title":"TimeJD.day2seconds (float)"},{"location":"api/midgard-data/#timejdformat-str","text":"format = 'jd'","title":"TimeJD.format (str)"},{"location":"api/midgard-data/#timejdfrom_jds","text":"Full name: midgard.data._time_formats.from_jds Signature: (jd1, jd2)","title":"TimeJD.from_jds()"},{"location":"api/midgard-data/#timejdto_jds","text":"Full name: midgard.data._time_formats.to_jds Signature: (val, val2)","title":"TimeJD.to_jds()"},{"location":"api/midgard-data/#timejdunit-tuple","text":"unit = ('day',)","title":"TimeJD.unit (tuple)"},{"location":"api/midgard-data/#timejdweek2days-float","text":"week2days = 6.999999999999998","title":"TimeJD.week2days (float)"},{"location":"api/midgard-data/#timemjd","text":"Full name: midgard.data._time_formats.TimeMJD Signature: (val, val2=None) Modified Julian Date time format. This represents the number of days since midnight on November 17, 1858. For example, 51544.0 in MJD is midnight on January 1, 2000.","title":"TimeMJD"},{"location":"api/midgard-data/#timemjdday2seconds-float","text":"day2seconds = 86400.0","title":"TimeMJD.day2seconds (float)"},{"location":"api/midgard-data/#timemjdformat-str","text":"format = 'mjd'","title":"TimeMJD.format (str)"},{"location":"api/midgard-data/#timemjdfrom_jds","text":"Full name: midgard.data._time_formats.from_jds Signature: (jd1, jd2)","title":"TimeMJD.from_jds()"},{"location":"api/midgard-data/#timemjdto_jds","text":"Full name: midgard.data._time_formats.to_jds Signature: (val, val2)","title":"TimeMJD.to_jds()"},{"location":"api/midgard-data/#timemjdunit-tuple","text":"unit = ('day',)","title":"TimeMJD.unit (tuple)"},{"location":"api/midgard-data/#timemjdweek2days-float","text":"week2days = 6.999999999999998","title":"TimeMJD.week2days (float)"},{"location":"api/midgard-data/#timeyear","text":"Full name: midgard.data._time_formats.TimeYear Signature: (val, val2=None) Year.","title":"TimeYear"},{"location":"api/midgard-data/#todo-conversion-is-not-correct","text":"","title":"TODO: conversion is not correct!!!"},{"location":"api/midgard-data/#timeyearday2seconds-float","text":"day2seconds = 86400.0","title":"TimeYear.day2seconds (float)"},{"location":"api/midgard-data/#timeyearformat-str","text":"format = 'decimalyear'","title":"TimeYear.format (str)"},{"location":"api/midgard-data/#timeyearfrom_jds","text":"Full name: midgard.data._time_formats.from_jds Signature: (jds1, jds2)","title":"TimeYear.from_jds()"},{"location":"api/midgard-data/#timeyearto_jds","text":"Full name: midgard.data._time_formats.to_jds Signature: (val, val2=None)","title":"TimeYear.to_jds()"},{"location":"api/midgard-data/#timeyearunit-tuple","text":"unit = ('common_year',)","title":"TimeYear.unit (tuple)"},{"location":"api/midgard-data/#timeyearweek2days-float","text":"week2days = 6.999999999999998","title":"TimeYear.week2days (float)"},{"location":"api/midgard-data/#register_format","text":"Full name: midgard.data._time_formats.register_format Signature: (cls:Callable) -> Callable Decorator used to register new time formats The format name is read from the .format attribute of the TimeFormat class.","title":"register_format()"},{"location":"api/midgard-data/#midgarddata_time_scales","text":"Time scales and conversions between them","title":"midgard.data._time_scales"},{"location":"api/midgard-data/#gpstime","text":"Full name: midgard.data._time_scales.GpsTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None)","title":"GpsTime"},{"location":"api/midgard-data/#gpstimescale-str","text":"scale = 'gps'","title":"GpsTime.scale (str)"},{"location":"api/midgard-data/#taitime","text":"Full name: midgard.data._time_scales.TaiTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None)","title":"TaiTime"},{"location":"api/midgard-data/#taitimescale-str","text":"scale = 'tai'","title":"TaiTime.scale (str)"},{"location":"api/midgard-data/#tttime","text":"Full name: midgard.data._time_scales.TtTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None)","title":"TtTime"},{"location":"api/midgard-data/#tttimescale-str","text":"scale = 'tt'","title":"TtTime.scale (str)"},{"location":"api/midgard-data/#utctime","text":"Full name: midgard.data._time_scales.UtcTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None)","title":"UtcTime"},{"location":"api/midgard-data/#utctimescale-str","text":"scale = 'utc'","title":"UtcTime.scale (str)"},{"location":"api/midgard-data/#midgarddatadataset","text":"A dataset for handling time series data Description:","title":"midgard.data.dataset"},{"location":"api/midgard-data/#dataset","text":"Full name: midgard.data.dataset.Dataset Signature: (num_obs:int=0) -> None A dataset representing fields of data arrays","title":"Dataset"},{"location":"api/midgard-data/#datasetadd_collection","text":"Full name: midgard.data.dataset.add_collection Signature: (self, name, val, unit=None, write_level=None, suffix=None, **field_args) Add a collection field to the dataset","title":"Dataset.add_collection()"},{"location":"api/midgard-data/#datasetadd_float","text":"Full name: midgard.data.dataset.add_float Signature: (self, name, val, unit=None, write_level=None, suffix=None, **field_args) Add a float field to the dataset","title":"Dataset.add_float()"},{"location":"api/midgard-data/#datasetadd_position","text":"Full name: midgard.data.dataset.add_position Signature: (self, name, val, unit=None, write_level=None, suffix=None, **field_args) Add a position field to the dataset","title":"Dataset.add_position()"},{"location":"api/midgard-data/#datasetadd_position_delta","text":"Full name: midgard.data.dataset.add_position_delta Signature: (self, name, val, unit=None, write_level=None, suffix=None, **field_args) Add a position_delta field to the dataset","title":"Dataset.add_position_delta()"},{"location":"api/midgard-data/#datasetadd_sigma","text":"Full name: midgard.data.dataset.add_sigma Signature: (self, name, val, unit=None, write_level=None, suffix=None, **field_args) Add a sigma field to the dataset","title":"Dataset.add_sigma()"},{"location":"api/midgard-data/#datasetadd_time","text":"Full name: midgard.data.dataset.add_time Signature: (self, name, val, unit=None, write_level=None, suffix=None, **field_args) Add a time field to the dataset","title":"Dataset.add_time()"},{"location":"api/midgard-data/#datasetapply","text":"Full name: midgard.data.dataset.apply Signature: (self, func:Callable, field:str, **filters:Any) -> Any Apply a function to a field","title":"Dataset.apply()"},{"location":"api/midgard-data/#datasetas_dataframe","text":"Full name: midgard.data.dataset.as_dataframe Signature: (self, fields=None, index=None) -> pandas.core.frame.DataFrame Return a representation of the dataset as a Pandas DataFrame","title":"Dataset.as_dataframe()"},{"location":"api/midgard-data/#datasetas_dict","text":"Full name: midgard.data.dataset.as_dict Signature: (self, fields=None) -> Dict[str, Any] Return a representation of the dataset as a dictionary","title":"Dataset.as_dict()"},{"location":"api/midgard-data/#datasetcopy_from","text":"Full name: midgard.data.dataset.copy_from Signature: (self, other:'Dataset') -> None Copy observations from another dataset Args: other_dset (Dataset): The other dataset. meta_key (str): Dictionary key for introduction of an additional level in dictionary.","title":"Dataset.copy_from()"},{"location":"api/midgard-data/#datasetcount","text":"Full name: midgard.data.dataset.count Signature: (self, field:str, **filters:Any) -> int Count the number of unique values in a field","title":"Dataset.count()"},{"location":"api/midgard-data/#datasetextend","text":"Full name: midgard.data.dataset.extend Signature: (self, other_dataset:'Dataset') -> None Add observations from another dataset to the end of this dataset","title":"Dataset.extend()"},{"location":"api/midgard-data/#datasetfilter","text":"Full name: midgard.data.dataset.filter Signature: (self, idx=None, **filters) -> <built-in function array> Filter observations TODO: default_field_suffix","title":"Dataset.filter()"},{"location":"api/midgard-data/#datasetfor_each","text":"Full name: midgard.data.dataset.for_each Signature: (self, key) Do something for each suffix","title":"Dataset.for_each()"},{"location":"api/midgard-data/#datasetmean","text":"Full name: midgard.data.dataset.mean Signature: (self, field:str, **filters:Any) -> float Calculate mean of a field","title":"Dataset.mean()"},{"location":"api/midgard-data/#datasetnum","text":"Full name: midgard.data.dataset.num Signature: (self, **filters:Any) -> int Number of observations satisfying the filters","title":"Dataset.num()"},{"location":"api/midgard-data/#datasetplot_values","text":"Full name: midgard.data.dataset.plot_values Signature: (self, field:str) -> <built-in function array> Return values of a field in a form that can be plotted","title":"Dataset.plot_values()"},{"location":"api/midgard-data/#datasetread","text":"Full name: midgard.data.dataset.read Signature: (file_path:Union[str, pathlib.Path]) -> 'Dataset' Read a dataset from file","title":"Dataset.read()"},{"location":"api/midgard-data/#datasetrms","text":"Full name: midgard.data.dataset.rms Signature: (self, field:str, **filters:Any) -> float Calculate Root Mean Square of a field","title":"Dataset.rms()"},{"location":"api/midgard-data/#datasetsubset","text":"Full name: midgard.data.dataset.subset Signature: (self, idx:<built-in function array>) -> None Remove observations from all fields based on index","title":"Dataset.subset()"},{"location":"api/midgard-data/#datasetunique","text":"Full name: midgard.data.dataset.unique Signature: (self, field, **filters) -> <built-in function array> List unique values of a given field TODO: default_field_suffix","title":"Dataset.unique()"},{"location":"api/midgard-data/#datasetunit","text":"Full name: midgard.data.dataset.unit Signature: (self, field) Unit for values in a given field","title":"Dataset.unit()"},{"location":"api/midgard-data/#datasetversion-str","text":"version = 'Dataset v3.0, Midgard v0.2.0'","title":"Dataset.version (str)"},{"location":"api/midgard-data/#datasetwrite","text":"Full name: midgard.data.dataset.write Signature: (self, file_path:Union[str, pathlib.Path], write_level:Union[midgard.collections.enums.WriteLevel, NoneType]=None) -> None Write a dataset to file","title":"Dataset.write()"},{"location":"api/midgard-data/#meta","text":"Full name: midgard.data.dataset.Meta Signature: (*args, **kwargs)","title":"Meta"},{"location":"api/midgard-data/#metaadd","text":"Full name: midgard.data.dataset.add Signature: (self, section, name, value) Add information to the metaset","title":"Meta.add()"},{"location":"api/midgard-data/#metaadd_event","text":"Full name: midgard.data.dataset.add_event Signature: (self, timestamp, event_type, description) Add event to the metaset","title":"Meta.add_event()"},{"location":"api/midgard-data/#metacopy_from","text":"Full name: midgard.data.dataset.copy_from Signature: (self, other)","title":"Meta.copy_from()"},{"location":"api/midgard-data/#metaget_events","text":"Full name: midgard.data.dataset.get_events Signature: (self, *event_types) Get events from the metaset","title":"Meta.get_events()"},{"location":"api/midgard-data/#metaread","text":"Full name: midgard.data.dataset.read Signature: (self, h5_group)","title":"Meta.read()"},{"location":"api/midgard-data/#metawrite","text":"Full name: midgard.data.dataset.write Signature: (self, h5_group)","title":"Meta.write()"},{"location":"api/midgard-data/#field_type-str","text":"field_type = 'time'","title":"field_type (str)"},{"location":"api/midgard-data/#midgarddatafieldtypes","text":"Field types that can be used by Dataset","title":"midgard.data.fieldtypes"},{"location":"api/midgard-data/#function","text":"Full name: midgard.data.fieldtypes.function Signature: (plugin_name:str) -> Callable Function creating new field","title":"function()"},{"location":"api/midgard-data/#names","text":"Full name: midgard.data.fieldtypes.names Signature: () -> List[str] Names of fieldtype plugins","title":"names()"},{"location":"api/midgard-data/#midgarddatafieldtypes_fieldtype","text":"Abstract class used to define different types of tables for a Dataset","title":"midgard.data.fieldtypes._fieldtype"},{"location":"api/midgard-data/#fieldtype","text":"Full name: midgard.data.fieldtypes._fieldtype.FieldType Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args) Abstract class representing a type of field in the Dataset","title":"FieldType"},{"location":"api/midgard-data/#fieldtypeas_dataframe","text":"Full name: midgard.data.fieldtypes._fieldtype.as_dataframe Signature: (self, fields=None, index=None) -> pandas.core.frame.DataFrame Return a representation of the field as a Pandas DataFrame","title":"FieldType.as_dataframe()"},{"location":"api/midgard-data/#fieldtypeas_dict","text":"Full name: midgard.data.fieldtypes._fieldtype.as_dict Signature: (self, fields=None) -> Dict[str, Any] Return a representation of the field as a dictionary","title":"FieldType.as_dict()"},{"location":"api/midgard-data/#fieldtypecopy","text":"Full name: midgard.data.fieldtypes._fieldtype.copy Signature: (self) -> 'FieldType' Make a copy of field","title":"FieldType.copy()"},{"location":"api/midgard-data/#fieldtypecopy_from","text":"Full name: midgard.data.fieldtypes._fieldtype.copy_from Signature: (self, other_field) -> None Copy data from another field","title":"FieldType.copy_from()"},{"location":"api/midgard-data/#fieldtypeextend","text":"Full name: midgard.data.fieldtypes._fieldtype.extend Signature: (self, other_field) -> None Add observations from another field","title":"FieldType.extend()"},{"location":"api/midgard-data/#fieldtyperead","text":"Full name: midgard.data.fieldtypes._fieldtype.read Signature: (h5_group, master) -> 'FieldType' Read a field from a HDF5 data source","title":"FieldType.read()"},{"location":"api/midgard-data/#fieldtypesubset","text":"Full name: midgard.data.fieldtypes._fieldtype.subset Signature: (self, idx:<built-in function array>) -> None Remove observations from a field based on index","title":"FieldType.subset()"},{"location":"api/midgard-data/#fieldtypeunit","text":"Full name: midgard.data.fieldtypes._fieldtype.unit Signature: (self, subfield) Unit(s) of field","title":"FieldType.unit()"},{"location":"api/midgard-data/#fieldtypewrite","text":"Full name: midgard.data.fieldtypes._fieldtype.write Signature: (self, h5_group, write_level:midgard.collections.enums.WriteLevel) -> None Write data to a HDF5 data source","title":"FieldType.write()"},{"location":"api/midgard-data/#midgarddatafieldtypescollection","text":"A Dataset collection field consisting of other fields","title":"midgard.data.fieldtypes.collection"},{"location":"api/midgard-data/#collection","text":"Full name: midgard.data.fieldtypes.collection.Collection Signature: ()","title":"Collection"},{"location":"api/midgard-data/#collectionunit","text":"Full name: midgard.data.fieldtypes.collection.unit Signature: (self, field) Unit for values in a given field","title":"Collection.unit()"},{"location":"api/midgard-data/#collectionfield","text":"Full name: midgard.data.fieldtypes.collection.CollectionField Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args)","title":"CollectionField"},{"location":"api/midgard-data/#collectionfieldread","text":"Full name: midgard.data.fieldtypes.collection.read Signature: (h5_group, master)","title":"CollectionField.read()"},{"location":"api/midgard-data/#collectionfieldwrite","text":"Full name: midgard.data.fieldtypes.collection.write Signature: (self, h5_group, write_level) Write data to a HDF5 data source","title":"CollectionField.write()"},{"location":"api/midgard-data/#midgarddatafieldtypesfloat","text":"A Dataset float field","title":"midgard.data.fieldtypes.float"},{"location":"api/midgard-data/#floatfield","text":"Full name: midgard.data.fieldtypes.float.FloatField Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args)","title":"FloatField"},{"location":"api/midgard-data/#midgarddatafieldtypesposition","text":"A Dataset position field","title":"midgard.data.fieldtypes.position"},{"location":"api/midgard-data/#positionfield","text":"Full name: midgard.data.fieldtypes.position.PositionField Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args)","title":"PositionField"},{"location":"api/midgard-data/#midgarddatafieldtypesposition_delta","text":"A Dataset position delta field","title":"midgard.data.fieldtypes.position_delta"},{"location":"api/midgard-data/#positiondeltafield","text":"Full name: midgard.data.fieldtypes.position_delta.PositionDeltaField Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args)","title":"PositionDeltaField"},{"location":"api/midgard-data/#midgarddatafieldtypessigma","text":"A Dataset sigma field","title":"midgard.data.fieldtypes.sigma"},{"location":"api/midgard-data/#sigmafield","text":"Full name: midgard.data.fieldtypes.sigma.SigmaField Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args)","title":"SigmaField"},{"location":"api/midgard-data/#midgarddatafieldtypestime","text":"A Dataset time field","title":"midgard.data.fieldtypes.time"},{"location":"api/midgard-data/#timefield","text":"Full name: midgard.data.fieldtypes.time.TimeField Signature: (num_obs, master, name, val, unit=None, write_level=None, **field_args)","title":"TimeField"},{"location":"api/midgard-data/#midgarddataposition","text":"Array with positions","title":"midgard.data.position"},{"location":"api/midgard-data/#position","text":"Full name: midgard.data.position.Position Signature: (val:numpy.ndarray, system:str, **pos_args:Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system.","title":"Position()"},{"location":"api/midgard-data/#positiondelta","text":"Full name: midgard.data.position.PositionDelta Signature: (val:numpy.ndarray, system:str, ref_pos:midgard.data._position.PositionArray, **delta_args:Any) -> midgard.data._position_delta.PositionDeltaArray Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system.","title":"PositionDelta()"},{"location":"api/midgard-data/#midgarddatasigma","text":"Array with sigma values See https://docs.scipy.org/doc/numpy/user/basics.subclassing.html for information about subclassing Numpy arrays. SigmaArray is a regular Numpy array with an added field, sigma.","title":"midgard.data.sigma"},{"location":"api/midgard-data/#sigmaarray","text":"Full name: midgard.data.sigma.SigmaArray Signature: (values, sigma=None)","title":"SigmaArray"},{"location":"api/midgard-data/#midgarddatatime","text":"Array with time epochs","title":"midgard.data.time"},{"location":"api/midgard-data/#time","text":"Full name: midgard.data.time.Time Signature: (val:numpy.ndarray, scale:str, format:str, val2:Union[numpy.ndarray, NoneType]=None) -> 'TimeArray' Factory for creating TimeArrays for different systems See each time class for exact optional parameters. Args: val : Array of time values. val2 : Optional second array for extra precision. scale : Name of time scale. format : Format of values given in val and val2. Returns: Array with epochs in the given time scale and format","title":"Time()"},{"location":"api/midgard-dev/","text":"midgard.dev midgard.dev.console Simpler dealing with the console Description: Utilities for using the console. Mainly wrappers around other libraries to make them easier and more intuitive to use. Size of console: The two functions lines() and columns() report the current size of the console. Textwrapping: The function fill() can be used to rewrap a text-string so that it fits inside the console. Color: The sub-module color can be used to set the foreground and background colors. Note that the color functionality depends on the external package colorama . If colorama is not installed, color gracefully falls back to not showing any color. Examples: >>> from midgard.dev import console >>> console.columns() # doctest: +SKIP 86 >>> print(console.fill(a_very_long_string)) # doctest: +SKIP Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras tempus eleifend feugiat. Maecenas vitae posuere metus. Sed sit amet fermentum velit. Aenean vitae turpis at risus sollicitudin fringilla in in nisi. Maecenas vitae ante libero. Aenean ut eros consequat, ornare erat at, tempus arcu. Suspendisse velit leo, eleifend eget mi non, vehicula ultricies erat. Vestibulum id nisi eget nisl venenatis dignissim. Duis cursus quam dui, vel hendrerit nibh lacinia id. >>> print(console.color.Fore.YELLOW + console.color.Back.BLUE + 'I am YELLOW text on BLUE backdrop!') # doctest: +SKIP I am YELLOW text on a BLUE background! columns () Full name: midgard.dev.console.columns Signature: () -> int The width of the console Returns: The width of the console in characters. dedent () Full name: midgard.dev.console.dedent Signature: (text:str, num_spaces:Union[int, NoneType]=None) -> str Wrapper around textwrap.dedent Dedents at most num_spaces. If num_spaces is not specified, dedents as much as possible. Args: text : Text that will be dedented. num_spaces : Number of spaces that will be used for dedentation. Returns: Dedented string. fill () Full name: midgard.dev.console.fill Signature: (text:str, *, width:Union[int, NoneType]=None, hanging:Union[int, NoneType]=None, **tw_args:Any) -> str Wrapper around textwrap.fill The tw_args are passed on to textwrap.fill. See textwrap.TextWrapper for available keyword arguments. The default value for width is console.columns(), while the new argument hanging , if defined, will try to set (although not override) the textwrap-arguments initial_indent and subsequent_indent to create a hanging indent (no indent on the first line) of hanging spaces. Args: text : Text that will be wrapped. width : The maximum width (in characters) of wrapped lines. hanging : Number of characters used for hanging indent. tw_args : Arguments passed on to textwrap.fill . Returns: Wrapped string. indent () Full name: midgard.dev.console.indent Signature: (text:str, num_spaces:int, **tw_args:Any) -> str Wrapper around textwrap.indent The tw_args are passed on to textwrap.indent. Args: text : Text that will be indented. num_spaces : Number of spaces that will be used for indentation. Returns: Indented string. lines () Full name: midgard.dev.console.lines Signature: () -> int The height of the console Returns: The heigth of the console in characters. num_leading_spaces () Full name: midgard.dev.console.num_leading_spaces Signature: (text:str, space_char:str=' ') -> int Count number of leading spaces in a string Args: text : String to count. space_char : Which characters count as spaces. Returns: Number of leading spaces. midgard.dev.exceptions Definition of Midgard-specific exceptions Description: Custom exceptions used by Midgard for more specific error messages and handling. FieldDoesNotExistError Full name: midgard.dev.exceptions.FieldDoesNotExistError Signature: () FieldExistsError Full name: midgard.dev.exceptions.FieldExistsError Signature: () InitializationError Full name: midgard.dev.exceptions.InitializationError Signature: () MidgardException Full name: midgard.dev.exceptions.MidgardException Signature: () MidgardExit Full name: midgard.dev.exceptions.MidgardExit Signature: () MissingConfigurationError Full name: midgard.dev.exceptions.MissingConfigurationError Signature: () MissingDataError Full name: midgard.dev.exceptions.MissingDataError Signature: () MissingEntryError Full name: midgard.dev.exceptions.MissingEntryError Signature: () MissingSectionError Full name: midgard.dev.exceptions.MissingSectionError Signature: () ParserError Full name: midgard.dev.exceptions.ParserError Signature: () TimerNotRunning Full name: midgard.dev.exceptions.TimerNotRunning Signature: () TimerRunning Full name: midgard.dev.exceptions.TimerRunning Signature: () UnitError Full name: midgard.dev.exceptions.UnitError Signature: () UnknownConstantError Full name: midgard.dev.exceptions.UnknownConstantError Signature: () UnknownConversionError Full name: midgard.dev.exceptions.UnknownConversionError Signature: () UnknownEnumError Full name: midgard.dev.exceptions.UnknownEnumError Signature: () UnknownPackageError Full name: midgard.dev.exceptions.UnknownPackageError Signature: () UnknownPluginError Full name: midgard.dev.exceptions.UnknownPluginError Signature: () UnknownSystemError Full name: midgard.dev.exceptions.UnknownSystemError Signature: () midgard.dev.library Python wrapper around C-libraries Description: Loads a C-library. If a library is missing, a mock library is returned. If this mock is used for anything, a warning will be printed. This is done to avoid dependencies to all the C/C++-libraries for Python programs only using some of them. SimpleMock Full name: midgard.dev.library.SimpleMock Signature: (name, raise_error=True) Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (typically because a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on). load_name () Full name: midgard.dev.library.load_name Signature: (library_name, func_specs=None, name_patterns=None) Load the given shared C-library See load_path for an explanation of the func_specs and name_patterns -arguments. Args: library_name (String): The name of the library. func_specs (Dict): Specification of types in lib (see load_path). name_patterns (List): Name mangling patterns (see load_path). Returns: ctypes.CDLL: Representation of the shared library. load_path () Full name: midgard.dev.library.load_path Signature: (library_path, func_specs=None, name_patterns=None) Load the given shared C-library The optional func_specs-dictionary can be used to specify argument and return types of functions in the library (see the ctypes documentation for information about argtypes and restype). The dictionary should be on the form:: func_spec = {'func_1': dict(func_name='name_of_func_1_in_lib', argtypes=[ ... argtypes of func_1 ... ], restype=... restype of func_1 ...), 'func_2': ... } If the library is not found, a mock library is returned instead. The mock library will print a warning if it is used. For some libraries, name mangling is used and this might be different depending on operating system and how the library is compiled. For instance, in a Fortran library the function Test might be represented as __Test on a Windows system and test_ (with lower-case t ) on a Linux system. This can be handled by providing a list of possible patterns. The above example can be handled by:: name_patterns = ('__{func_name}', '{func_name_lower}_') In this case, each function in func_specs is looked up by testing each pattern in turn until a match is found. Args: library_path (String): The path to the library. func_specs (Dict): Specification of types in library (see above). name_patterns (List): Name mangling patterns (see above). Returns: ctypes.CDLL: Representation of the shared library. midgard.dev.log Midgard library module for logging Description: This module provides simple logging inside Midgard. To use it, you must first add a an active logger. This is typically done using one of the init-functions: init() or file_init(). To write a log message, simply call one of midgard.log.debug, midgard.log.info, midgard.log.warn, midgard.log.error or midgard.log.fatal with a log message. To add a different logger, you should subclass the Logger abstract class. Example: >>> from midgard.dev import log >>> log.init(\"info\", prefix=\"My prefix\") >>> n, m = 5, 3 >>> log.info(f\"Calculating the inverse of a {n:>2d}x{m:<2d} matrix\") INFO [My prefix] Calculating the inverse of a 5x3 matrix ConsoleLogger Full name: midgard.dev.log.ConsoleLogger Signature: (log_level:Union[str, NoneType]=None, prefix:str='', use_command_line:bool=True) -> None Log to the console, the log level can also be set using command line parameters ConsoleLogger. blank () Full name: midgard.dev.log.blank Signature: (self) -> None Log blank line ConsoleLogger. get_color () Full name: midgard.dev.log.get_color Signature: (level:midgard.collections.enums.LogLevel) -> str Get color string for the given log level ConsoleLogger. is_level () Full name: midgard.dev.log.is_level Signature: (level:str) -> bool Checks that level is a valid log level ConsoleLogger. log () Full name: midgard.dev.log.log Signature: (self, level:midgard.collections.enums.LogLevel, log_text:str) -> None Log text at given level ConsoleLogger.name (str) name = 'console' FileLogger Full name: midgard.dev.log.FileLogger Signature: (file_path:Union[str, pathlib.Path], log_level:Union[str, NoneType]=None, prefix:str='', rotation:Union[int, NoneType]=None) -> None Log to a file, the log files can be rotated so that older files are kept FileLogger. blank () Full name: midgard.dev.log.blank Signature: (self) -> None Log blank line FileLogger. get_color () Full name: midgard.dev.log.get_color Signature: (level:midgard.collections.enums.LogLevel) -> str Get color string for the given log level FileLogger. is_level () Full name: midgard.dev.log.is_level Signature: (level:str) -> bool Checks that level is a valid log level FileLogger. log () Full name: midgard.dev.log.log Signature: (self, level:midgard.collections.enums.LogLevel, log_text:str) -> None Log text at given level FileLogger.name (str) name = 'logger' FileLogger. rotate_files () Full name: midgard.dev.log.rotate_files Signature: (self, rotation:int) -> None Perform necessary rolling of log files Rolls the log files. That is, if there are old log files, they will be moved to files with extension .0, .1 and so on. The number of rolled logs to keep is specified by the rotation parameter. Args: rotation : Number of log files to keep. Logger Full name: midgard.dev.log.Logger Signature: (log_level:Union[str, NoneType]=None, prefix:str='') Abstract class that can be specialized to create new loggers Logger. blank () Full name: midgard.dev.log.blank Signature: (self) -> None Log blank line Logger. get_color () Full name: midgard.dev.log.get_color Signature: (level:midgard.collections.enums.LogLevel) -> str Get color string for the given log level Logger. is_level () Full name: midgard.dev.log.is_level Signature: (level:str) -> bool Checks that level is a valid log level Logger. log () Full name: midgard.dev.log.log Signature: (self, level:midgard.collections.enums.LogLevel, log_text:str) -> None Log text at given level Logger.name (str) name = 'logger' all () Full name: midgard.dev.log.all Signature: (log_text:str, *, level:str='all') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. blank () Full name: midgard.dev.log.blank Signature: () -> None Log blank line debug () Full name: midgard.dev.log.debug Signature: (log_text:str, *, level:str='debug') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. error () Full name: midgard.dev.log.error Signature: (log_text:str, *, level:str='error') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. fatal () Full name: midgard.dev.log.fatal Signature: (log_text:str, *, level:str='fatal') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. file_init Full name: midgard.dev.log.file_init Signature: (file_path:Union[str, pathlib.Path], log_level:Union[str, NoneType]=None, prefix:str='', rotation:Union[int, NoneType]=None) -> None Log to a file, the log files can be rotated so that older files are kept file_init. blank () Full name: midgard.dev.log.blank Signature: (self) -> None Log blank line file_init. get_color () Full name: midgard.dev.log.get_color Signature: (level:midgard.collections.enums.LogLevel) -> str Get color string for the given log level file_init. is_level () Full name: midgard.dev.log.is_level Signature: (level:str) -> bool Checks that level is a valid log level file_init. log () Full name: midgard.dev.log.log Signature: (self, level:midgard.collections.enums.LogLevel, log_text:str) -> None Log text at given level file_init.name (str) name = 'logger' file_init. rotate_files () Full name: midgard.dev.log.rotate_files Signature: (self, rotation:int) -> None Perform necessary rolling of log files Rolls the log files. That is, if there are old log files, they will be moved to files with extension .0, .1 and so on. The number of rolled logs to keep is specified by the rotation parameter. Args: rotation : Number of log files to keep. info () Full name: midgard.dev.log.info Signature: (log_text:str, *, level:str='info') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. init Full name: midgard.dev.log.init Signature: (log_level:Union[str, NoneType]=None, prefix:str='', use_command_line:bool=True) -> None Log to the console, the log level can also be set using command line parameters init. blank () Full name: midgard.dev.log.blank Signature: (self) -> None Log blank line init. get_color () Full name: midgard.dev.log.get_color Signature: (level:midgard.collections.enums.LogLevel) -> str Get color string for the given log level init. is_level () Full name: midgard.dev.log.is_level Signature: (level:str) -> bool Checks that level is a valid log level init. log () Full name: midgard.dev.log.log Signature: (self, level:midgard.collections.enums.LogLevel, log_text:str) -> None Log text at given level init.name (str) name = 'console' log () Full name: midgard.dev.log.log Signature: (log_text:str, level:str) -> None Log text at the given level none () Full name: midgard.dev.log.none Signature: (log_text:str, *, level:str='none') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. print_file () Full name: midgard.dev.log.print_file Signature: (log_path:Union[str, pathlib.Path], log_level:str='info', print_func:Callable[[str], NoneType]=<built-in function print>) -> None Print a log file with colors, stripping away any item below log_level warn () Full name: midgard.dev.log.warn Signature: (log_text:str, *, level:str='warn') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. midgard.dev.optional Midgard library module for handling optional dependencies Description: Import dependencies that are only necessary for specific parts of Midgard. Using this module will delay raising an ImportError until the dependency is actually used. This means that if one for instance only wants to run a GNSS analysis (or only use a Rinex-parser) installing special libraries only used for VLBI is not necessary. Examples: The optional import is typically used as follows:: from midgard.lib import optional netCDF4 = optional.optional_import('netCDF4') EmptyStringMock Full name: midgard.dev.optional.EmptyStringMock Signature: (name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None, error_msg:Union[str, NoneType]=None) -> None A mock object whose properties are all empty strings SimpleMock Full name: midgard.dev.optional.SimpleMock Signature: (name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None, error_msg:Union[str, NoneType]=None) -> None Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (for instance if a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on). The exception is if any attributes ( attrs ) are explicitly defined on the mock. No exception is raised if those attributes are looked up. optional_import () Full name: midgard.dev.optional.optional_import Signature: (module_name:str, raise_error:bool=True, mock_cls:type=<class 'midgard.dev.optional.SimpleMock'>, attrs:Union[Dict[str, Any], NoneType]=None) -> Union[Any, midgard.dev.optional.SimpleMock] Try to import an optional module If the module does not exist, a SimpleMock-object is returned instead. If this SimpleMock-object is later used, an ImportError will be raised then (if raise_error is True, which is default). Args: module_name : Name of module to import. raise_error : Whether an ImportError should be raised if the module does not exist, but is used. attrs : Attributes that should be added to the SimpleMock used if the module does not exist. Returns: Imported module object, or a SimpleMock-object if the module can not be imported. midgard.dev.plugins Set up a plug-in architecture for Midgard Description: In order to be able to add models, parsers, data sources etc without needing to hardcode names, but rather pick them from configuration files, we use a simple plug-in architecture. The plug-in mechanism is based on the different plug-ins registering themselves using the register decorator: from midgard.dev import plugins @plugins.register def simple_model(rundate, tech, dset): ... Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. To list all plug-ins in a package use names : > from midgard.dev import plugins > plugins.names('midgard.models') ['model_one', 'model_three', 'model_two'] If the optional parameter config_key is given, then only plug-ins listed in the corresponding section in the current configuration file is listed. For instance, if the configuration file contains a line saying ham_models = model_three, model_one then we can list only the ham_models as follows: > from midgard.dev import plugins > plugins.names('midgard.models', config_key='ham_models') ['model_one', 'model_three'] Note that the plug-ins by default are sorted alphabetically. To run the plug-ins, use either call_all or call_one . The former calls all plug-ins and returns a dictionary containing the result from each plug-in. As with names the optional parameter config_key may be given: > from midgard.dev import plugins > plugins.call_all('midgard.models', config_key='ham_models', arg_to_plugin='hello') {'model_three': <result from model_three>, 'model_one': <result from model_one>} Arguments to the plug-ins should be passed as named arguments to call_all . Similarly, one plug-in may be called explicitly using call_one : > from midgard.dev import plugins > plugins.call_one('midgard.models', plugin_name='model_one', arg_to_plugin='hello') <result from model_one> There may be more than one function in each plug-in that is decorated by register . In this case, the default behaviour is that only the first function will be called. To call the other registered functions one should use the list_parts function to get a list of these functions and call them explicitly using the part optional parameter to call_one : > from midgard.dev import plugins > plugins.list_parts('midgard.techniques', plugin_name='vlbi') ['read', 'edit', 'calculate', 'estimate', 'write_result']) > for part in plugins.list_parts('midgard.techniques', plugin_name='vlbi'): ... plugins.call_one('midgard.techniques', plugin_name='vlbi', part=part, ...) Plugin Full name: midgard.dev.plugins.Plugin Signature: (name:str, function:Callable, file_path:pathlib.Path, sort_value:int) Information about a plug-in Args: name : Name of the plug-in. function : The plug-in. file_path : Path to the source code of the plug-in, may be used to add the source as a dependency. sort_value : Value used when sorting plug-ins in order to control the order they are called. add_alias () Full name: midgard.dev.plugins.add_alias Signature: (package_name:str, alias:str) -> None Add alias to plug-in package This allows one package of plug-ins to be spread over several directories Args: package_name : Name of package containing plug-ins. directory : Additional plug-in directory. call () Full name: midgard.dev.plugins.call Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -> Any Call one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to the plug-in. Returns: Return value of the plug-in. call_all () Full name: midgard.dev.plugins.call_all Signature: (package_name:str, plugins:Union[List[str], NoneType]=None, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -> Dict[str, Any] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list or in the config file does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-in names that should be used (optional). part : Name of function to call within the plug-ins (optional). prefix : Prefix of the plug-in names, used for a plug-in if it is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to all the plug-ins. Returns: Dictionary of all results from the plug-ins. doc () Full name: midgard.dev.plugins.doc Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False, use_module:bool=False) -> str Document one plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Documentation of the plug-in. doc_all () Full name: midgard.dev.plugins.doc_all Signature: (package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False, use_module:bool=False) -> Dict[str, str] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-ins are unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Dictionary of all doc-strings from the plug-ins. exists () Full name: midgard.dev.plugins.exists Signature: (package_name:str, plugin_name:str) -> bool Check whether or not a plug-in exists in a package Tries to import the given plug-in. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). Returns: True if plug-in exists, False otherwise. get () Full name: midgard.dev.plugins.get Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None) -> midgard.dev.plugins.Plugin Get a specific plugin-object If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be called. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). Returns: Plugin-namedtuple representing the plug-in. load () Full name: midgard.dev.plugins.load Signature: (package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -> str Load one plug-in from a package First tries to load the plugin with the given name. If that fails, it tries to load {prefix}_{plugin_name} instead. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Actual name of plug-in (with or without prefix). names () Full name: midgard.dev.plugins.names Signature: (package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None) -> List[str] List plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be listed. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-in names are unknown (optional). Returns: List of strings with names of plug-ins. parts () Full name: midgard.dev.plugins.parts Signature: (package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -> List[str] List all parts of one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in. prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: List : Strings with names of parts. register () Full name: midgard.dev.plugins.register Signature: (func:Callable, name:Union[str, NoneType]=None, sort_value:int=0) -> Callable Decorator used to register a plug-in Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. The path to the source code file is also stored. This is used to be able to add the source code as a dependency file when the plug-in is called. If name is given, the plug-in is registered based on this name instead of the name of the module. The name of the module is still registered as a part that can be used to distinguish between similar plug-ins in different files (see for instance how session is used in midgard.pipelines ). Args: func : The function that is being registered. name : Alternative name of plug-in. Used by register_named . sort_value : The value used when sorting plug-ins. Used by register_ordered . Returns: The function that is being registered. register_named () Full name: midgard.dev.plugins.register_named Signature: (name:str) -> Callable Decorator used to register a named plug-in This allows for overriding the name used to register the plug-in. See register for more details. Args: name : Name used for plug-in instead of module name. Returns: Decorator that registers a named function. register_ordered () Full name: midgard.dev.plugins.register_ordered Signature: (sort_value:int) -> Callable Decorator used to register a plug-in with a specific sort order The sort value should be a number. Lower numbers are sorted first, higher numbers last. Plug-ins without an explicit sort_order gets the sort value of 0. Args: sort_value : The value used when sorting plug-ins. Returns: Decorator that registers an ordered function. signature () Full name: midgard.dev.plugins.signature Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None) -> inspect.Signature Get signature of a plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Signature of the plugin midgard.dev.profiler Add a profiler when running Supports several profilers including cprofile, line_profiler, memprof and memory_profiler. CProfile Full name: midgard.dev.profiler.CProfile Signature: () cprofile is used for profiling the whole program CProfile. end () Full name: midgard.dev.profiler.end Signature: (self) Stop profiler CProfile.extension (NotImplementedType) extension = NotImplemented CProfile.option (str) option = '--profiler' CProfile.pip_name (str) pip_name = 'cprofile' CProfile. setup () Full name: midgard.dev.profiler.setup Signature: (self, options) Set up profiler CProfile. show () Full name: midgard.dev.profiler.show Signature: (self) Show results of profiler session in console CProfile. start () Full name: midgard.dev.profiler.start Signature: (self) CProfile. write () Full name: midgard.dev.profiler.write Signature: (self) Write results of profiler session to disk LineProfiler Full name: midgard.dev.profiler.LineProfiler Signature: () line_profiler is used to profile one or a few functions in detail LineProfiler. end () Full name: midgard.dev.profiler.end Signature: (self) Stop profiler LineProfiler.extension (NotImplementedType) extension = NotImplemented LineProfiler.option (str) option = '--line_profiler' LineProfiler.pip_name (str) pip_name = 'line_profiler' LineProfiler. setup () Full name: midgard.dev.profiler.setup Signature: (self, options) Set up profiler LineProfiler. show () Full name: midgard.dev.profiler.show Signature: (self) Show results of profiler session in console LineProfiler. start () Full name: midgard.dev.profiler.start Signature: (self) Start profiler LineProfiler. write () Full name: midgard.dev.profiler.write Signature: (self) Write results of profiler session to disk Profiler Full name: midgard.dev.profiler.Profiler Signature: () Base class for profilers Profiler. end () Full name: midgard.dev.profiler.end Signature: (self) Stop profiler Profiler.extension (NotImplementedType) extension = NotImplemented Profiler.option (NotImplementedType) option = NotImplemented Profiler.pip_name (NotImplementedType) pip_name = NotImplemented Profiler. setup () Full name: midgard.dev.profiler.setup Signature: (self, options) Set up profiler Profiler. show () Full name: midgard.dev.profiler.show Signature: (self) Show results of profiler session in console Profiler. start () Full name: midgard.dev.profiler.start Signature: (self) Start profiler Profiler. write () Full name: midgard.dev.profiler.write Signature: (self) Write results of profiler session to disk midgard.dev.timer Class for timing the running time of functions and code blocks Description: The dev.timer can be used to log the running time of functions and general code blocks. Typically, you will import the Timer -class from within the module: from midgard.dev.timer import Timer The Timer can then be used in three different ways: As a decorator to time one function: @Timer('The time to execute some_function was') def some_function(some_argument, some_other_argument=some_value): pass As a context manager together with with to time a code block: with Timer('Finish doing stuff in', logger=logger.debug) as t: do_something() do_something_else() With explicit start - and end -statements: t = Timer() t.start() do_something() do_something_else() t.end() As can be seen in the examples above, Timer() may be called with several optional parameters, including the text to report when the timer ends and which logger is used to report the timing. See Timer.__init__ for more details. AccumulatedTimer Full name: midgard.dev.timer.AccumulatedTimer Signature: (text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=functools.partial(<function log at 0x7f15061d2ea0>, level='info')) -> None AccumulatedTimer. elapsed () Full name: midgard.dev.timer.elapsed Signature: (self) -> float Log the time elapsed Can be used explicitly to log the time since a timer started without ending the timer. Returns: The time elapsed in seconds. AccumulatedTimer. end () Full name: midgard.dev.timer.end Signature: (self) -> float End the timer and log the time elapsed Returns: The time elapsed in seconds. AccumulatedTimer. pause () Full name: midgard.dev.timer.pause Signature: (self) -> float Pause the timer without logging. Use .start() to restart the timer AccumulatedTimer. reset () Full name: midgard.dev.timer.reset Signature: (self) -> None Reset the timer back to 0 AccumulatedTimer. start () Full name: midgard.dev.timer.start Signature: (self) -> None Start the timer AccumulatedTimer. timer () Full name: midgard.dev.timer.timer Signature: () -> float Get current value of timer Using the built-in time.perf_counter to do the timing. Returns: Current value of timer. Timer Full name: midgard.dev.timer.Timer Signature: (text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=functools.partial(<function log at 0x7f15061d2ea0>, level='info')) -> None Class for timing running time of functions and code blocks. Timer. elapsed () Full name: midgard.dev.timer.elapsed Signature: (self) -> float Log the time elapsed Can be used explicitly to log the time since a timer started without ending the timer. Returns: The time elapsed in seconds. Timer. end () Full name: midgard.dev.timer.end Signature: (self) -> float End the timer and log the time elapsed Returns: The time elapsed in seconds. Timer. pause () Full name: midgard.dev.timer.pause Signature: (self) -> float Pause the timer without logging. Use .start() to restart the timer Timer. start () Full name: midgard.dev.timer.start Signature: (self) -> None Start the timer Timer. timer () Full name: midgard.dev.timer.timer Signature: () -> float Get current value of timer Using the built-in time.perf_counter to do the timing. Returns: Current value of timer.","title":"midgard.dev"},{"location":"api/midgard-dev/#midgarddev","text":"","title":"midgard.dev"},{"location":"api/midgard-dev/#midgarddevconsole","text":"Simpler dealing with the console Description: Utilities for using the console. Mainly wrappers around other libraries to make them easier and more intuitive to use. Size of console: The two functions lines() and columns() report the current size of the console. Textwrapping: The function fill() can be used to rewrap a text-string so that it fits inside the console. Color: The sub-module color can be used to set the foreground and background colors. Note that the color functionality depends on the external package colorama . If colorama is not installed, color gracefully falls back to not showing any color. Examples: >>> from midgard.dev import console >>> console.columns() # doctest: +SKIP 86 >>> print(console.fill(a_very_long_string)) # doctest: +SKIP Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras tempus eleifend feugiat. Maecenas vitae posuere metus. Sed sit amet fermentum velit. Aenean vitae turpis at risus sollicitudin fringilla in in nisi. Maecenas vitae ante libero. Aenean ut eros consequat, ornare erat at, tempus arcu. Suspendisse velit leo, eleifend eget mi non, vehicula ultricies erat. Vestibulum id nisi eget nisl venenatis dignissim. Duis cursus quam dui, vel hendrerit nibh lacinia id. >>> print(console.color.Fore.YELLOW + console.color.Back.BLUE + 'I am YELLOW text on BLUE backdrop!') # doctest: +SKIP I am YELLOW text on a BLUE background!","title":"midgard.dev.console"},{"location":"api/midgard-dev/#columns","text":"Full name: midgard.dev.console.columns Signature: () -> int The width of the console Returns: The width of the console in characters.","title":"columns()"},{"location":"api/midgard-dev/#dedent","text":"Full name: midgard.dev.console.dedent Signature: (text:str, num_spaces:Union[int, NoneType]=None) -> str Wrapper around textwrap.dedent Dedents at most num_spaces. If num_spaces is not specified, dedents as much as possible. Args: text : Text that will be dedented. num_spaces : Number of spaces that will be used for dedentation. Returns: Dedented string.","title":"dedent()"},{"location":"api/midgard-dev/#fill","text":"Full name: midgard.dev.console.fill Signature: (text:str, *, width:Union[int, NoneType]=None, hanging:Union[int, NoneType]=None, **tw_args:Any) -> str Wrapper around textwrap.fill The tw_args are passed on to textwrap.fill. See textwrap.TextWrapper for available keyword arguments. The default value for width is console.columns(), while the new argument hanging , if defined, will try to set (although not override) the textwrap-arguments initial_indent and subsequent_indent to create a hanging indent (no indent on the first line) of hanging spaces. Args: text : Text that will be wrapped. width : The maximum width (in characters) of wrapped lines. hanging : Number of characters used for hanging indent. tw_args : Arguments passed on to textwrap.fill . Returns: Wrapped string.","title":"fill()"},{"location":"api/midgard-dev/#indent","text":"Full name: midgard.dev.console.indent Signature: (text:str, num_spaces:int, **tw_args:Any) -> str Wrapper around textwrap.indent The tw_args are passed on to textwrap.indent. Args: text : Text that will be indented. num_spaces : Number of spaces that will be used for indentation. Returns: Indented string.","title":"indent()"},{"location":"api/midgard-dev/#lines","text":"Full name: midgard.dev.console.lines Signature: () -> int The height of the console Returns: The heigth of the console in characters.","title":"lines()"},{"location":"api/midgard-dev/#num_leading_spaces","text":"Full name: midgard.dev.console.num_leading_spaces Signature: (text:str, space_char:str=' ') -> int Count number of leading spaces in a string Args: text : String to count. space_char : Which characters count as spaces. Returns: Number of leading spaces.","title":"num_leading_spaces()"},{"location":"api/midgard-dev/#midgarddevexceptions","text":"Definition of Midgard-specific exceptions Description: Custom exceptions used by Midgard for more specific error messages and handling.","title":"midgard.dev.exceptions"},{"location":"api/midgard-dev/#fielddoesnotexisterror","text":"Full name: midgard.dev.exceptions.FieldDoesNotExistError Signature: ()","title":"FieldDoesNotExistError"},{"location":"api/midgard-dev/#fieldexistserror","text":"Full name: midgard.dev.exceptions.FieldExistsError Signature: ()","title":"FieldExistsError"},{"location":"api/midgard-dev/#initializationerror","text":"Full name: midgard.dev.exceptions.InitializationError Signature: ()","title":"InitializationError"},{"location":"api/midgard-dev/#midgardexception","text":"Full name: midgard.dev.exceptions.MidgardException Signature: ()","title":"MidgardException"},{"location":"api/midgard-dev/#midgardexit","text":"Full name: midgard.dev.exceptions.MidgardExit Signature: ()","title":"MidgardExit"},{"location":"api/midgard-dev/#missingconfigurationerror","text":"Full name: midgard.dev.exceptions.MissingConfigurationError Signature: ()","title":"MissingConfigurationError"},{"location":"api/midgard-dev/#missingdataerror","text":"Full name: midgard.dev.exceptions.MissingDataError Signature: ()","title":"MissingDataError"},{"location":"api/midgard-dev/#missingentryerror","text":"Full name: midgard.dev.exceptions.MissingEntryError Signature: ()","title":"MissingEntryError"},{"location":"api/midgard-dev/#missingsectionerror","text":"Full name: midgard.dev.exceptions.MissingSectionError Signature: ()","title":"MissingSectionError"},{"location":"api/midgard-dev/#parsererror","text":"Full name: midgard.dev.exceptions.ParserError Signature: ()","title":"ParserError"},{"location":"api/midgard-dev/#timernotrunning","text":"Full name: midgard.dev.exceptions.TimerNotRunning Signature: ()","title":"TimerNotRunning"},{"location":"api/midgard-dev/#timerrunning","text":"Full name: midgard.dev.exceptions.TimerRunning Signature: ()","title":"TimerRunning"},{"location":"api/midgard-dev/#uniterror","text":"Full name: midgard.dev.exceptions.UnitError Signature: ()","title":"UnitError"},{"location":"api/midgard-dev/#unknownconstanterror","text":"Full name: midgard.dev.exceptions.UnknownConstantError Signature: ()","title":"UnknownConstantError"},{"location":"api/midgard-dev/#unknownconversionerror","text":"Full name: midgard.dev.exceptions.UnknownConversionError Signature: ()","title":"UnknownConversionError"},{"location":"api/midgard-dev/#unknownenumerror","text":"Full name: midgard.dev.exceptions.UnknownEnumError Signature: ()","title":"UnknownEnumError"},{"location":"api/midgard-dev/#unknownpackageerror","text":"Full name: midgard.dev.exceptions.UnknownPackageError Signature: ()","title":"UnknownPackageError"},{"location":"api/midgard-dev/#unknownpluginerror","text":"Full name: midgard.dev.exceptions.UnknownPluginError Signature: ()","title":"UnknownPluginError"},{"location":"api/midgard-dev/#unknownsystemerror","text":"Full name: midgard.dev.exceptions.UnknownSystemError Signature: ()","title":"UnknownSystemError"},{"location":"api/midgard-dev/#midgarddevlibrary","text":"Python wrapper around C-libraries Description: Loads a C-library. If a library is missing, a mock library is returned. If this mock is used for anything, a warning will be printed. This is done to avoid dependencies to all the C/C++-libraries for Python programs only using some of them.","title":"midgard.dev.library"},{"location":"api/midgard-dev/#simplemock","text":"Full name: midgard.dev.library.SimpleMock Signature: (name, raise_error=True) Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (typically because a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on).","title":"SimpleMock"},{"location":"api/midgard-dev/#load_name","text":"Full name: midgard.dev.library.load_name Signature: (library_name, func_specs=None, name_patterns=None) Load the given shared C-library See load_path for an explanation of the func_specs and name_patterns -arguments. Args: library_name (String): The name of the library. func_specs (Dict): Specification of types in lib (see load_path). name_patterns (List): Name mangling patterns (see load_path). Returns: ctypes.CDLL: Representation of the shared library.","title":"load_name()"},{"location":"api/midgard-dev/#load_path","text":"Full name: midgard.dev.library.load_path Signature: (library_path, func_specs=None, name_patterns=None) Load the given shared C-library The optional func_specs-dictionary can be used to specify argument and return types of functions in the library (see the ctypes documentation for information about argtypes and restype). The dictionary should be on the form:: func_spec = {'func_1': dict(func_name='name_of_func_1_in_lib', argtypes=[ ... argtypes of func_1 ... ], restype=... restype of func_1 ...), 'func_2': ... } If the library is not found, a mock library is returned instead. The mock library will print a warning if it is used. For some libraries, name mangling is used and this might be different depending on operating system and how the library is compiled. For instance, in a Fortran library the function Test might be represented as __Test on a Windows system and test_ (with lower-case t ) on a Linux system. This can be handled by providing a list of possible patterns. The above example can be handled by:: name_patterns = ('__{func_name}', '{func_name_lower}_') In this case, each function in func_specs is looked up by testing each pattern in turn until a match is found. Args: library_path (String): The path to the library. func_specs (Dict): Specification of types in library (see above). name_patterns (List): Name mangling patterns (see above). Returns: ctypes.CDLL: Representation of the shared library.","title":"load_path()"},{"location":"api/midgard-dev/#midgarddevlog","text":"Midgard library module for logging Description: This module provides simple logging inside Midgard. To use it, you must first add a an active logger. This is typically done using one of the init-functions: init() or file_init(). To write a log message, simply call one of midgard.log.debug, midgard.log.info, midgard.log.warn, midgard.log.error or midgard.log.fatal with a log message. To add a different logger, you should subclass the Logger abstract class. Example: >>> from midgard.dev import log >>> log.init(\"info\", prefix=\"My prefix\") >>> n, m = 5, 3 >>> log.info(f\"Calculating the inverse of a {n:>2d}x{m:<2d} matrix\") INFO [My prefix] Calculating the inverse of a 5x3 matrix","title":"midgard.dev.log"},{"location":"api/midgard-dev/#consolelogger","text":"Full name: midgard.dev.log.ConsoleLogger Signature: (log_level:Union[str, NoneType]=None, prefix:str='', use_command_line:bool=True) -> None Log to the console, the log level can also be set using command line parameters","title":"ConsoleLogger"},{"location":"api/midgard-dev/#consoleloggerblank","text":"Full name: midgard.dev.log.blank Signature: (self) -> None Log blank line","title":"ConsoleLogger.blank()"},{"location":"api/midgard-dev/#consoleloggerget_color","text":"Full name: midgard.dev.log.get_color Signature: (level:midgard.collections.enums.LogLevel) -> str Get color string for the given log level","title":"ConsoleLogger.get_color()"},{"location":"api/midgard-dev/#consoleloggeris_level","text":"Full name: midgard.dev.log.is_level Signature: (level:str) -> bool Checks that level is a valid log level","title":"ConsoleLogger.is_level()"},{"location":"api/midgard-dev/#consoleloggerlog","text":"Full name: midgard.dev.log.log Signature: (self, level:midgard.collections.enums.LogLevel, log_text:str) -> None Log text at given level","title":"ConsoleLogger.log()"},{"location":"api/midgard-dev/#consoleloggername-str","text":"name = 'console'","title":"ConsoleLogger.name (str)"},{"location":"api/midgard-dev/#filelogger","text":"Full name: midgard.dev.log.FileLogger Signature: (file_path:Union[str, pathlib.Path], log_level:Union[str, NoneType]=None, prefix:str='', rotation:Union[int, NoneType]=None) -> None Log to a file, the log files can be rotated so that older files are kept","title":"FileLogger"},{"location":"api/midgard-dev/#fileloggerblank","text":"Full name: midgard.dev.log.blank Signature: (self) -> None Log blank line","title":"FileLogger.blank()"},{"location":"api/midgard-dev/#fileloggerget_color","text":"Full name: midgard.dev.log.get_color Signature: (level:midgard.collections.enums.LogLevel) -> str Get color string for the given log level","title":"FileLogger.get_color()"},{"location":"api/midgard-dev/#fileloggeris_level","text":"Full name: midgard.dev.log.is_level Signature: (level:str) -> bool Checks that level is a valid log level","title":"FileLogger.is_level()"},{"location":"api/midgard-dev/#fileloggerlog","text":"Full name: midgard.dev.log.log Signature: (self, level:midgard.collections.enums.LogLevel, log_text:str) -> None Log text at given level","title":"FileLogger.log()"},{"location":"api/midgard-dev/#fileloggername-str","text":"name = 'logger'","title":"FileLogger.name (str)"},{"location":"api/midgard-dev/#fileloggerrotate_files","text":"Full name: midgard.dev.log.rotate_files Signature: (self, rotation:int) -> None Perform necessary rolling of log files Rolls the log files. That is, if there are old log files, they will be moved to files with extension .0, .1 and so on. The number of rolled logs to keep is specified by the rotation parameter. Args: rotation : Number of log files to keep.","title":"FileLogger.rotate_files()"},{"location":"api/midgard-dev/#logger","text":"Full name: midgard.dev.log.Logger Signature: (log_level:Union[str, NoneType]=None, prefix:str='') Abstract class that can be specialized to create new loggers","title":"Logger"},{"location":"api/midgard-dev/#loggerblank","text":"Full name: midgard.dev.log.blank Signature: (self) -> None Log blank line","title":"Logger.blank()"},{"location":"api/midgard-dev/#loggerget_color","text":"Full name: midgard.dev.log.get_color Signature: (level:midgard.collections.enums.LogLevel) -> str Get color string for the given log level","title":"Logger.get_color()"},{"location":"api/midgard-dev/#loggeris_level","text":"Full name: midgard.dev.log.is_level Signature: (level:str) -> bool Checks that level is a valid log level","title":"Logger.is_level()"},{"location":"api/midgard-dev/#loggerlog","text":"Full name: midgard.dev.log.log Signature: (self, level:midgard.collections.enums.LogLevel, log_text:str) -> None Log text at given level","title":"Logger.log()"},{"location":"api/midgard-dev/#loggername-str","text":"name = 'logger'","title":"Logger.name (str)"},{"location":"api/midgard-dev/#all","text":"Full name: midgard.dev.log.all Signature: (log_text:str, *, level:str='all') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"all()"},{"location":"api/midgard-dev/#blank","text":"Full name: midgard.dev.log.blank Signature: () -> None Log blank line","title":"blank()"},{"location":"api/midgard-dev/#debug","text":"Full name: midgard.dev.log.debug Signature: (log_text:str, *, level:str='debug') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"debug()"},{"location":"api/midgard-dev/#error","text":"Full name: midgard.dev.log.error Signature: (log_text:str, *, level:str='error') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"error()"},{"location":"api/midgard-dev/#fatal","text":"Full name: midgard.dev.log.fatal Signature: (log_text:str, *, level:str='fatal') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"fatal()"},{"location":"api/midgard-dev/#file_init","text":"Full name: midgard.dev.log.file_init Signature: (file_path:Union[str, pathlib.Path], log_level:Union[str, NoneType]=None, prefix:str='', rotation:Union[int, NoneType]=None) -> None Log to a file, the log files can be rotated so that older files are kept","title":"file_init"},{"location":"api/midgard-dev/#file_initblank","text":"Full name: midgard.dev.log.blank Signature: (self) -> None Log blank line","title":"file_init.blank()"},{"location":"api/midgard-dev/#file_initget_color","text":"Full name: midgard.dev.log.get_color Signature: (level:midgard.collections.enums.LogLevel) -> str Get color string for the given log level","title":"file_init.get_color()"},{"location":"api/midgard-dev/#file_initis_level","text":"Full name: midgard.dev.log.is_level Signature: (level:str) -> bool Checks that level is a valid log level","title":"file_init.is_level()"},{"location":"api/midgard-dev/#file_initlog","text":"Full name: midgard.dev.log.log Signature: (self, level:midgard.collections.enums.LogLevel, log_text:str) -> None Log text at given level","title":"file_init.log()"},{"location":"api/midgard-dev/#file_initname-str","text":"name = 'logger'","title":"file_init.name (str)"},{"location":"api/midgard-dev/#file_initrotate_files","text":"Full name: midgard.dev.log.rotate_files Signature: (self, rotation:int) -> None Perform necessary rolling of log files Rolls the log files. That is, if there are old log files, they will be moved to files with extension .0, .1 and so on. The number of rolled logs to keep is specified by the rotation parameter. Args: rotation : Number of log files to keep.","title":"file_init.rotate_files()"},{"location":"api/midgard-dev/#info","text":"Full name: midgard.dev.log.info Signature: (log_text:str, *, level:str='info') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"info()"},{"location":"api/midgard-dev/#init","text":"Full name: midgard.dev.log.init Signature: (log_level:Union[str, NoneType]=None, prefix:str='', use_command_line:bool=True) -> None Log to the console, the log level can also be set using command line parameters","title":"init"},{"location":"api/midgard-dev/#initblank","text":"Full name: midgard.dev.log.blank Signature: (self) -> None Log blank line","title":"init.blank()"},{"location":"api/midgard-dev/#initget_color","text":"Full name: midgard.dev.log.get_color Signature: (level:midgard.collections.enums.LogLevel) -> str Get color string for the given log level","title":"init.get_color()"},{"location":"api/midgard-dev/#initis_level","text":"Full name: midgard.dev.log.is_level Signature: (level:str) -> bool Checks that level is a valid log level","title":"init.is_level()"},{"location":"api/midgard-dev/#initlog","text":"Full name: midgard.dev.log.log Signature: (self, level:midgard.collections.enums.LogLevel, log_text:str) -> None Log text at given level","title":"init.log()"},{"location":"api/midgard-dev/#initname-str","text":"name = 'console'","title":"init.name (str)"},{"location":"api/midgard-dev/#log","text":"Full name: midgard.dev.log.log Signature: (log_text:str, level:str) -> None Log text at the given level","title":"log()"},{"location":"api/midgard-dev/#none","text":"Full name: midgard.dev.log.none Signature: (log_text:str, *, level:str='none') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"none()"},{"location":"api/midgard-dev/#print_file","text":"Full name: midgard.dev.log.print_file Signature: (log_path:Union[str, pathlib.Path], log_level:str='info', print_func:Callable[[str], NoneType]=<built-in function print>) -> None Print a log file with colors, stripping away any item below log_level","title":"print_file()"},{"location":"api/midgard-dev/#warn","text":"Full name: midgard.dev.log.warn Signature: (log_text:str, *, level:str='warn') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"warn()"},{"location":"api/midgard-dev/#midgarddevoptional","text":"Midgard library module for handling optional dependencies Description: Import dependencies that are only necessary for specific parts of Midgard. Using this module will delay raising an ImportError until the dependency is actually used. This means that if one for instance only wants to run a GNSS analysis (or only use a Rinex-parser) installing special libraries only used for VLBI is not necessary. Examples: The optional import is typically used as follows:: from midgard.lib import optional netCDF4 = optional.optional_import('netCDF4')","title":"midgard.dev.optional"},{"location":"api/midgard-dev/#emptystringmock","text":"Full name: midgard.dev.optional.EmptyStringMock Signature: (name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None, error_msg:Union[str, NoneType]=None) -> None A mock object whose properties are all empty strings","title":"EmptyStringMock"},{"location":"api/midgard-dev/#simplemock_1","text":"Full name: midgard.dev.optional.SimpleMock Signature: (name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None, error_msg:Union[str, NoneType]=None) -> None Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (for instance if a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on). The exception is if any attributes ( attrs ) are explicitly defined on the mock. No exception is raised if those attributes are looked up.","title":"SimpleMock"},{"location":"api/midgard-dev/#optional_import","text":"Full name: midgard.dev.optional.optional_import Signature: (module_name:str, raise_error:bool=True, mock_cls:type=<class 'midgard.dev.optional.SimpleMock'>, attrs:Union[Dict[str, Any], NoneType]=None) -> Union[Any, midgard.dev.optional.SimpleMock] Try to import an optional module If the module does not exist, a SimpleMock-object is returned instead. If this SimpleMock-object is later used, an ImportError will be raised then (if raise_error is True, which is default). Args: module_name : Name of module to import. raise_error : Whether an ImportError should be raised if the module does not exist, but is used. attrs : Attributes that should be added to the SimpleMock used if the module does not exist. Returns: Imported module object, or a SimpleMock-object if the module can not be imported.","title":"optional_import()"},{"location":"api/midgard-dev/#midgarddevplugins","text":"Set up a plug-in architecture for Midgard Description: In order to be able to add models, parsers, data sources etc without needing to hardcode names, but rather pick them from configuration files, we use a simple plug-in architecture. The plug-in mechanism is based on the different plug-ins registering themselves using the register decorator: from midgard.dev import plugins @plugins.register def simple_model(rundate, tech, dset): ... Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. To list all plug-ins in a package use names : > from midgard.dev import plugins > plugins.names('midgard.models') ['model_one', 'model_three', 'model_two'] If the optional parameter config_key is given, then only plug-ins listed in the corresponding section in the current configuration file is listed. For instance, if the configuration file contains a line saying ham_models = model_three, model_one then we can list only the ham_models as follows: > from midgard.dev import plugins > plugins.names('midgard.models', config_key='ham_models') ['model_one', 'model_three'] Note that the plug-ins by default are sorted alphabetically. To run the plug-ins, use either call_all or call_one . The former calls all plug-ins and returns a dictionary containing the result from each plug-in. As with names the optional parameter config_key may be given: > from midgard.dev import plugins > plugins.call_all('midgard.models', config_key='ham_models', arg_to_plugin='hello') {'model_three': <result from model_three>, 'model_one': <result from model_one>} Arguments to the plug-ins should be passed as named arguments to call_all . Similarly, one plug-in may be called explicitly using call_one : > from midgard.dev import plugins > plugins.call_one('midgard.models', plugin_name='model_one', arg_to_plugin='hello') <result from model_one> There may be more than one function in each plug-in that is decorated by register . In this case, the default behaviour is that only the first function will be called. To call the other registered functions one should use the list_parts function to get a list of these functions and call them explicitly using the part optional parameter to call_one : > from midgard.dev import plugins > plugins.list_parts('midgard.techniques', plugin_name='vlbi') ['read', 'edit', 'calculate', 'estimate', 'write_result']) > for part in plugins.list_parts('midgard.techniques', plugin_name='vlbi'): ... plugins.call_one('midgard.techniques', plugin_name='vlbi', part=part, ...)","title":"midgard.dev.plugins"},{"location":"api/midgard-dev/#plugin","text":"Full name: midgard.dev.plugins.Plugin Signature: (name:str, function:Callable, file_path:pathlib.Path, sort_value:int) Information about a plug-in Args: name : Name of the plug-in. function : The plug-in. file_path : Path to the source code of the plug-in, may be used to add the source as a dependency. sort_value : Value used when sorting plug-ins in order to control the order they are called.","title":"Plugin"},{"location":"api/midgard-dev/#add_alias","text":"Full name: midgard.dev.plugins.add_alias Signature: (package_name:str, alias:str) -> None Add alias to plug-in package This allows one package of plug-ins to be spread over several directories Args: package_name : Name of package containing plug-ins. directory : Additional plug-in directory.","title":"add_alias()"},{"location":"api/midgard-dev/#call","text":"Full name: midgard.dev.plugins.call Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -> Any Call one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to the plug-in. Returns: Return value of the plug-in.","title":"call()"},{"location":"api/midgard-dev/#call_all","text":"Full name: midgard.dev.plugins.call_all Signature: (package_name:str, plugins:Union[List[str], NoneType]=None, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -> Dict[str, Any] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list or in the config file does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-in names that should be used (optional). part : Name of function to call within the plug-ins (optional). prefix : Prefix of the plug-in names, used for a plug-in if it is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to all the plug-ins. Returns: Dictionary of all results from the plug-ins.","title":"call_all()"},{"location":"api/midgard-dev/#doc","text":"Full name: midgard.dev.plugins.doc Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False, use_module:bool=False) -> str Document one plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Documentation of the plug-in.","title":"doc()"},{"location":"api/midgard-dev/#doc_all","text":"Full name: midgard.dev.plugins.doc_all Signature: (package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False, use_module:bool=False) -> Dict[str, str] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-ins are unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Dictionary of all doc-strings from the plug-ins.","title":"doc_all()"},{"location":"api/midgard-dev/#exists","text":"Full name: midgard.dev.plugins.exists Signature: (package_name:str, plugin_name:str) -> bool Check whether or not a plug-in exists in a package Tries to import the given plug-in. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). Returns: True if plug-in exists, False otherwise.","title":"exists()"},{"location":"api/midgard-dev/#get","text":"Full name: midgard.dev.plugins.get Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None) -> midgard.dev.plugins.Plugin Get a specific plugin-object If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be called. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). Returns: Plugin-namedtuple representing the plug-in.","title":"get()"},{"location":"api/midgard-dev/#load","text":"Full name: midgard.dev.plugins.load Signature: (package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -> str Load one plug-in from a package First tries to load the plugin with the given name. If that fails, it tries to load {prefix}_{plugin_name} instead. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Actual name of plug-in (with or without prefix).","title":"load()"},{"location":"api/midgard-dev/#names","text":"Full name: midgard.dev.plugins.names Signature: (package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None) -> List[str] List plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be listed. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-in names are unknown (optional). Returns: List of strings with names of plug-ins.","title":"names()"},{"location":"api/midgard-dev/#parts","text":"Full name: midgard.dev.plugins.parts Signature: (package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -> List[str] List all parts of one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in. prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: List : Strings with names of parts.","title":"parts()"},{"location":"api/midgard-dev/#register","text":"Full name: midgard.dev.plugins.register Signature: (func:Callable, name:Union[str, NoneType]=None, sort_value:int=0) -> Callable Decorator used to register a plug-in Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. The path to the source code file is also stored. This is used to be able to add the source code as a dependency file when the plug-in is called. If name is given, the plug-in is registered based on this name instead of the name of the module. The name of the module is still registered as a part that can be used to distinguish between similar plug-ins in different files (see for instance how session is used in midgard.pipelines ). Args: func : The function that is being registered. name : Alternative name of plug-in. Used by register_named . sort_value : The value used when sorting plug-ins. Used by register_ordered . Returns: The function that is being registered.","title":"register()"},{"location":"api/midgard-dev/#register_named","text":"Full name: midgard.dev.plugins.register_named Signature: (name:str) -> Callable Decorator used to register a named plug-in This allows for overriding the name used to register the plug-in. See register for more details. Args: name : Name used for plug-in instead of module name. Returns: Decorator that registers a named function.","title":"register_named()"},{"location":"api/midgard-dev/#register_ordered","text":"Full name: midgard.dev.plugins.register_ordered Signature: (sort_value:int) -> Callable Decorator used to register a plug-in with a specific sort order The sort value should be a number. Lower numbers are sorted first, higher numbers last. Plug-ins without an explicit sort_order gets the sort value of 0. Args: sort_value : The value used when sorting plug-ins. Returns: Decorator that registers an ordered function.","title":"register_ordered()"},{"location":"api/midgard-dev/#signature","text":"Full name: midgard.dev.plugins.signature Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None) -> inspect.Signature Get signature of a plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Signature of the plugin","title":"signature()"},{"location":"api/midgard-dev/#midgarddevprofiler","text":"Add a profiler when running Supports several profilers including cprofile, line_profiler, memprof and memory_profiler.","title":"midgard.dev.profiler"},{"location":"api/midgard-dev/#cprofile","text":"Full name: midgard.dev.profiler.CProfile Signature: () cprofile is used for profiling the whole program","title":"CProfile"},{"location":"api/midgard-dev/#cprofileend","text":"Full name: midgard.dev.profiler.end Signature: (self) Stop profiler","title":"CProfile.end()"},{"location":"api/midgard-dev/#cprofileextension-notimplementedtype","text":"extension = NotImplemented","title":"CProfile.extension (NotImplementedType)"},{"location":"api/midgard-dev/#cprofileoption-str","text":"option = '--profiler'","title":"CProfile.option (str)"},{"location":"api/midgard-dev/#cprofilepip_name-str","text":"pip_name = 'cprofile'","title":"CProfile.pip_name (str)"},{"location":"api/midgard-dev/#cprofilesetup","text":"Full name: midgard.dev.profiler.setup Signature: (self, options) Set up profiler","title":"CProfile.setup()"},{"location":"api/midgard-dev/#cprofileshow","text":"Full name: midgard.dev.profiler.show Signature: (self) Show results of profiler session in console","title":"CProfile.show()"},{"location":"api/midgard-dev/#cprofilestart","text":"Full name: midgard.dev.profiler.start Signature: (self)","title":"CProfile.start()"},{"location":"api/midgard-dev/#cprofilewrite","text":"Full name: midgard.dev.profiler.write Signature: (self) Write results of profiler session to disk","title":"CProfile.write()"},{"location":"api/midgard-dev/#lineprofiler","text":"Full name: midgard.dev.profiler.LineProfiler Signature: () line_profiler is used to profile one or a few functions in detail","title":"LineProfiler"},{"location":"api/midgard-dev/#lineprofilerend","text":"Full name: midgard.dev.profiler.end Signature: (self) Stop profiler","title":"LineProfiler.end()"},{"location":"api/midgard-dev/#lineprofilerextension-notimplementedtype","text":"extension = NotImplemented","title":"LineProfiler.extension (NotImplementedType)"},{"location":"api/midgard-dev/#lineprofileroption-str","text":"option = '--line_profiler'","title":"LineProfiler.option (str)"},{"location":"api/midgard-dev/#lineprofilerpip_name-str","text":"pip_name = 'line_profiler'","title":"LineProfiler.pip_name (str)"},{"location":"api/midgard-dev/#lineprofilersetup","text":"Full name: midgard.dev.profiler.setup Signature: (self, options) Set up profiler","title":"LineProfiler.setup()"},{"location":"api/midgard-dev/#lineprofilershow","text":"Full name: midgard.dev.profiler.show Signature: (self) Show results of profiler session in console","title":"LineProfiler.show()"},{"location":"api/midgard-dev/#lineprofilerstart","text":"Full name: midgard.dev.profiler.start Signature: (self) Start profiler","title":"LineProfiler.start()"},{"location":"api/midgard-dev/#lineprofilerwrite","text":"Full name: midgard.dev.profiler.write Signature: (self) Write results of profiler session to disk","title":"LineProfiler.write()"},{"location":"api/midgard-dev/#profiler","text":"Full name: midgard.dev.profiler.Profiler Signature: () Base class for profilers","title":"Profiler"},{"location":"api/midgard-dev/#profilerend","text":"Full name: midgard.dev.profiler.end Signature: (self) Stop profiler","title":"Profiler.end()"},{"location":"api/midgard-dev/#profilerextension-notimplementedtype","text":"extension = NotImplemented","title":"Profiler.extension (NotImplementedType)"},{"location":"api/midgard-dev/#profileroption-notimplementedtype","text":"option = NotImplemented","title":"Profiler.option (NotImplementedType)"},{"location":"api/midgard-dev/#profilerpip_name-notimplementedtype","text":"pip_name = NotImplemented","title":"Profiler.pip_name (NotImplementedType)"},{"location":"api/midgard-dev/#profilersetup","text":"Full name: midgard.dev.profiler.setup Signature: (self, options) Set up profiler","title":"Profiler.setup()"},{"location":"api/midgard-dev/#profilershow","text":"Full name: midgard.dev.profiler.show Signature: (self) Show results of profiler session in console","title":"Profiler.show()"},{"location":"api/midgard-dev/#profilerstart","text":"Full name: midgard.dev.profiler.start Signature: (self) Start profiler","title":"Profiler.start()"},{"location":"api/midgard-dev/#profilerwrite","text":"Full name: midgard.dev.profiler.write Signature: (self) Write results of profiler session to disk","title":"Profiler.write()"},{"location":"api/midgard-dev/#midgarddevtimer","text":"Class for timing the running time of functions and code blocks Description: The dev.timer can be used to log the running time of functions and general code blocks. Typically, you will import the Timer -class from within the module: from midgard.dev.timer import Timer The Timer can then be used in three different ways: As a decorator to time one function: @Timer('The time to execute some_function was') def some_function(some_argument, some_other_argument=some_value): pass As a context manager together with with to time a code block: with Timer('Finish doing stuff in', logger=logger.debug) as t: do_something() do_something_else() With explicit start - and end -statements: t = Timer() t.start() do_something() do_something_else() t.end() As can be seen in the examples above, Timer() may be called with several optional parameters, including the text to report when the timer ends and which logger is used to report the timing. See Timer.__init__ for more details.","title":"midgard.dev.timer"},{"location":"api/midgard-dev/#accumulatedtimer","text":"Full name: midgard.dev.timer.AccumulatedTimer Signature: (text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=functools.partial(<function log at 0x7f15061d2ea0>, level='info')) -> None","title":"AccumulatedTimer"},{"location":"api/midgard-dev/#accumulatedtimerelapsed","text":"Full name: midgard.dev.timer.elapsed Signature: (self) -> float Log the time elapsed Can be used explicitly to log the time since a timer started without ending the timer. Returns: The time elapsed in seconds.","title":"AccumulatedTimer.elapsed()"},{"location":"api/midgard-dev/#accumulatedtimerend","text":"Full name: midgard.dev.timer.end Signature: (self) -> float End the timer and log the time elapsed Returns: The time elapsed in seconds.","title":"AccumulatedTimer.end()"},{"location":"api/midgard-dev/#accumulatedtimerpause","text":"Full name: midgard.dev.timer.pause Signature: (self) -> float Pause the timer without logging. Use .start() to restart the timer","title":"AccumulatedTimer.pause()"},{"location":"api/midgard-dev/#accumulatedtimerreset","text":"Full name: midgard.dev.timer.reset Signature: (self) -> None Reset the timer back to 0","title":"AccumulatedTimer.reset()"},{"location":"api/midgard-dev/#accumulatedtimerstart","text":"Full name: midgard.dev.timer.start Signature: (self) -> None Start the timer","title":"AccumulatedTimer.start()"},{"location":"api/midgard-dev/#accumulatedtimertimer","text":"Full name: midgard.dev.timer.timer Signature: () -> float Get current value of timer Using the built-in time.perf_counter to do the timing. Returns: Current value of timer.","title":"AccumulatedTimer.timer()"},{"location":"api/midgard-dev/#timer","text":"Full name: midgard.dev.timer.Timer Signature: (text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=functools.partial(<function log at 0x7f15061d2ea0>, level='info')) -> None Class for timing running time of functions and code blocks.","title":"Timer"},{"location":"api/midgard-dev/#timerelapsed","text":"Full name: midgard.dev.timer.elapsed Signature: (self) -> float Log the time elapsed Can be used explicitly to log the time since a timer started without ending the timer. Returns: The time elapsed in seconds.","title":"Timer.elapsed()"},{"location":"api/midgard-dev/#timerend","text":"Full name: midgard.dev.timer.end Signature: (self) -> float End the timer and log the time elapsed Returns: The time elapsed in seconds.","title":"Timer.end()"},{"location":"api/midgard-dev/#timerpause","text":"Full name: midgard.dev.timer.pause Signature: (self) -> float Pause the timer without logging. Use .start() to restart the timer","title":"Timer.pause()"},{"location":"api/midgard-dev/#timerstart","text":"Full name: midgard.dev.timer.start Signature: (self) -> None Start the timer","title":"Timer.start()"},{"location":"api/midgard-dev/#timertimer","text":"Full name: midgard.dev.timer.timer Signature: () -> float Get current value of timer Using the built-in time.perf_counter to do the timing. Returns: Current value of timer.","title":"Timer.timer()"},{"location":"api/midgard-files/","text":"midgard.files midgard.files.dates Convenience functions for working with dates Description: Formats and converters that can be used for convenience and consistency. FMT_date (str) FMT_date = '%Y-%m-%d' FMT_datetime (str) FMT_datetime = '%Y-%m-%d %H:%M:%S' FMT_dt_file (str) FMT_dt_file = '%Y%m%d-%H%M%S' date_vars () Full name: midgard.files.dates.date_vars Signature: (date:Union[datetime.date, NoneType]) -> Dict[str, str] Construct a dict of date variables From a given date, construct a dict containing all relevant date variables. This dict can be used to for instance replace variables in file names. Examples: >>> from datetime import date >>> date_vars(date(2009, 11, 2)) # doctest: +NORMALIZE_WHITESPACE {'yyyy': '2009', 'ce': '20', 'yy': '09', 'm': '11', 'mm': '11', 'mmm': 'nov', 'MMM': 'NOV', 'd': '2', 'dd': '02', 'doy': '306', 'dow': '1', 'h': '0', 'hh': '00'} >>> date_vars(None) {} Args: date : The given date. Returns: Dictionary with date variables for the given date. midgard.files.dependencies Midgard library module for handling dependencies Description: Stores a list of files with a hash/checksum or a timestamp that can be used to detect if a file changes. Two strategies are available: Timestamps: Fast, but not always reliable as timestamps may update without the file actually changing. md5 hash/checksum: Slower, since it needs to read through the whole file, but will reliably only trigger when a file has changed. add () Full name: midgard.files.dependencies.add Signature: (*file_paths:Union[str, pathlib.Path], label:str='') -> None Add a list of files to the list of dependencies Records the current time stamp or md5 hash of the files specified by file paths, and stores as dependencies on the dependency file. Before adding dependencies, a call to init() has to be done, to set up where to store the dependencies. Args: file_paths : List of file paths to add to the dependency file. label : Optional label for dependencies. changed () Full name: midgard.files.dependencies.changed Signature: (file_path:Union[str, pathlib.Path], fast_check:bool=True) -> bool Check if the dependencies have changed Returns True if any of the files listed in the dependency file have changed, or if the dependency file itself does not exist. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums. Returns: True if any file has changed or if the dependecy file does not exist, False otherwise. get_md5 () Full name: midgard.files.dependencies.get_md5 Signature: (file_path:Union[str, pathlib.Path]) -> str Return a md5 checksum based on a file. Args: file_path : Path to file. Returns: Hex-string representing the contents of the file. get_paths_with_label () Full name: midgard.files.dependencies.get_paths_with_label Signature: (file_path:Union[str, pathlib.Path], label_pattern:str) -> List[pathlib.Path] Find all paths with the given label Args: file_path : Path to dependency file. label_pattern : String with label or regular expression (e.g. 'gnss_rinex_nav_[MGE]' or 'gnss_rinex_nav_.'). Returns: List : List of file paths. get_timestamp () Full name: midgard.files.dependencies.get_timestamp Signature: (file_path:Union[str, pathlib.Path]) -> str Return a textual timestamp from the modification date of a file Args: file_path : Path to file. Returns: String representing the modification date of the file. init () Full name: midgard.files.dependencies.init Signature: (file_path:Union[str, pathlib.Path], fast_check:bool=True) -> None Start a clean list of dependencies The file_path is to the file in which dependencies are stored. This is cached, so after init() is run, the other functions do not need to specify the file_path. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums. write () Full name: midgard.files.dependencies.write Signature: () -> None Write dependencies to file midgard.files.files Utilities for working with files move () Full name: midgard.files.files.move Signature: (from_path:Union[str, pathlib.Path], to_path:Union[str, pathlib.Path], overwrite:bool=True) -> None Move a file to another path With overwrite set to True, to_path may already exist and will be overwritten without warning. Setting overwrite to False will raise a FileExistsError if to_path already exists. Args: from_path : Path of file to be moved. to_path : Path file will be moved to. overwrite : If True, to_path may already exist. If False, to_path will never be overwritten. open () Full name: midgard.files.files.open Signature: (file_path:Union[str, pathlib.Path], create_dirs:bool=False, open_as_gzip:Union[bool, NoneType]=None, **open_args:Any) -> Iterator Open a file. Can automatically create the necessary directories before writing to a file, as well as handle gzipped files. With open_as_gzip set to None (default), it will try to detect whether the path is a .gz file simply by looking at the path suffix. For more control, you can set the parameter to True or False explicitly. Args: file_path : String or pathlib.Path representing the full file path. create_dirs : True or False, if True missing directories are created. open_as_gzip : Use gzip library to open file. open_args : All keyword arguments are passed on to the built-in open. Returns: File object representing the file. midgard.files.url Midgard library module, defining a URL class that mirrors Pathlib.Path Warning: There are many intricacies of URLs that are not handled by this class at the moment. URL Full name: midgard.files.url.URL Signature: () Simple wrapper around String to have URLs work similar to pathlib.Path URL. download_to () Full name: midgard.files.url.download_to Signature: (self, path:Union[str, pathlib.Path]) -> None Download the URL to path Args: path : Path to save the URL. URL. exists () Full name: midgard.files.url.exists Signature: (self) -> bool Check whether the given URL returns a valid document Try to download the first byte of the document (avoid downloading a big file if it exists). Warning: Because of network latency, this will be a slow operation. Return: True if URL leads to a valid document, False otherwise. URL. with_name () Full name: midgard.files.url.with_name Signature: (self, name:str) -> 'URL' Replace part of URL after the last / with a new name Args: name : New name. Return: URL with part after the last / replaced with the new name.","title":"midgard.files"},{"location":"api/midgard-files/#midgardfiles","text":"","title":"midgard.files"},{"location":"api/midgard-files/#midgardfilesdates","text":"Convenience functions for working with dates Description: Formats and converters that can be used for convenience and consistency.","title":"midgard.files.dates"},{"location":"api/midgard-files/#fmt_date-str","text":"FMT_date = '%Y-%m-%d'","title":"FMT_date (str)"},{"location":"api/midgard-files/#fmt_datetime-str","text":"FMT_datetime = '%Y-%m-%d %H:%M:%S'","title":"FMT_datetime (str)"},{"location":"api/midgard-files/#fmt_dt_file-str","text":"FMT_dt_file = '%Y%m%d-%H%M%S'","title":"FMT_dt_file (str)"},{"location":"api/midgard-files/#date_vars","text":"Full name: midgard.files.dates.date_vars Signature: (date:Union[datetime.date, NoneType]) -> Dict[str, str] Construct a dict of date variables From a given date, construct a dict containing all relevant date variables. This dict can be used to for instance replace variables in file names. Examples: >>> from datetime import date >>> date_vars(date(2009, 11, 2)) # doctest: +NORMALIZE_WHITESPACE {'yyyy': '2009', 'ce': '20', 'yy': '09', 'm': '11', 'mm': '11', 'mmm': 'nov', 'MMM': 'NOV', 'd': '2', 'dd': '02', 'doy': '306', 'dow': '1', 'h': '0', 'hh': '00'} >>> date_vars(None) {} Args: date : The given date. Returns: Dictionary with date variables for the given date.","title":"date_vars()"},{"location":"api/midgard-files/#midgardfilesdependencies","text":"Midgard library module for handling dependencies Description: Stores a list of files with a hash/checksum or a timestamp that can be used to detect if a file changes. Two strategies are available: Timestamps: Fast, but not always reliable as timestamps may update without the file actually changing. md5 hash/checksum: Slower, since it needs to read through the whole file, but will reliably only trigger when a file has changed.","title":"midgard.files.dependencies"},{"location":"api/midgard-files/#add","text":"Full name: midgard.files.dependencies.add Signature: (*file_paths:Union[str, pathlib.Path], label:str='') -> None Add a list of files to the list of dependencies Records the current time stamp or md5 hash of the files specified by file paths, and stores as dependencies on the dependency file. Before adding dependencies, a call to init() has to be done, to set up where to store the dependencies. Args: file_paths : List of file paths to add to the dependency file. label : Optional label for dependencies.","title":"add()"},{"location":"api/midgard-files/#changed","text":"Full name: midgard.files.dependencies.changed Signature: (file_path:Union[str, pathlib.Path], fast_check:bool=True) -> bool Check if the dependencies have changed Returns True if any of the files listed in the dependency file have changed, or if the dependency file itself does not exist. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums. Returns: True if any file has changed or if the dependecy file does not exist, False otherwise.","title":"changed()"},{"location":"api/midgard-files/#get_md5","text":"Full name: midgard.files.dependencies.get_md5 Signature: (file_path:Union[str, pathlib.Path]) -> str Return a md5 checksum based on a file. Args: file_path : Path to file. Returns: Hex-string representing the contents of the file.","title":"get_md5()"},{"location":"api/midgard-files/#get_paths_with_label","text":"Full name: midgard.files.dependencies.get_paths_with_label Signature: (file_path:Union[str, pathlib.Path], label_pattern:str) -> List[pathlib.Path] Find all paths with the given label Args: file_path : Path to dependency file. label_pattern : String with label or regular expression (e.g. 'gnss_rinex_nav_[MGE]' or 'gnss_rinex_nav_.'). Returns: List : List of file paths.","title":"get_paths_with_label()"},{"location":"api/midgard-files/#get_timestamp","text":"Full name: midgard.files.dependencies.get_timestamp Signature: (file_path:Union[str, pathlib.Path]) -> str Return a textual timestamp from the modification date of a file Args: file_path : Path to file. Returns: String representing the modification date of the file.","title":"get_timestamp()"},{"location":"api/midgard-files/#init","text":"Full name: midgard.files.dependencies.init Signature: (file_path:Union[str, pathlib.Path], fast_check:bool=True) -> None Start a clean list of dependencies The file_path is to the file in which dependencies are stored. This is cached, so after init() is run, the other functions do not need to specify the file_path. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums.","title":"init()"},{"location":"api/midgard-files/#write","text":"Full name: midgard.files.dependencies.write Signature: () -> None Write dependencies to file","title":"write()"},{"location":"api/midgard-files/#midgardfilesfiles","text":"Utilities for working with files","title":"midgard.files.files"},{"location":"api/midgard-files/#move","text":"Full name: midgard.files.files.move Signature: (from_path:Union[str, pathlib.Path], to_path:Union[str, pathlib.Path], overwrite:bool=True) -> None Move a file to another path With overwrite set to True, to_path may already exist and will be overwritten without warning. Setting overwrite to False will raise a FileExistsError if to_path already exists. Args: from_path : Path of file to be moved. to_path : Path file will be moved to. overwrite : If True, to_path may already exist. If False, to_path will never be overwritten.","title":"move()"},{"location":"api/midgard-files/#open","text":"Full name: midgard.files.files.open Signature: (file_path:Union[str, pathlib.Path], create_dirs:bool=False, open_as_gzip:Union[bool, NoneType]=None, **open_args:Any) -> Iterator Open a file. Can automatically create the necessary directories before writing to a file, as well as handle gzipped files. With open_as_gzip set to None (default), it will try to detect whether the path is a .gz file simply by looking at the path suffix. For more control, you can set the parameter to True or False explicitly. Args: file_path : String or pathlib.Path representing the full file path. create_dirs : True or False, if True missing directories are created. open_as_gzip : Use gzip library to open file. open_args : All keyword arguments are passed on to the built-in open. Returns: File object representing the file.","title":"open()"},{"location":"api/midgard-files/#midgardfilesurl","text":"Midgard library module, defining a URL class that mirrors Pathlib.Path Warning: There are many intricacies of URLs that are not handled by this class at the moment.","title":"midgard.files.url"},{"location":"api/midgard-files/#url","text":"Full name: midgard.files.url.URL Signature: () Simple wrapper around String to have URLs work similar to pathlib.Path","title":"URL"},{"location":"api/midgard-files/#urldownload_to","text":"Full name: midgard.files.url.download_to Signature: (self, path:Union[str, pathlib.Path]) -> None Download the URL to path Args: path : Path to save the URL.","title":"URL.download_to()"},{"location":"api/midgard-files/#urlexists","text":"Full name: midgard.files.url.exists Signature: (self) -> bool Check whether the given URL returns a valid document Try to download the first byte of the document (avoid downloading a big file if it exists). Warning: Because of network latency, this will be a slow operation. Return: True if URL leads to a valid document, False otherwise.","title":"URL.exists()"},{"location":"api/midgard-files/#urlwith_name","text":"Full name: midgard.files.url.with_name Signature: (self, name:str) -> 'URL' Replace part of URL after the last / with a new name Args: name : New name. Return: URL with part after the last / replaced with the new name.","title":"URL.with_name()"},{"location":"api/midgard-gnss/","text":"midgard.gnss midgard.gnss.solution_validation Perform Chi-square test for residuals Description: Perform Chi-square test for residuals. Degrees of freedom (df) refers to the number of values that are free to vary df = number of valid satellites (nv) - number of parameters to be estimated (nx) - 1. GNSS solution validation based on the argument alpha, the level of significance (e.g. 99%), and defines the rejection level of the crossing events. Note that this is different from the false alarm rate, which instead refers to error type I MAX_GDOPS (float) MAX_GDOPS = 30.0 MIN_EL_MASK (float) MIN_EL_MASK = 10.0 SOL_MIN_VALID_SATS (float) SOL_MIN_VALID_SATS = 4.0 comp_quality_indicators () Full name: midgard.gnss.solution_validation.comp_quality_indicators Signature: (sol_vc_mat:<built-in function array>, logger:Callable=functools.partial(<function log at 0x7f15061d2ea0>, level='info')) -> Tuple[float, float, float] Compute quality indicators This function computes compute the distance root mean squared (DRMS) compute the circular error probable (CEP) compute the standard error ellipse (SEE) Args: sol_vc_mat : variance-covariance matrix of the unknown logger : to handle messages Returns: Tuple with quality indicators: (DRMS, CEP, SEE) compute_DOPS () Full name: midgard.gnss.solution_validation.compute_DOPS Signature: (az:<built-in function array>, el:<built-in function array>, logger:Callable=functools.partial(<function log at 0x7f15061d2ea0>, level='info')) -> Tuple[float, float, float, float] Compute DOP (dilution of precision) In case of error, dop[0]-dop[3] are set to 0 and a warning is raised. Args: az : Satellite azimuth angles (radians). el : Satellite elevation angles (radians). logger : Logger to handle messages. Returns: Tuple with DOP values: (GDOP, PDOP, HDOP, VDOP) . sol_validation () Full name: midgard.gnss.solution_validation.sol_validation Signature: (residuals, alpha_siglev, n_params, az, el, logger=functools.partial(<function log at 0x7f15061d2ea0>, level='info')) -> bool Validate a GNSS solution Validating the GNSS solution is carried out by performing the following tasks: Chi-square test as outlier detection and rejections compute DOPS values compute the standard error ellipse compute the distance root mean squred (DRMS) <- TODO compute the circular error probable (CEP) <- TODO implementation of internal reliability implementation of external reliability Args: residuals : Postfit residuals alpha_siglev : Alpha significance level n_val_sats : Number of valid satellites n_params : Number of parameters (states) az : Array containing the azimuth values el : Array containing the elevation values logger : To handle messages Returns: True if solution is validated, False otherwise.","title":"midgard.gnss"},{"location":"api/midgard-gnss/#midgardgnss","text":"","title":"midgard.gnss"},{"location":"api/midgard-gnss/#midgardgnsssolution_validation","text":"Perform Chi-square test for residuals Description: Perform Chi-square test for residuals. Degrees of freedom (df) refers to the number of values that are free to vary df = number of valid satellites (nv) - number of parameters to be estimated (nx) - 1. GNSS solution validation based on the argument alpha, the level of significance (e.g. 99%), and defines the rejection level of the crossing events. Note that this is different from the false alarm rate, which instead refers to error type I","title":"midgard.gnss.solution_validation"},{"location":"api/midgard-gnss/#max_gdops-float","text":"MAX_GDOPS = 30.0","title":"MAX_GDOPS (float)"},{"location":"api/midgard-gnss/#min_el_mask-float","text":"MIN_EL_MASK = 10.0","title":"MIN_EL_MASK (float)"},{"location":"api/midgard-gnss/#sol_min_valid_sats-float","text":"SOL_MIN_VALID_SATS = 4.0","title":"SOL_MIN_VALID_SATS (float)"},{"location":"api/midgard-gnss/#comp_quality_indicators","text":"Full name: midgard.gnss.solution_validation.comp_quality_indicators Signature: (sol_vc_mat:<built-in function array>, logger:Callable=functools.partial(<function log at 0x7f15061d2ea0>, level='info')) -> Tuple[float, float, float] Compute quality indicators This function computes compute the distance root mean squared (DRMS) compute the circular error probable (CEP) compute the standard error ellipse (SEE) Args: sol_vc_mat : variance-covariance matrix of the unknown logger : to handle messages Returns: Tuple with quality indicators: (DRMS, CEP, SEE)","title":"comp_quality_indicators()"},{"location":"api/midgard-gnss/#compute_dops","text":"Full name: midgard.gnss.solution_validation.compute_DOPS Signature: (az:<built-in function array>, el:<built-in function array>, logger:Callable=functools.partial(<function log at 0x7f15061d2ea0>, level='info')) -> Tuple[float, float, float, float] Compute DOP (dilution of precision) In case of error, dop[0]-dop[3] are set to 0 and a warning is raised. Args: az : Satellite azimuth angles (radians). el : Satellite elevation angles (radians). logger : Logger to handle messages. Returns: Tuple with DOP values: (GDOP, PDOP, HDOP, VDOP) .","title":"compute_DOPS()"},{"location":"api/midgard-gnss/#sol_validation","text":"Full name: midgard.gnss.solution_validation.sol_validation Signature: (residuals, alpha_siglev, n_params, az, el, logger=functools.partial(<function log at 0x7f15061d2ea0>, level='info')) -> bool Validate a GNSS solution Validating the GNSS solution is carried out by performing the following tasks: Chi-square test as outlier detection and rejections compute DOPS values compute the standard error ellipse compute the distance root mean squred (DRMS) <- TODO compute the circular error probable (CEP) <- TODO implementation of internal reliability implementation of external reliability Args: residuals : Postfit residuals alpha_siglev : Alpha significance level n_val_sats : Number of valid satellites n_params : Number of parameters (states) az : Array containing the azimuth values el : Array containing the elevation values logger : To handle messages Returns: True if solution is validated, False otherwise.","title":"sol_validation()"},{"location":"api/midgard-ionosphere/","text":"midgard.ionosphere midgard.ionosphere.klobuchar Klobuchar model for computing the ionospheric time-delay correction. Description: Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model). GPS and Beidu satellite navigation systems use this model. The implementation is based on original paper of Klobuchar (1987). The Klobuchar model is also described in Figure 20-4 in IS-GPS-200J. References: IS-GPS-200J (2018): \"Global positioning systems directorate systems engineering & integration interface specification IS-GPS-200, Navstar GPS space Segment/Navigation user segment interfaces, 25. April 2018 Klobuchar, J.A. (1987): \"Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users\", IEEE Transactions on Aerospace and Electronic Systems, Vol. AES-23, No. 3, May 1987, https://scinapse.io/papers/2058160370 Sanz Subirana, J., Juan Zornoza, J.M. and Hernandez-Pajares, M. (2013): \"GNSS data processing - Volume I: Fundamentals and Algorithms\", TM-23/1, European Space Agency, May 2013 klobuchar () Full name: midgard.ionosphere.klobuchar.klobuchar Signature: (time, ion_coeffs, rec_pos, az, el, freq_l1, freq=None, logger=functools.partial(<function log at 0x7f15061d2ea0>, level='info')) Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model) GPS and BeiDou satellite navigation systems use this model. The implementation is based on original paper of Klobuchar, J.A. Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users https://scinapse.io/papers/2058160370 Args: time : GPST ion_coeffs : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector rec_pos : receiver position {lat,lon,h} [rad, rad, m] as vector az : azimuth angle [rad] el : elevation angle [rad] system : GNSS system freq_l1 : L1 frequency of given GNSS in [Hz] freq : Frequency in [Hz] for which ionospheric delay should be determined. logger : Function that logs Returns: iono_delay : computed path delay for given frequency [m] L1_variance : corresponding variance [m^2] TODO: freq_L1 should be determined in klobuchar routine and argument be replaced by system. constants needed in Midgard. main () Full name: midgard.ionosphere.klobuchar.main Signature: ()","title":"midgard.ionosphere"},{"location":"api/midgard-ionosphere/#midgardionosphere","text":"","title":"midgard.ionosphere"},{"location":"api/midgard-ionosphere/#midgardionosphereklobuchar","text":"Klobuchar model for computing the ionospheric time-delay correction. Description: Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model). GPS and Beidu satellite navigation systems use this model. The implementation is based on original paper of Klobuchar (1987). The Klobuchar model is also described in Figure 20-4 in IS-GPS-200J. References: IS-GPS-200J (2018): \"Global positioning systems directorate systems engineering & integration interface specification IS-GPS-200, Navstar GPS space Segment/Navigation user segment interfaces, 25. April 2018 Klobuchar, J.A. (1987): \"Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users\", IEEE Transactions on Aerospace and Electronic Systems, Vol. AES-23, No. 3, May 1987, https://scinapse.io/papers/2058160370 Sanz Subirana, J., Juan Zornoza, J.M. and Hernandez-Pajares, M. (2013): \"GNSS data processing - Volume I: Fundamentals and Algorithms\", TM-23/1, European Space Agency, May 2013","title":"midgard.ionosphere.klobuchar"},{"location":"api/midgard-ionosphere/#klobuchar","text":"Full name: midgard.ionosphere.klobuchar.klobuchar Signature: (time, ion_coeffs, rec_pos, az, el, freq_l1, freq=None, logger=functools.partial(<function log at 0x7f15061d2ea0>, level='info')) Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model) GPS and BeiDou satellite navigation systems use this model. The implementation is based on original paper of Klobuchar, J.A. Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users https://scinapse.io/papers/2058160370 Args: time : GPST ion_coeffs : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector rec_pos : receiver position {lat,lon,h} [rad, rad, m] as vector az : azimuth angle [rad] el : elevation angle [rad] system : GNSS system freq_l1 : L1 frequency of given GNSS in [Hz] freq : Frequency in [Hz] for which ionospheric delay should be determined. logger : Function that logs Returns: iono_delay : computed path delay for given frequency [m] L1_variance : corresponding variance [m^2] TODO: freq_L1 should be determined in klobuchar routine and argument be replaced by system. constants needed in Midgard.","title":"klobuchar()"},{"location":"api/midgard-ionosphere/#main","text":"Full name: midgard.ionosphere.klobuchar.main Signature: ()","title":"main()"},{"location":"api/midgard-math/","text":"midgard.math midgard.math.constant Midgard library module defining an assortment of constants Description: This module provides constants that are used within the Midgard project. The actual constants are defined in the constants.conf file (see the file list for location). See that file for references and for adding or changing constants. The constants are stored as module variables so they can be used simply as constant.c as in the example above. Some models use particular values for constants that are different from the conventional ones. This is handled by the source parameter. For instance, the EGM 2008 gravity field is calculated with a value for GM different from the IERS Conventions value, using:: constant.get('GM', source='egm_2008') instead of simply constant.GM . Example: >>> from midgard.math.constant import Constant >>> print(f\"The speed of light is {constant.c:0.2f}\") The speed of light is 299792458.00 Todo: Rewrite as a class instead of a module, to have somewhat cleaner code (and be more consistent with things like lib.unit). Constant Full name: midgard.math.constant.Constant Signature: () -> None Constant. get () Full name: midgard.math.constant.get Signature: (self, constant:str, source:str=None) -> float Get the value of one constant Note that if you need the default value of the constant (from the default source) it is typically better to read it as a property. That is, constant.c is preferred to constant.get('c') . Args: constant : Name of the constant. source : Source from which the constant is defined. Returns: Value of constant. Constant. unit () Full name: midgard.math.constant.unit Signature: (self, constant:str) -> str Unit of constant Constant. update_from_file () Full name: midgard.math.constant.update_from_file Signature: (self, file_path) Update list of constants from file Constant. use_source () Full name: midgard.math.constant.use_source Signature: (self, source:str) -> None Context manager for handling different sources Example: >>> constant.GM 398600441800000.0 >>> with constant.use_source(\"de430\"): ... print(constant.GM) ... 398600435436000.0 Args: source : Name of source of constant. constant (Constant) constant = Constant('/home/kirann/anaconda3/lib/python3.6/site-packages/midgard/math/constant.txt') midgard.math.ellipsoid Midgard library module for handling Earth ellipsoids Description: Ellipsoid Full name: midgard.math.ellipsoid.Ellipsoid Signature: (name:str, a:float, f_inv:float, description:str) -> None Ellipsoid(name:str, a:float, f_inv:float, description:str) GRS80 (Ellipsoid) GRS80 = Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS') IERS2003 (Ellipsoid) IERS2003 = Ellipsoid(name='IERS2003', a=6378136.6, f_inv=298.25642, description='IERS conventions 2003, p. 12') IERS2010 (Ellipsoid) IERS2010 = Ellipsoid(name='IERS2010', a=6378136.6, f_inv=298.25642, description='IERS conventions 2010, p. 18') WGS72 (Ellipsoid) WGS72 = Ellipsoid(name='WGS72', a=6378135, f_inv=298.26, description='WGS72') WGS84 (Ellipsoid) WGS84 = Ellipsoid(name='WGS84', a=6378137, f_inv=298.257223563, description='Used by GPS') get () Full name: midgard.math.ellipsoid.get Signature: (ellipsoid:str) -> 'Ellipsoid' Get an ellipsoid by name sphere (Ellipsoid) sphere = Ellipsoid(name='sphere', a=6371008.8, f_inv=inf, description='Regular sphere, mean radius') midgard.math.interpolation Methods for interpolating in numpy arrays Description: Different interpolation methods are decorated with @register_interpolator and will then become available for use as kind in interpolate and moving_window . Example: >>> import numpy as np >>> np.set_printoptions(precision=3, suppress=True) >>> x = np.linspace(-1, 1, 11) >>> y = x**3 - x >>> y array([ 0. , 0.288, 0.384, 0.336, 0.192, 0. , -0.192, -0.336, -0.384, -0.288, 0. ]) >>> x_new = np.linspace(-0.8, 0.8, 11) >>> interpolate(x, y, x_new, kind='cubic') array([ 0.288, 0.378, 0.369, 0.287, 0.156, -0. , -0.156, -0.287, -0.369, -0.378, -0.288]) Developer info: To add your own interpolators, you can simply decorate your interpolator functions with @register_interpolator . Your interpolator function should have the signature (x: np.ndarray, y: np.ndarray) -> Callable For instance, the following would implement a terrible interpolation function that sets all values to zero: from midgard.math.interpolation import register_interpolator @register_interpolator def zero(x: np.ndarray, y: np.ndarray) -> Callable: def _zero(x_new: np.ndarray) -> np.ndarray: return np.zeros(y.shape) return _zero This function would then be available as an interpolator. For instance, one could do >>> interpolate(x, y, x_new, kind='zero') # doctest: +SKIP array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) barycentric_interpolator () Full name: midgard.math.interpolation.barycentric_interpolator Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable The interpolating polynomial through the given points Uses the scipy.interpolate.BarycentricInterpolator function behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Barycentric interpolation function cubic () Full name: midgard.math.interpolation.cubic Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable Cubic spline interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='cubic' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Cubic spline interpolation function get_interpolator () Full name: midgard.math.interpolation.get_interpolator Signature: (name:str) -> Callable Return an interpolation function Interpolation functions are registered by the @register_interpolator-decorator. The name-parameter corresponds to the function name of the interpolator. Args: name : Name of interpolator. Returns: Interpolation function with the given name. interpolate () Full name: midgard.math.interpolation.interpolate Signature: (x:numpy.ndarray, y:numpy.ndarray, x_new:numpy.ndarray, *, kind:str, **ipargs:Any) -> numpy.ndarray Interpolate values from one x-array to another See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. ipargs : Keyword arguments passed on to the interpolator. Returns: Array of interpolated y-values. interpolate_with_derivative () Full name: midgard.math.interpolation.interpolate_with_derivative Signature: (x:numpy.ndarray, y:numpy.ndarray, x_new:numpy.ndarray, *, kind:str, dx:float=0.5, **ipargs:Any) -> numpy.ndarray Interpolate values from one x-array to another as well as find derivatives See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. dx : Values at x \u00b1 dx are used to determine derivative. ipargs : Keyword arguments passed on to the interpolator. Returns: Tuple with array of interpolated y-values and array of derivatives. interpolated_univariate_spline () Full name: midgard.math.interpolation.interpolated_univariate_spline Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable One-dimensional interpolating spline for the given points Uses the scipy.interpolate.InterpolatedUnivariateSpline function behind the scenes. The original only deals with one-dimensional y arrays, so multiple calls are made for higher dimensional y arrays. The dimensions are handled independently of each other. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Interpolating spline function interpolators () Full name: midgard.math.interpolation.interpolators Signature: () -> List[str] Return a list of available interpolators Returns: Names of available interpolators. lagrange () Full name: midgard.math.interpolation.lagrange Signature: (x:numpy.ndarray, y:numpy.ndarray, *, window:int=10, bounds_error:bool=True, assume_sorted:bool=False) -> Callable Computes the lagrange polynomial passing through a certain set of points See https://en.wikipedia.org/wiki/Lagrange_polynomial Uses window of the original points to calculate the Lagrange polynomials. The window of points is chosen by finding the closest original point and essentially picking the window // 2 indices on either side. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. window : Number of points used in interpolation. bounds_error : If True, a ValueError is raised if extrapolation is attempted. assume_sorted : If True, x must be an array of monotonically increasing values. Returns: Lagrange interpolation function. linear () Full name: midgard.math.interpolation.linear Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable Linear interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='linear' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Linear interpolation function register_interpolator () Full name: midgard.math.interpolation.register_interpolator Signature: (func:Callable) -> Callable Register an interpolation function This function should be used as a @register_interpolator-decorator Args: func : Function that will be registered as an interpolator. Returns: Same function. midgard.math.rotation Library for basic rotation matrices Description: Creates rotation matrices for rotation around the axes of a right handed Cartesian coordinate system and their derivatives. For instance, for an XYZ-system, R1 returns a rotation matrix around the x-axis and for an ENU-system, R1 returns a rotation matrix around the east-axis. dR1 returns the derivative of the R1 matrix with respect to the rotation angle. All functions are vectorized, so that one rotation matrix is returned per input angle. Example: from where.lib import rotation rotation.R1([0, 1]) array([[[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , -0. , 1. ]], [[ 1. , 0. , 0. ], [ 0. , 0.54030231, 0.84147098], [ 0. , -0.84147098, 0.54030231]]]) R1 () Full name: midgard.math.rotation.R1 Signature: (angle:~np_float) -> numpy.ndarray Rotation matrix around the first axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. R2 () Full name: midgard.math.rotation.R2 Signature: (angle:~np_float) -> numpy.ndarray Rotation matrix around the second axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. R3 () Full name: midgard.math.rotation.R3 Signature: (angle:~np_float) -> numpy.ndarray Rotation matrix around the third axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. dR1 () Full name: midgard.math.rotation.dR1 Signature: (angle:~np_float) -> numpy.ndarray Derivative of a rotation matrix around the first axis with respect to the rotation angle. Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. dR2 () Full name: midgard.math.rotation.dR2 Signature: (angle:~np_float) -> numpy.ndarray Derivative of a rotation matrix around the second axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. dR3 () Full name: midgard.math.rotation.dR3 Signature: (angle:~np_float) -> numpy.ndarray Derivative of a rotation matrix around the third axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. enu2trs () Full name: midgard.math.rotation.enu2trs Signature: (lat:~np_float, lon:~np_float) -> numpy.ndarray Rotation matrix for rotating an ENU coordinate system to an earth oriented one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R3(-(np.pi/2 + lon)) @ R1(-(np.pi/2 - lat)) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices. trs2enu () Full name: midgard.math.rotation.trs2enu Signature: (lat:~np_float, lon:~np_float) -> numpy.ndarray Rotation matrix for rotating an earth oriented coordinate system to an ENU one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R1(np.pi/2 - lat) @ R3(np.pi/2 + lon) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices. midgard.math.transformation Midgard library module for handling of geodetic conversions Description: Ellipsoid Full name: midgard.math.transformation.Ellipsoid Signature: (name, a, f) Ellipsoid(name, a, f) GRS80 (Ellipsoid) GRS80 = Ellipsoid(name='GRS80', a=6378137, f=0.003352810681182319) WGS72 (Ellipsoid) WGS72 = Ellipsoid(name='WGS72', a=6378135, f=0.003352779454167505) WGS84 (Ellipsoid) WGS84 = Ellipsoid(name='WGS84', a=6378137, f=0.0033528106647474805) llh2trs () Full name: midgard.math.transformation.llh2trs Signature: (llh:numpy.ndarray, ellipsoid:midgard.math.ellipsoid.Ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS')) -> numpy.ndarray Convert geodetic latitude-, longitude-, height-coordinates to geocentric xyz-coordinates Ref: Datums and Map projections, Jonathan Iliffe and Roger Lott, section 2.2.4 trs2llh () Full name: midgard.math.transformation.trs2llh Signature: (trs:numpy.ndarray, ellipsoid:midgard.math.ellipsoid.Ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS')) -> numpy.ndarray Convert geocentric xyz-coordinates to geodetic latitude-, longitude-, height-coordinates Ref: Datums and Map projections, Jonathan Iliffe and Roger Lott, section 2.2.4 midgard.math.unit Midgard library module for handling of SI-unit conversions Description: This module provides unit conversion constants and functions. The heavy lifting is done by the pint package. The basic usage is as follows: >>> from midgard.math.unit import Unit >>> seconds_in_two_weeks = 2 * Unit.week2secs >>> seconds_in_two_weeks 1209600.0 In general Unit.spam2ham will give the multiplicative conversion scale between the units spam and ham . Through the pint package we support a lot of units. See Unit.list() or https://github.com/hgrecco/pint/blob/master/pint/default_en.txt . Another notation is also available, and might be necessary for some more complicated conversions: >>> seconds_in_two_weeks = 2 * Unit('week', 'seconds') >>> miles_per_hour_in_meters_per_second = Unit('mph', 'meters / sec') Do note that we support most normal aliases as well as singular and plural forms of the units. For instance can second be represented as s , sec , secs and seconds . Prefixes are also handled: >>> nanoseconds_in_an_hour = Unit.hour2nanosecs >>> inches_in_a_kilometer = Unit.km2inches For more complicated conversions (for instance from Celsius to Fahrenheit) one can create custom conversion functions using convert : >>> c2f = Unit.function('celsius', 'fahrenheit') >>> absolute_zero_in_fahrenheit = c2f(-273.15) For convenience, this can also be written using the attribute notation as Unit.spam_to_ham(spam_value) . Then the previous example simply becomes: >>> absolute_zero_in_fahrenheit = Unit.celsius_to_fahrenheit(-273.15) (or even easier Unit.kelvin_to_fahrenheit(0) ). Finally, we can access the unit/quantity system of pint by using the name of a unit by itself, e.g. Unit.spam . For instance: >>> distance = 42 * Unit.km >>> time = 31 * Unit('minutes') >>> speed = distance / time >>> speed.to(Unit.mph) <Quantity(50.511464659292955, 'mph')> >>> speed.to_base_units() <Quantity(22.580645161290324, 'meter / second')> However, using the full unit system adds some overhead so we should be careful in using it in heavy calculations. Note that pint has a system for defining new units and constants if necessary, http://pint.readthedocs.io/en/latest/defining.html . To use this system, add units to the unit.txt file in the current (midgard/math) directory. Unit Full name: midgard.math.unit.Unit Signature: (from_unit:str, to_unit:Union[str, NoneType]=None) -> Any Unit converter The implementation of the unit conversion is done in the _convert_units -metaclass. Unit. dms_to_rad () Full name: midgard.math.unit.dms_to_rad Signature: (degrees:~np_float, minutes:~np_float, seconds:~np_float) -> ~np_float Convert degrees, minutes and seconds to radians The sign of degrees will be used. In this case, be careful that the sign of +0 or -0 is correctly passed on. That is, degrees must be specified as a float, not an int. Args: degrees : Degrees as float (including sign) or array of floats minutes : Minutes as int/float or array of ints/floats seconds : Seconds as float or array of floats Returns: Given degrees, minutes and seconds as radians. Examples: >>> Unit.dms_to_rad(59, 54, 52.32) 1.04570587646256 >>> Unit.dms_to_rad(-12.0, 34, 56.789) -0.21960503017531938 >>> Unit.dms_to_rad(-0.0, 19, 59.974870) -0.005817642339636369 Unit. hms_to_rad () Full name: midgard.math.unit.hms_to_rad Signature: (hours:~np_float, minutes:~np_float, seconds:~np_float) -> ~np_float Convert hours, minutes and seconds to radians Args: hours : Hours as int or array of ints minutes : Minutes as int or or array of ints seconds : Seconds as float or or array of floats Returns: Given hours, minutes and seconds as radians. Examples: >>> Unit.hms_to_rad(17, 7, 17.753427) 4.482423920139868 >>> Unit.hms_to_rad(12, 0, 0.00) 3.1415926535897936 >>> Unit.hms_to_rad(-12, 34, 56.789) Traceback (most recent call last): ValueError: hours must be non-negative Unit. rad_to_dms () Full name: midgard.math.unit.rad_to_dms Signature: (radians:~np_float) -> Tuple[~np_float, ~np_float, ~np_float] Converts radians to degrees, minutes and seconds Args: radians : Angle(s) in radians Returns: Tuple with degrees, minutes, and seconds. Examples: >>> Unit.rad_to_dms(1.04570587646256) (59.0, 54.0, 52.3200000000179) >>> Unit.rad_to_dms(-0.2196050301753194) (-12.0, 34.0, 56.78900000000468) >>> Unit.rad_to_dms(-0.005817642339636369) (-0.0, 19.0, 59.974869999999925) fid (TextIOWrapper) fid = <_io.TextIOWrapper name='/home/kirann/anaconda3/lib/python3.6/site-packages/midgard/math/unit.txt' mode='r' encoding='utf-8'>","title":"midgard.math"},{"location":"api/midgard-math/#midgardmath","text":"","title":"midgard.math"},{"location":"api/midgard-math/#midgardmathconstant","text":"Midgard library module defining an assortment of constants Description: This module provides constants that are used within the Midgard project. The actual constants are defined in the constants.conf file (see the file list for location). See that file for references and for adding or changing constants. The constants are stored as module variables so they can be used simply as constant.c as in the example above. Some models use particular values for constants that are different from the conventional ones. This is handled by the source parameter. For instance, the EGM 2008 gravity field is calculated with a value for GM different from the IERS Conventions value, using:: constant.get('GM', source='egm_2008') instead of simply constant.GM . Example: >>> from midgard.math.constant import Constant >>> print(f\"The speed of light is {constant.c:0.2f}\") The speed of light is 299792458.00 Todo: Rewrite as a class instead of a module, to have somewhat cleaner code (and be more consistent with things like lib.unit).","title":"midgard.math.constant"},{"location":"api/midgard-math/#constant","text":"Full name: midgard.math.constant.Constant Signature: () -> None","title":"Constant"},{"location":"api/midgard-math/#constantget","text":"Full name: midgard.math.constant.get Signature: (self, constant:str, source:str=None) -> float Get the value of one constant Note that if you need the default value of the constant (from the default source) it is typically better to read it as a property. That is, constant.c is preferred to constant.get('c') . Args: constant : Name of the constant. source : Source from which the constant is defined. Returns: Value of constant.","title":"Constant.get()"},{"location":"api/midgard-math/#constantunit","text":"Full name: midgard.math.constant.unit Signature: (self, constant:str) -> str Unit of constant","title":"Constant.unit()"},{"location":"api/midgard-math/#constantupdate_from_file","text":"Full name: midgard.math.constant.update_from_file Signature: (self, file_path) Update list of constants from file","title":"Constant.update_from_file()"},{"location":"api/midgard-math/#constantuse_source","text":"Full name: midgard.math.constant.use_source Signature: (self, source:str) -> None Context manager for handling different sources Example: >>> constant.GM 398600441800000.0 >>> with constant.use_source(\"de430\"): ... print(constant.GM) ... 398600435436000.0 Args: source : Name of source of constant.","title":"Constant.use_source()"},{"location":"api/midgard-math/#constant-constant","text":"constant = Constant('/home/kirann/anaconda3/lib/python3.6/site-packages/midgard/math/constant.txt')","title":"constant (Constant)"},{"location":"api/midgard-math/#midgardmathellipsoid","text":"Midgard library module for handling Earth ellipsoids Description:","title":"midgard.math.ellipsoid"},{"location":"api/midgard-math/#ellipsoid","text":"Full name: midgard.math.ellipsoid.Ellipsoid Signature: (name:str, a:float, f_inv:float, description:str) -> None Ellipsoid(name:str, a:float, f_inv:float, description:str)","title":"Ellipsoid"},{"location":"api/midgard-math/#grs80-ellipsoid","text":"GRS80 = Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS')","title":"GRS80 (Ellipsoid)"},{"location":"api/midgard-math/#iers2003-ellipsoid","text":"IERS2003 = Ellipsoid(name='IERS2003', a=6378136.6, f_inv=298.25642, description='IERS conventions 2003, p. 12')","title":"IERS2003 (Ellipsoid)"},{"location":"api/midgard-math/#iers2010-ellipsoid","text":"IERS2010 = Ellipsoid(name='IERS2010', a=6378136.6, f_inv=298.25642, description='IERS conventions 2010, p. 18')","title":"IERS2010 (Ellipsoid)"},{"location":"api/midgard-math/#wgs72-ellipsoid","text":"WGS72 = Ellipsoid(name='WGS72', a=6378135, f_inv=298.26, description='WGS72')","title":"WGS72 (Ellipsoid)"},{"location":"api/midgard-math/#wgs84-ellipsoid","text":"WGS84 = Ellipsoid(name='WGS84', a=6378137, f_inv=298.257223563, description='Used by GPS')","title":"WGS84 (Ellipsoid)"},{"location":"api/midgard-math/#get","text":"Full name: midgard.math.ellipsoid.get Signature: (ellipsoid:str) -> 'Ellipsoid' Get an ellipsoid by name","title":"get()"},{"location":"api/midgard-math/#sphere-ellipsoid","text":"sphere = Ellipsoid(name='sphere', a=6371008.8, f_inv=inf, description='Regular sphere, mean radius')","title":"sphere (Ellipsoid)"},{"location":"api/midgard-math/#midgardmathinterpolation","text":"Methods for interpolating in numpy arrays Description: Different interpolation methods are decorated with @register_interpolator and will then become available for use as kind in interpolate and moving_window . Example: >>> import numpy as np >>> np.set_printoptions(precision=3, suppress=True) >>> x = np.linspace(-1, 1, 11) >>> y = x**3 - x >>> y array([ 0. , 0.288, 0.384, 0.336, 0.192, 0. , -0.192, -0.336, -0.384, -0.288, 0. ]) >>> x_new = np.linspace(-0.8, 0.8, 11) >>> interpolate(x, y, x_new, kind='cubic') array([ 0.288, 0.378, 0.369, 0.287, 0.156, -0. , -0.156, -0.287, -0.369, -0.378, -0.288]) Developer info: To add your own interpolators, you can simply decorate your interpolator functions with @register_interpolator . Your interpolator function should have the signature (x: np.ndarray, y: np.ndarray) -> Callable For instance, the following would implement a terrible interpolation function that sets all values to zero: from midgard.math.interpolation import register_interpolator @register_interpolator def zero(x: np.ndarray, y: np.ndarray) -> Callable: def _zero(x_new: np.ndarray) -> np.ndarray: return np.zeros(y.shape) return _zero This function would then be available as an interpolator. For instance, one could do >>> interpolate(x, y, x_new, kind='zero') # doctest: +SKIP array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])","title":"midgard.math.interpolation"},{"location":"api/midgard-math/#barycentric_interpolator","text":"Full name: midgard.math.interpolation.barycentric_interpolator Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable The interpolating polynomial through the given points Uses the scipy.interpolate.BarycentricInterpolator function behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Barycentric interpolation function","title":"barycentric_interpolator()"},{"location":"api/midgard-math/#cubic","text":"Full name: midgard.math.interpolation.cubic Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable Cubic spline interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='cubic' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Cubic spline interpolation function","title":"cubic()"},{"location":"api/midgard-math/#get_interpolator","text":"Full name: midgard.math.interpolation.get_interpolator Signature: (name:str) -> Callable Return an interpolation function Interpolation functions are registered by the @register_interpolator-decorator. The name-parameter corresponds to the function name of the interpolator. Args: name : Name of interpolator. Returns: Interpolation function with the given name.","title":"get_interpolator()"},{"location":"api/midgard-math/#interpolate","text":"Full name: midgard.math.interpolation.interpolate Signature: (x:numpy.ndarray, y:numpy.ndarray, x_new:numpy.ndarray, *, kind:str, **ipargs:Any) -> numpy.ndarray Interpolate values from one x-array to another See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. ipargs : Keyword arguments passed on to the interpolator. Returns: Array of interpolated y-values.","title":"interpolate()"},{"location":"api/midgard-math/#interpolate_with_derivative","text":"Full name: midgard.math.interpolation.interpolate_with_derivative Signature: (x:numpy.ndarray, y:numpy.ndarray, x_new:numpy.ndarray, *, kind:str, dx:float=0.5, **ipargs:Any) -> numpy.ndarray Interpolate values from one x-array to another as well as find derivatives See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. dx : Values at x \u00b1 dx are used to determine derivative. ipargs : Keyword arguments passed on to the interpolator. Returns: Tuple with array of interpolated y-values and array of derivatives.","title":"interpolate_with_derivative()"},{"location":"api/midgard-math/#interpolated_univariate_spline","text":"Full name: midgard.math.interpolation.interpolated_univariate_spline Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable One-dimensional interpolating spline for the given points Uses the scipy.interpolate.InterpolatedUnivariateSpline function behind the scenes. The original only deals with one-dimensional y arrays, so multiple calls are made for higher dimensional y arrays. The dimensions are handled independently of each other. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Interpolating spline function","title":"interpolated_univariate_spline()"},{"location":"api/midgard-math/#interpolators","text":"Full name: midgard.math.interpolation.interpolators Signature: () -> List[str] Return a list of available interpolators Returns: Names of available interpolators.","title":"interpolators()"},{"location":"api/midgard-math/#lagrange","text":"Full name: midgard.math.interpolation.lagrange Signature: (x:numpy.ndarray, y:numpy.ndarray, *, window:int=10, bounds_error:bool=True, assume_sorted:bool=False) -> Callable Computes the lagrange polynomial passing through a certain set of points See https://en.wikipedia.org/wiki/Lagrange_polynomial Uses window of the original points to calculate the Lagrange polynomials. The window of points is chosen by finding the closest original point and essentially picking the window // 2 indices on either side. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. window : Number of points used in interpolation. bounds_error : If True, a ValueError is raised if extrapolation is attempted. assume_sorted : If True, x must be an array of monotonically increasing values. Returns: Lagrange interpolation function.","title":"lagrange()"},{"location":"api/midgard-math/#linear","text":"Full name: midgard.math.interpolation.linear Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable Linear interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='linear' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Linear interpolation function","title":"linear()"},{"location":"api/midgard-math/#register_interpolator","text":"Full name: midgard.math.interpolation.register_interpolator Signature: (func:Callable) -> Callable Register an interpolation function This function should be used as a @register_interpolator-decorator Args: func : Function that will be registered as an interpolator. Returns: Same function.","title":"register_interpolator()"},{"location":"api/midgard-math/#midgardmathrotation","text":"Library for basic rotation matrices Description: Creates rotation matrices for rotation around the axes of a right handed Cartesian coordinate system and their derivatives. For instance, for an XYZ-system, R1 returns a rotation matrix around the x-axis and for an ENU-system, R1 returns a rotation matrix around the east-axis. dR1 returns the derivative of the R1 matrix with respect to the rotation angle. All functions are vectorized, so that one rotation matrix is returned per input angle. Example: from where.lib import rotation rotation.R1([0, 1]) array([[[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , -0. , 1. ]], [[ 1. , 0. , 0. ], [ 0. , 0.54030231, 0.84147098], [ 0. , -0.84147098, 0.54030231]]])","title":"midgard.math.rotation"},{"location":"api/midgard-math/#r1","text":"Full name: midgard.math.rotation.R1 Signature: (angle:~np_float) -> numpy.ndarray Rotation matrix around the first axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"R1()"},{"location":"api/midgard-math/#r2","text":"Full name: midgard.math.rotation.R2 Signature: (angle:~np_float) -> numpy.ndarray Rotation matrix around the second axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"R2()"},{"location":"api/midgard-math/#r3","text":"Full name: midgard.math.rotation.R3 Signature: (angle:~np_float) -> numpy.ndarray Rotation matrix around the third axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"R3()"},{"location":"api/midgard-math/#dr1","text":"Full name: midgard.math.rotation.dR1 Signature: (angle:~np_float) -> numpy.ndarray Derivative of a rotation matrix around the first axis with respect to the rotation angle. Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"dR1()"},{"location":"api/midgard-math/#dr2","text":"Full name: midgard.math.rotation.dR2 Signature: (angle:~np_float) -> numpy.ndarray Derivative of a rotation matrix around the second axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"dR2()"},{"location":"api/midgard-math/#dr3","text":"Full name: midgard.math.rotation.dR3 Signature: (angle:~np_float) -> numpy.ndarray Derivative of a rotation matrix around the third axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"dR3()"},{"location":"api/midgard-math/#enu2trs","text":"Full name: midgard.math.rotation.enu2trs Signature: (lat:~np_float, lon:~np_float) -> numpy.ndarray Rotation matrix for rotating an ENU coordinate system to an earth oriented one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R3(-(np.pi/2 + lon)) @ R1(-(np.pi/2 - lat)) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"enu2trs()"},{"location":"api/midgard-math/#trs2enu","text":"Full name: midgard.math.rotation.trs2enu Signature: (lat:~np_float, lon:~np_float) -> numpy.ndarray Rotation matrix for rotating an earth oriented coordinate system to an ENU one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R1(np.pi/2 - lat) @ R3(np.pi/2 + lon) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"trs2enu()"},{"location":"api/midgard-math/#midgardmathtransformation","text":"Midgard library module for handling of geodetic conversions Description:","title":"midgard.math.transformation"},{"location":"api/midgard-math/#ellipsoid_1","text":"Full name: midgard.math.transformation.Ellipsoid Signature: (name, a, f) Ellipsoid(name, a, f)","title":"Ellipsoid"},{"location":"api/midgard-math/#grs80-ellipsoid_1","text":"GRS80 = Ellipsoid(name='GRS80', a=6378137, f=0.003352810681182319)","title":"GRS80 (Ellipsoid)"},{"location":"api/midgard-math/#wgs72-ellipsoid_1","text":"WGS72 = Ellipsoid(name='WGS72', a=6378135, f=0.003352779454167505)","title":"WGS72 (Ellipsoid)"},{"location":"api/midgard-math/#wgs84-ellipsoid_1","text":"WGS84 = Ellipsoid(name='WGS84', a=6378137, f=0.0033528106647474805)","title":"WGS84 (Ellipsoid)"},{"location":"api/midgard-math/#llh2trs","text":"Full name: midgard.math.transformation.llh2trs Signature: (llh:numpy.ndarray, ellipsoid:midgard.math.ellipsoid.Ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS')) -> numpy.ndarray Convert geodetic latitude-, longitude-, height-coordinates to geocentric xyz-coordinates Ref: Datums and Map projections, Jonathan Iliffe and Roger Lott, section 2.2.4","title":"llh2trs()"},{"location":"api/midgard-math/#trs2llh","text":"Full name: midgard.math.transformation.trs2llh Signature: (trs:numpy.ndarray, ellipsoid:midgard.math.ellipsoid.Ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS')) -> numpy.ndarray Convert geocentric xyz-coordinates to geodetic latitude-, longitude-, height-coordinates Ref: Datums and Map projections, Jonathan Iliffe and Roger Lott, section 2.2.4","title":"trs2llh()"},{"location":"api/midgard-math/#midgardmathunit","text":"Midgard library module for handling of SI-unit conversions Description: This module provides unit conversion constants and functions. The heavy lifting is done by the pint package. The basic usage is as follows: >>> from midgard.math.unit import Unit >>> seconds_in_two_weeks = 2 * Unit.week2secs >>> seconds_in_two_weeks 1209600.0 In general Unit.spam2ham will give the multiplicative conversion scale between the units spam and ham . Through the pint package we support a lot of units. See Unit.list() or https://github.com/hgrecco/pint/blob/master/pint/default_en.txt . Another notation is also available, and might be necessary for some more complicated conversions: >>> seconds_in_two_weeks = 2 * Unit('week', 'seconds') >>> miles_per_hour_in_meters_per_second = Unit('mph', 'meters / sec') Do note that we support most normal aliases as well as singular and plural forms of the units. For instance can second be represented as s , sec , secs and seconds . Prefixes are also handled: >>> nanoseconds_in_an_hour = Unit.hour2nanosecs >>> inches_in_a_kilometer = Unit.km2inches For more complicated conversions (for instance from Celsius to Fahrenheit) one can create custom conversion functions using convert : >>> c2f = Unit.function('celsius', 'fahrenheit') >>> absolute_zero_in_fahrenheit = c2f(-273.15) For convenience, this can also be written using the attribute notation as Unit.spam_to_ham(spam_value) . Then the previous example simply becomes: >>> absolute_zero_in_fahrenheit = Unit.celsius_to_fahrenheit(-273.15) (or even easier Unit.kelvin_to_fahrenheit(0) ). Finally, we can access the unit/quantity system of pint by using the name of a unit by itself, e.g. Unit.spam . For instance: >>> distance = 42 * Unit.km >>> time = 31 * Unit('minutes') >>> speed = distance / time >>> speed.to(Unit.mph) <Quantity(50.511464659292955, 'mph')> >>> speed.to_base_units() <Quantity(22.580645161290324, 'meter / second')> However, using the full unit system adds some overhead so we should be careful in using it in heavy calculations. Note that pint has a system for defining new units and constants if necessary, http://pint.readthedocs.io/en/latest/defining.html . To use this system, add units to the unit.txt file in the current (midgard/math) directory.","title":"midgard.math.unit"},{"location":"api/midgard-math/#unit","text":"Full name: midgard.math.unit.Unit Signature: (from_unit:str, to_unit:Union[str, NoneType]=None) -> Any Unit converter The implementation of the unit conversion is done in the _convert_units -metaclass.","title":"Unit"},{"location":"api/midgard-math/#unitdms_to_rad","text":"Full name: midgard.math.unit.dms_to_rad Signature: (degrees:~np_float, minutes:~np_float, seconds:~np_float) -> ~np_float Convert degrees, minutes and seconds to radians The sign of degrees will be used. In this case, be careful that the sign of +0 or -0 is correctly passed on. That is, degrees must be specified as a float, not an int. Args: degrees : Degrees as float (including sign) or array of floats minutes : Minutes as int/float or array of ints/floats seconds : Seconds as float or array of floats Returns: Given degrees, minutes and seconds as radians. Examples: >>> Unit.dms_to_rad(59, 54, 52.32) 1.04570587646256 >>> Unit.dms_to_rad(-12.0, 34, 56.789) -0.21960503017531938 >>> Unit.dms_to_rad(-0.0, 19, 59.974870) -0.005817642339636369","title":"Unit.dms_to_rad()"},{"location":"api/midgard-math/#unithms_to_rad","text":"Full name: midgard.math.unit.hms_to_rad Signature: (hours:~np_float, minutes:~np_float, seconds:~np_float) -> ~np_float Convert hours, minutes and seconds to radians Args: hours : Hours as int or array of ints minutes : Minutes as int or or array of ints seconds : Seconds as float or or array of floats Returns: Given hours, minutes and seconds as radians. Examples: >>> Unit.hms_to_rad(17, 7, 17.753427) 4.482423920139868 >>> Unit.hms_to_rad(12, 0, 0.00) 3.1415926535897936 >>> Unit.hms_to_rad(-12, 34, 56.789) Traceback (most recent call last): ValueError: hours must be non-negative","title":"Unit.hms_to_rad()"},{"location":"api/midgard-math/#unitrad_to_dms","text":"Full name: midgard.math.unit.rad_to_dms Signature: (radians:~np_float) -> Tuple[~np_float, ~np_float, ~np_float] Converts radians to degrees, minutes and seconds Args: radians : Angle(s) in radians Returns: Tuple with degrees, minutes, and seconds. Examples: >>> Unit.rad_to_dms(1.04570587646256) (59.0, 54.0, 52.3200000000179) >>> Unit.rad_to_dms(-0.2196050301753194) (-12.0, 34.0, 56.78900000000468) >>> Unit.rad_to_dms(-0.005817642339636369) (-0.0, 19.0, 59.974869999999925)","title":"Unit.rad_to_dms()"},{"location":"api/midgard-math/#fid-textiowrapper","text":"fid = <_io.TextIOWrapper name='/home/kirann/anaconda3/lib/python3.6/site-packages/midgard/math/unit.txt' mode='r' encoding='utf-8'>","title":"fid (TextIOWrapper)"},{"location":"api/midgard-parsers/","text":"midgard.parsers Framework for parsers Description: To add a new parser, simply create a new .py-file which defines a class inheriting from parsers.Parser. The class needs to be decorated with the midgard.dev.plugins.register decorator as follows: from midgard.parsers import parser from midgard.lib import plugins @plugins.register class MyNewParser(parser.Parser): ... To use a parser, you will typically use the parse_file -function defined below from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() The name used in parse_file to call the parser is the name of the module (file) containing the parser. names () Full name: midgard.parsers.names Signature: () -> List[str] List the names of the available parsers Returns: Names of the available parsers parse_file () Full name: midgard.parsers.parse_file Signature: (parser_name:str, file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, timer_logger:Union[Callable[[str], NoneType], NoneType]=None, use_cache:bool=False, **parser_args:Any) -> midgard.parsers._parser.Parser Use the given parser on a file and return parsed data Specify parser_name and file_path to the file that should be parsed. The following parsers are available: {doc_parser_names} Data can be retrieved either as Dictionaries, Pandas DataFrames or Midgard Datasets by using one of the methods as_dict , as_dataframe or as_dataset . Example: >>> df = parse_file('rinex2_obs', 'ande3160.16o').as_dataframe() # doctest: +SKIP Args: parser_name : Name of parser file_path : Path to file that should be parsed. encoding : Encoding in file that is parsed. timer_logger : Logging function that will be used to log timing information. use_cache : Whether to use a cache to avoid parsing the same file several times. parser_args : Input arguments to the parser Returns: Parser : Parser with the parsed data midgard.parsers._parser Basic functionality for parsing datafiles, extended by individual parsers Description: This module contains functions and classes for parsing datafiles. It should typically be used by calling parsers.parse_file : Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() Parser Full name: midgard.parsers._parser.Parser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file. You should inherit from one of the specific parsers like for instance ChainParser, LineParser, SinexParser etc Attributes: file_path (Path): Path to the datafile that will be read. file_encoding (String): Encoding of the datafile. parser_name (String): Name of the parser (as needed to call parsers.parse_...). data_available (Boolean): Indicator of whether data are available. data (Dict): The (observation) data read from file. meta (Dict): Metainformation read from file. Parser. as_dataframe () Full name: midgard.parsers._parser.as_dataframe Signature: (self, index:Union[str, List[str], NoneType]=None) -> pandas.core.frame.DataFrame Return the parsed data as a Pandas DataFrame This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: index : Optional name of field to use as index. May also be a list of strings. Returns: Pandas DataFrame with the parsed data. Parser. as_dataset () Full name: midgard.parsers._parser.as_dataset Signature: (self) -> NoReturn Return the parsed data as a Midgard Dataset This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Returns: Dataset : The parsed data. Parser. as_dict () Full name: midgard.parsers._parser.as_dict Signature: (self, include_meta:bool=False) -> Dict[str, Any] Return the parsed data as a dictionary This is a basic implementation, simply returning a copy of self.data. More advanced parsers may need to reimplement this method. Args: include_meta : Whether to include meta-data in the returned dictionary (default: False). Returns: Dictionary with the parsed data. Parser. parse () Full name: midgard.parsers._parser.parse Signature: (self) -> 'Parser' Parse data This is a basic implementation that carries out the whole pipeline of reading and parsing datafiles including calculating secondary data. Subclasses should typically implement (at least) the read_data -method. Parser. postprocess_data () Full name: midgard.parsers._parser.postprocess_data Signature: (self) -> None Do simple manipulations on the data after they are read Simple manipulations of data may be performed in postprocessors after they are read. They should be kept simple so that a parser returns as true representation of the data file as possible. Advanced calculations may be done inside apriori classes or similar. To add a postprocessor, define it in its own method, and override the setup_postprocessors -method to return a list of all postprocessors. Parser. read_data () Full name: midgard.parsers._parser.read_data Signature: (self) -> None Read data from the data file Data should be read from self.file_path and stored in the dictionary self.data . A description of the data may be placed in the dictionary self.meta . If data are not available for some reason, self.data_available should be set to False. Parser. setup_parser () Full name: midgard.parsers._parser.setup_parser Signature: (self) -> Any Set up information needed for the parser Parser. setup_postprocessors () Full name: midgard.parsers._parser.setup_postprocessors Signature: (self) -> List[Callable[[], NoneType]] List postprocessors that should be called after parsing Parser. update_dataset () Full name: midgard.parsers._parser.update_dataset Signature: (self, dset:Any) -> NoReturn Update the given dataset with the parsed data This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: dset : The dataset to update with parsed data. midgard.parsers._parser_chain Basic functionality for parsing datafiles line by line Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() ChainParser Full name: midgard.parsers._parser_chain.ChainParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file with chained groups of information. You should inherit from this one, and at least specify the necessary parameters in setup_parser . ChainParser. parse_line () Full name: midgard.parsers._parser_chain.parse_line Signature: (self, line:str, cache:Dict[str, Any], parser:midgard.parsers._parser_chain.ParserDef) -> None Parse line A line is parsed by separating a line in fields. How the separation is done, is defined in the parser_def entry of the ParserDef. Args: line : Line to be parsed. cache : Store temporary data. parser : Dictionary with defined parsers with the keys 'parser_def', 'label' and 'end_marker'. ChainParser. read_data () Full name: midgard.parsers._parser_chain.read_data Signature: (self) -> None Read data from a data file and parse the contents ChainParser. setup_parser () Full name: midgard.parsers._parser_chain.setup_parser Signature: (self) -> Any Set up information needed for the parser Return an iterable of ParserDef's that describe the structure of the file that will be parsed ParserDef Full name: midgard.parsers._parser_chain.ParserDef Signature: (end_marker:Callable[[str, int, str], bool], label:Callable[[str, int], Any], parser_def:Dict[Any, Dict[str, Any]], skip_line:Union[Callable[[str], bool], NoneType]=None, end_callback:Union[Callable[[Dict[str, Any]], NoneType], NoneType]=None) A convenience class for defining the necessary fields of a parser A single parser can read and parse one group of datalines, defined through the ParserDef by specifying how to parse each line (parser_def), how to identify each line (label), how to recognize the end of the group of lines (end_marker) and finally what (if anything) should be done after all lines in a group is read (end_callback). The end_marker, label, skip_line and end_callback parameters should all be functions with the following signatures: end_marker = func(line, line_num, next_line) label = func(line, line_num) skip_line = func(line) end_callback = func(cache) The parser definition parser_def includes the parser , field , strip and delimiter entries. The parser entry points to the parser function and the field entry defines how to separate the line in fields. The separated fields are saved either in a dictionary or in a list. In the last case the line is split on whitespace by default. With the delimiter entry the default definition can be overwritten. Leading and trailing whitespace characters are removed by default before a line is parsed. This default can be overwritten by defining the characters, which should be removed with the 'strip' entry. The parser dictionary is defined like: parser_def = { <label>: {'fields': <dict or list of fields>, 'parser': <parser function>, 'delimiter': <optional delimiter for splitting line>, 'strip': <optional characters to be removed from beginning and end of line> }} Args: end_marker : A function returning True for the last line in a group. label : A function returning a label used in the parser_def. parser_def : A dict with 'parser' and 'fields' defining the parser. skip_line : A function returning True if the line should be skipped. end_callback : A function called after reading all lines in a group. midgard.parsers._parser_line Basic functionality for parsing datafiles line by line using Numpy Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() LineParser Full name: midgard.parsers._parser_line.LineParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for using numpy to parse a file line by line. You should inherit from this one, and at least specify the necessary parameters in setup_parser . LineParser. read_data () Full name: midgard.parsers._parser_line.read_data Signature: (self) -> None Read data from the data file Uses the np.genfromtxt-function to parse the file. Any necessary parameters should be set by setup_parser . Override self.structure_data if the self.data-dictionary needs to be structured in a particular way. LineParser. setup_parser () Full name: midgard.parsers._parser_line.setup_parser Signature: (self) -> Any Set up information needed for the parser This method should return a dictionary which contains all parameters needed by np.genfromtxt to do the actual parsing. LineParser. structure_data () Full name: midgard.parsers._parser_line.structure_data Signature: (self) -> None Structure raw array data into the self.data dictionary This simple implementation creates a dictionary with one item per column in the array. Override this method for more complex use cases. midgard.parsers._parser_rinex Basic functionality for parsing Rinex files Description: This module contains functions and classes for parsing Rinex files. This file defines the general structure shared by most types of Rinex files, including header information. More specific format details are implemented in subclasses. When calling the parser, you should call the apropriate parser for a given Rinex format. RinexHeader Full name: midgard.parsers._parser_rinex.RinexHeader Signature: (marker:str, fields:Dict[str, Tuple[int, int]], parser:Callable[[Dict[str, str]], Dict[str, Any]]) A convenience class for defining how a Rinex header is parsed Args: marker : Marker of header (as defined in columns 60 and onward). fields : Dictionary with field names as keys, tuple of start- and end-columns as value. parser : Function that will parse the fields. RinexParser Full name: midgard.parsers._parser_rinex.RinexParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for reading Rinex header data. You should inherit from this one, and at least implement parse_epochs . RinexParser. get_rinex_version_type () Full name: midgard.parsers._parser_rinex.get_rinex_version_type Signature: (self) -> Dict[str, str] Get version and type of Rinex file RinexParser.name (str) name = 'Rinex' RinexParser. parse_approx_position () Full name: midgard.parsers._parser_rinex.parse_approx_position Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse station coordinates defined in RINEX header to instance variable data RinexParser. parse_comment () Full name: midgard.parsers._parser_rinex.parse_comment Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse comment lines in RINEX header to instance variable header['comment'] RinexParser. parse_data_lines () Full name: midgard.parsers._parser_rinex.parse_data_lines Signature: (self, lines, epoch_info) RinexParser. parse_epoch_line () Full name: midgard.parsers._parser_rinex.parse_epoch_line Signature: (self, line) RinexParser. parse_float () Full name: midgard.parsers._parser_rinex.parse_float Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse float entries of RINEX header to instance variable header RinexParser. parse_glonass_code_phase_bias () Full name: midgard.parsers._parser_rinex.parse_glonass_code_phase_bias Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse GLONASS phase correction in RINEX header to instance variable header['glonass_bias'] self.header['glonass_bias'] = { : } RinexParser. parse_glonass_slot () Full name: midgard.parsers._parser_rinex.parse_glonass_slot Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse GLONASS slot and frequency numbers given in RINEX header to instance variable header['glonass_slot'] self.header['glonass_slot'] = { : } RinexParser. parse_integer () Full name: midgard.parsers._parser_rinex.parse_integer Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse integer entries of RINEX header to instance variable header RinexParser. parse_leap_seconds () Full name: midgard.parsers._parser_rinex.parse_leap_seconds Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header LEAP SECONDS to instance variable header self.header['leap_seconds'] = { 'leap_seconds': , 'future_past_leap_seconds': , 'week': , 'week_day': , 'time_sys': } RinexParser. parse_phase_shift () Full name: midgard.parsers._parser_rinex.parse_phase_shift Signature: (self, fields:Dict[str, str], cache:List[Dict[str, str]]) -> Dict[str, Any] Parse entries of RINEX header SYS / PHASE SHIFT to instance variable header self.header['phase_shift'] = { <sat_sys>: { <obs_type>: { corr: <correction>, sat: <[satellite list]>}}} Example of phase_shift header entry: self.header['phase_shift'] = {'G': {'L1C': {'corr': '0.00000', 'sat': ['G01', 'G02', 'G03', ...]}, 'L1W': {'corr': '0.00000', 'sat': []}}, 'R': {'L1C': {'corr': '0.00000', 'sat': ['R01', 'R02', 'R07', 'R08']}}} TODO: Maybe better to add information to header['obstypes']? RinexParser. parse_scale_factor () Full name: midgard.parsers._parser_rinex.parse_scale_factor Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header SYS / SCALE FACTOR to instance variable header RinexParser. parse_string () Full name: midgard.parsers._parser_rinex.parse_string Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse string entries of RINEX header to instance variable 'header' RinexParser. parse_sys_dcbs_applied () Full name: midgard.parsers._parser_rinex.parse_sys_dcbs_applied Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header SYS / DCBS APPLIED to instance variable header self.header['dcbs_applied'] = { : { prg: , url: }} RinexParser. parse_sys_obs_types () Full name: midgard.parsers._parser_rinex.parse_sys_obs_types Signature: (self, fields:Dict[str, str], cache:List[Dict[str, str]]) -> Dict[str, Any] Parse observation types given in RINEX header to instance variable header['obstypes'] and data The data dictionaries obs , cycle_slip and signal_strength are initialized based on the given observation type in the RINEX header. self.header['obstypes'] = { <sat_sys>: [<ordered list with given observation types>]} RinexParser. parse_sys_pcvs_applied () Full name: midgard.parsers._parser_rinex.parse_sys_pcvs_applied Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header SYS / PCVS APPLIED to instance variable header self.header['pcvs_applied'] = { : { prg: , url: }} RinexParser. parse_time_of_first_obs () Full name: midgard.parsers._parser_rinex.parse_time_of_first_obs Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse time of first observation given in RINEX header to instance variable header RinexParser. parse_time_of_last_obs () Full name: midgard.parsers._parser_rinex.parse_time_of_last_obs Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse time of last observation given in RINEX header to instance variable header RinexParser. read_data () Full name: midgard.parsers._parser_rinex.read_data Signature: (self) -> None Read data from the data file RinexParser. read_epochs () Full name: midgard.parsers._parser_rinex.read_epochs Signature: (self, fid) -> None Read data from Rinex file Add data to self.data RinexParser. read_header () Full name: midgard.parsers._parser_rinex.read_header Signature: (self, fid) -> None Read header from the rinex file Add header information to self.header RinexParser. structure_data () Full name: midgard.parsers._parser_rinex.structure_data Signature: (self) -> None Convert lists of data to numpy arrays parser_cache () Full name: midgard.parsers._parser_rinex.parser_cache Signature: (func:Callable[[_ForwardRef('RinexParser'), Dict[str, str], List[Dict[str, str]]], Dict[str, Any]]) -> Callable[[_ForwardRef('RinexParser'), Dict[str, str]], Dict[str, Any]] Decorator for adding a cache to parser functions midgard.parsers._parser_sinex Basic functionality for parsing Sinex datafiles Description: This module contains functions and classes for parsing Sinex datafiles. References: SINEX Format: https://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html SinexBlock Full name: midgard.parsers._parser_sinex.SinexBlock Signature: (marker:str, fields:Tuple[midgard.parsers._parser_sinex.SinexField, ...], parser:Callable[[<built-in function array>, Tuple[str, ...]], Dict[str, Any]]) A convenience class for defining a Sinex block Args: marker : Sinex marker denoting the block. fields : Fields in Sinex block. parser : Function used to parse the data. SinexField Full name: midgard.parsers._parser_sinex.SinexField Signature: (name:str, start_col:int, dtype:Union[str, NoneType], converter:Union[str, NoneType]=None) A convenience class for defining the fields in a Sinex block Args: name : Name of field. start_col : Starting column of field (First column is 0) dtype : String, using numpy notation, defining type of field, use None to ignore field. converter : Optional, name of converter to apply to field data. SinexParser Full name: midgard.parsers._parser_sinex.SinexParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, header:bool=True) -> None An abstract base class that has basic methods for parsing a Sinex file This class provides functionality for parsing a sinex file with chained groups of information. You should inherit from this one, and at least specify which Sinex blocks you are interested in by implementing setup_parser , as well as implement methods that parse each block if needed. SinexParser. as_dataframe () Full name: midgard.parsers._parser_sinex.as_dataframe Signature: (self, index:Union[str, List[str], NoneType]=None, marker:Union[str, NoneType]=None) -> pandas.core.frame.DataFrame Return the parsed data as a Pandas DataFrame This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: marker : Only return data from this marker in the DataFrame. index : Name of field to use as index. May also be a list of strings. Returns: Pandas DataFrame with the parsed data. SinexParser. parse_bias_epochs () Full name: midgard.parsers._parser_sinex.parse_bias_epochs Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_blocks () Full name: midgard.parsers._parser_sinex.parse_blocks Signature: (self, fid:Iterable[bytes]) -> None Parse contents of Sinex blocks Contents of Sinex blocks are stored as separate numpy-arrays in self._sinex Args: fid : Pointer to file being read. SinexParser. parse_file_comment () Full name: midgard.parsers._parser_sinex.parse_file_comment Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_file_reference () Full name: midgard.parsers._parser_sinex.parse_file_reference Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_header_line () Full name: midgard.parsers._parser_sinex.parse_header_line Signature: (self, header_line:bytes) -> None Parse header of Sinex file Header information is stored in self.meta . Args: header_line : First line of Sinex file. SinexParser. parse_input_acknowledgements () Full name: midgard.parsers._parser_sinex.parse_input_acknowledgements Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_input_files () Full name: midgard.parsers._parser_sinex.parse_input_files Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_input_history () Full name: midgard.parsers._parser_sinex.parse_input_history Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_lines () Full name: midgard.parsers._parser_sinex.parse_lines Signature: (self, lines:List[bytes], fields:Tuple[midgard.parsers._parser_sinex.SinexField, ...]) -> <built-in function array> Parse lines in a Sinex file Args: lines : Lines to parse. fields : Definition of sinex fields in lines. Returns: Data contained in lines. SinexParser. parse_nutation_data () Full name: midgard.parsers._parser_sinex.parse_nutation_data Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_precession_data () Full name: midgard.parsers._parser_sinex.parse_precession_data Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_satellite_id () Full name: midgard.parsers._parser_sinex.parse_satellite_id Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_satellite_phase_center () Full name: midgard.parsers._parser_sinex.parse_satellite_phase_center Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_site_antenna () Full name: midgard.parsers._parser_sinex.parse_site_antenna Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_site_data () Full name: midgard.parsers._parser_sinex.parse_site_data Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_site_eccentricity () Full name: midgard.parsers._parser_sinex.parse_site_eccentricity Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_site_gal_phase_center () Full name: midgard.parsers._parser_sinex.parse_site_gal_phase_center Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_site_gps_phase_center () Full name: midgard.parsers._parser_sinex.parse_site_gps_phase_center Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_site_id () Full name: midgard.parsers._parser_sinex.parse_site_id Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_site_receiver () Full name: midgard.parsers._parser_sinex.parse_site_receiver Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_solution_apriori () Full name: midgard.parsers._parser_sinex.parse_solution_apriori Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_solution_epochs () Full name: midgard.parsers._parser_sinex.parse_solution_epochs Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_solution_estimate () Full name: midgard.parsers._parser_sinex.parse_solution_estimate Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_solution_matrix_apriori () Full name: midgard.parsers._parser_sinex.parse_solution_matrix_apriori Signature: (self:'SinexParser', data:<built-in function array>, lower_upper:str, type:str='') -> Dict[str, Any] Parser for SOLUTION/MATRIX_APRIORI data Converts the input data to a symmetric matrix and adds it to self.data['SOLUTION/MATRIX_APRIORI']. The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters Index in the SOLUTION/ESTIMATE block. Missing elements in the matrix are assumed to be zero (0); consequently, zero elements may be omitted to reduce the size of this block. Args: data : Input data, raw data for SOLUTION/MATRIX_APRIORI block. lower_upper : Either 'L' or 'U', indicating whether the matrix is given in lower or upper form. type : Information about the type of matrix, optional. Returns: Dictionary with symmetric matrix as a numpy array. SinexParser. parse_solution_matrix_estimate () Full name: midgard.parsers._parser_sinex.parse_solution_matrix_estimate Signature: (self:'SinexParser', data:<built-in function array>, lower_upper:str, type:str='') -> Dict[str, Any] Parser for SOLUTION/MATRIX_ESTIMATE data Converts the input data to a symmetric matrix and adds it to self.data['SOLUTION/MATRIX_ESTIMATE']. The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters Index in the SOLUTION/ESTIMATE block. Missing elements in the matrix are assumed to be zero (0); consequently, zero elements may be omitted to reduce the size of this block. Args: data : Input data, raw data for SOLUTION/MATRIX_ESTIMATE block. lower_upper : Either 'L' or 'U', indicating whether the matrix is given in lower or upper form. type : Information about the type of matrix, optional. Returns: Dictionary with symmetric matrix as a numpy array. SinexParser. parse_solution_normal_equation_matrix () Full name: midgard.parsers._parser_sinex.parse_solution_normal_equation_matrix Signature: (self:'SinexParser', data:<built-in function array>, lower_upper:str, type:str='') -> Dict[str, Any] Parser for SOLUTION/NORMAL_EQUATION_MATRIX data Converts the input data to a symmetric matrix and adds it to self.data['SOLUTION/NORMAL_EQUATION_MATRIX']. The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters Index in the SOLUTION/ESTIMATE block. Missing elements in the matrix are assumed to be zero (0); consequently, zero elements may be omitted to reduce the size of this block. Args: data : Input data, raw data for SOLUTION/NORMAL_EQUATION_MATRIX block. lower_upper : Either 'L' or 'U', indicating whether the matrix is given in lower or upper form. type : Information about the type of matrix, optional. Returns: Dictionary with symmetric matrix as a numpy array. SinexParser. parse_solution_normal_equation_vector () Full name: midgard.parsers._parser_sinex.parse_solution_normal_equation_vector Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_solution_statistics () Full name: midgard.parsers._parser_sinex.parse_solution_statistics Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. parse_source_id () Full name: midgard.parsers._parser_sinex.parse_source_id Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser. read_data () Full name: midgard.parsers._parser_sinex.read_data Signature: (self) -> None Read data from a Sinex file and parse the contents First the whole Sinex file is read and the requested blocks are stored in self._sinex. After the file has been read, a parser is called on each block so that self.data is properly populated. SinexParser. setup_parser () Full name: midgard.parsers._parser_sinex.setup_parser Signature: (self) -> Any Set up information needed for the parser Each individual Sinex-parser should at least implement this method. If the order the blocks are parsed is not important, the information should be returned as a set for optimal performance. If the parsing order is important, a tuple of SinexBlock-objects may be returned instead. Returns: Iterable of blocks in the Sinex file that should be parsed. parsing_factory () Full name: midgard.parsers._parser_sinex.parsing_factory Signature: () -> Callable[..., Dict[str, Any]] Create a default parsing function for a Sinex block The default parsing function returns a dictionary containing all fields of the block as separated arrays. This will be stored in self.data['{marker}'] with the {marker} of the current block. Returns: Simple parsing function for one Sinex block. parsing_matrix_factory () Full name: midgard.parsers._parser_sinex.parsing_matrix_factory Signature: (marker:str, size_marker:str) -> Callable[..., Dict[str, Any]] Create a parsing function for parsing a matrix within a Sinex block The default parsing function converts data to a symmetric matrix and stores it inside self.data[marker] . The size of the matrix is set to equal the number of parameters in the size_marker -block. If that block is not parsed/found. The size is set to the last given row index. If some zero elements in the matrix are omitted this might be wrong. Args: marker : Marker of Sinex block. size_marker : Marker of a different Sinex block indicating the size of the matrix. Returns: Simple parsing function for one Sinex block. midgard.parsers.anubis A parser for reading Anubis xtr-files AnubisXtrParser Full name: midgard.parsers.anubis.AnubisXtrParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Anubis XTR files AnubisXtrParser. read_data () Full name: midgard.parsers.anubis.read_data Signature: (self) -> None Read data and store in .data dictionary midgard.parsers.bcecmp_sisre A parser for reading DLR BCEcmp Software SISRE output files Example: from midgard import parsers p = parsers.parse_file(parser_name='bcecmp_sisre', file_path='BCEcmp_GAL_FNAV_E1E5A_com_2018_032.OUT') data = p.as_dict() Description: Reads data from files in the BCEcmp Software output file format. The BCEcmp Software is developed and used by DLR. BcecmpParser Full name: midgard.parsers.bcecmp_sisre.BcecmpParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading DLR BCEcmp Software output files. The following data are available after reading BCEcmp Software output file: Key Description age_min age of ephemeris in [min] clk_diff_sys Satellite clock correction difference in [m] dalong_track Along-track orbit difference in [m] dcross_track Cross-track orbit difference in [m] dradial Radial orbit difference in [m] dradial_wul Worst-user-location (wul) SISRE? satellite Satellite PRN number together with GNSS identifier (e.g. G07) sisre Signal-in-space range error [m] time Observation time used_iodc GPS: IODC (Clock issue of data indicates changes (set equal to IODE)) QZSS: IODC used_iode Ephemeris issue of data indicates changes to the broadcast ephemeris: - GPS: Ephemeris issue of data (IODE), which is set equal to IODC - Galileo: Issue of Data of the NAV batch (IODnav) - QZSS: Ephemeris issue of data (IODE) - BeiDou: Age of Data Ephemeris (AODE) - IRNSS: Issue of Data, Ephemeris and Clock (IODEC) and meta -data: Key Description __data_path__ File path __parser_name__ Parser name BcecmpParser. setup_parser () Full name: midgard.parsers.bcecmp_sisre.setup_parser Signature: (self) -> Iterable[midgard.parsers._parser_chain.ParserDef] Parsers defined for reading BCEcmp Software output file line by line. BcecmpParser. setup_postprocessors () Full name: midgard.parsers.bcecmp_sisre.setup_postprocessors Signature: (self) -> List[Callable[[], NoneType]] List steps necessary for postprocessing midgard.parsers.galileo_constellation_html A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example GalileoConstellationHTMLParser Full name: midgard.parsers.galileo_constellation_html.GalileoConstellationHTMLParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, url:Union[str, NoneType]=None) -> None A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example GalileoConstellationHTMLParser.URL (str) URL = 'https://www.gsc-europa.eu/system-status/Constellation-Information' GalileoConstellationHTMLParser. download_html () Full name: midgard.parsers.galileo_constellation_html.download_html Signature: (self, url:Union[str, NoneType]=None) -> None Download html file from url TODO: Move this to files/url.py Args: url : URL to download from, if None use self.URL instead. GalileoConstellationHTMLParser. read_data () Full name: midgard.parsers.galileo_constellation_html.read_data Signature: (self) -> None Read tables from the HTML file The satellite table is placed in self.data, while the NAGU events are placed in self.meta[\"events\"]. GalileoConstellationHTMLParser. satellite_id () Full name: midgard.parsers.galileo_constellation_html.satellite_id Signature: (self, sat_id:str) -> Dict[str, Any] Get satellite info from satellite vehicle ID Args: sat_id : ID of satellite, for example E01. Returns: Dictionary with satellite info. GalileoConstellationHTMLParser. satellite_name () Full name: midgard.parsers.galileo_constellation_html.satellite_name Signature: (self, sat_name:str) -> Dict[str, Any] Get satellite info from name Args: sat_name : Name of satellite, for example GSAT0101. Returns: Dictionary with satellite info. midgard.parsers.gipsy_tdp A parser for reading NASA JPL Gipsy time dependent parameter (TDP) file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsy_tdp', file_path='final.tdp') data = p.as_dict() Description: Reads data from files in Gipsy time dependent parameter (TDP) format. GipsyTdpParser Full name: midgard.parsers.gipsy_tdp.GipsyTdpParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Gipsy time dependent parameter (TDP) file Following data are available after reading Gipsy TDP output file: Key Description apriori_value Nominal value. This field contains the last value used by the model. name Parameter name. sigma The sigma associated with the value of the parameter. A negative value indicates it should be used for interpolation by the file reader read_time_variation in $GOA/libsrc/time_variation. If no sigmas are computed by the smapper, a 1.0 will be placed here. time_past_j2000 Time given in GPS seconds past J2000. value Accumulated value of the parameter at time and includes any nominal, or iterative correction. This is the only entry used by the model. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name GipsyTdpParser. setup_parser () Full name: midgard.parsers.gipsy_tdp.setup_parser Signature: (self) -> Dict[str, Any] Set up information needed for the parser This should return a dictionary with all parameters needed by np.genfromtxt to do the actual parsing. TODO: Station name should be separated from parameter name. Returns: Dict : Parameters needed by np.genfromtxt to parse the input file. midgard.parsers.gnss_antex A parser for reading ANTEX format 1.4 data Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_antex', file_path='igs14.atx') data = p.as_dict() Description: Reads data from files in the GNSS Antenna Exchange (ANTEX) file format version 1.4 (see :cite: antex ). AntexParser Full name: midgard.parsers.gnss_antex.AntexParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading ANTEX file The parser reads GNSS ANTEX format 1.4 (see :cite: antex ). The 'data' attribute is a dictionary with GNSS satellite PRN or receiver antenna as key. The GNSS satellite antenna corrections are time dependent and saved with \"valid from\" datetime object entry. The dictionary looks like: dout = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}} with following entries: Value Type Description azi numpy.ndarray Array with azimuth-elevation dependent antenna correction in [mm] with the shape: number of azimuth values x number of elevation values. azimuth numpy.ndarray List with azimuth values in [rad] corresponding to antenna corrections given in azi . cospar_id str COSPAR ID : yyyy -> year when the satellite was put in orbit, xxx -> sequential satellite number for that year, a -> alpha numeric sequence number within a launch elevation numpy.ndarray List with elevation values in [rad] corresponding to antenna corrections given in azi or noazi . str Frequency identifier (e.g. G01 - GPS L1) neu list North, East and Up eccentricities in [m]. The eccentricities of the mean antenna phase center is given relative to the antenna reference point (ARP) for receiver antennas or to the center of mass of the satellite in X-, Y- and Z-direction. noazi numpy.ndarray List with elevation dependent (non-azimuth-dependent) antenna correction in [mm]. str Satellite code e.g. GPS PRN, GLONASS slot or Galileo SVID number str Receiver antenna name together with radome code sat_code str Satellite code e.g. GPS SVN, GLONASS number or Galileo GSAT number sat_type str Satellite type (e.g. BLOCK IIA) valid_from datetime.datetime Start of validity period of satellite in GPS time valid_until datetime.datetime End of validity period of satellite in GPS time The 'meta' attribute is a dictionary with following entries: Value Type Description comment list Header commments given in list line by line pcv_type str Phase center variation type ref_antenna str Reference antenna type for relative antenna ref_serial_num str Serial number of the reference antenna sat_sys str Satellite system version str Format version Attributes: data : (dict), Contains the (observation) data read from file. data_available : (bool), Indicator of whether data are available. file_path : (pathlib.Path), File path. parser_name : (str), Parser name. meta : (dict), Contains metainformation read from file. AntexParser. parse_comment () Full name: midgard.parsers.gnss_antex.parse_comment Signature: (self, line:Dict[str, str], _:Dict[str, Any]) -> None Parse comment lines in ANTEX header. AntexParser. parse_correction () Full name: midgard.parsers.gnss_antex.parse_correction Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse antenna corrections entries of ANTEX antenna section. AntexParser. parse_default_meta () Full name: midgard.parsers.gnss_antex.parse_default_meta Signature: (self, line:Dict[str, str], _:Dict[str, Any]) -> None Add the contents of line to meta Args: line : Dict containing the fields of a line. AntexParser. parse_num_of_frequencies () Full name: midgard.parsers.gnss_antex.parse_num_of_frequencies Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse '# OF FREQUENCIES' entry of ANTEX antenna section. AntexParser. parse_section_float () Full name: midgard.parsers.gnss_antex.parse_section_float Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse float entries of ANTEX header. AntexParser. parse_section_string () Full name: midgard.parsers.gnss_antex.parse_section_string Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse string entries of ANTEX header. AntexParser. parse_string () Full name: midgard.parsers.gnss_antex.parse_string Signature: (self, line:Dict[str, str], _:Dict[str, Any]) -> None Parse string entries of ANTEX header. AntexParser. parse_valid_from () Full name: midgard.parsers.gnss_antex.parse_valid_from Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse 'VALID FROM' entries of ANTEX antenna section. AntexParser. parse_valid_until () Full name: midgard.parsers.gnss_antex.parse_valid_until Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse 'VALID UNTIL' entries of ANTEX antenna section. AntexParser. save_correction () Full name: midgard.parsers.gnss_antex.save_correction Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Save antenna correction in data structures. The antenna corrections are saved after reading of corrections for one frequency. Antenna correction data are saved in following data structure, whereby satellite antenna corrections are time dependent: self.data = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }} } AntexParser. setup_parser () Full name: midgard.parsers.gnss_antex.setup_parser Signature: (self) -> Iterable[midgard.parsers._parser_chain.ParserDef] Parsers defined for reading ANTEX file line by line. First the ANTEX header information are read and afterwards the ANTEX corrections. midgard.parsers.gnss_sinex_igs A parser for reading data from igs.snx file based on IGS sitelog files in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_sinex_igs', file_path='igs.snx') data = p.as_dict() Description: Reads station information (e.g. approximated station coordinates, receiver and antenna type, station eccentricities, ...) igs.snx file in SINEX format. IgsSnxParser Full name: midgard.parsers.gnss_sinex_igs.IgsSnxParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, header:bool=True) -> None A parser for reading data from igs.snx file based on IGS sitelog files in SINEX format site - Site dictionary, whereby keys are the site identifiers and values are a site entry dictionary with the keys 'site_antenna', 'site_eccentricity', 'site_id' and 'site_receiver'. The site dictionary has following strucuture: self.site[site] = { 'site_antenna': [], # SITE/ANTENNA SINEX block information 'site_eccentricity': [], # SITE/ECCENTRICITY block information 'site_id': {}, # SITE/ID block information 'site_receiver': [], # SITE/RECEIVER block information } with the site entry dictionary entries site_antenna[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'antenna_type': antenna_type, 'radome_type': radome_type, 'serial_number': serial_number } site_eccentricity[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'reference_system': reference_system, 'vector_1': vector_1, 'vector_2': vector_2, 'vector_3': vector_3, 'vector_type': UNE } site_id = { 'point_code': point_code, 'domes': domes, 'marker': marker, 'obs_code': obs_code, 'description': description, 'approx_lon': approx_lon, 'approx_lat': approx_lat, 'approx_height': approx_height } site_receiver[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'receiver_type': receiver_type, 'serial_number': serial_number, 'firmware': firmware } The counter 'ii' ranges from 0 to n and depends on how many antenna type, receiver type and antenna monument changes were done at each site. Note also, that time entries (e.g. start_time, end_time) are given in Modified Julian Date. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class. IgsSnxParser. parse_site_antenna () Full name: midgard.parsers.gnss_sinex_igs.parse_site_antenna Signature: (self, data) Parse SITE/ANTENNA SINEX block IgsSnxParser. parse_site_eccentricity () Full name: midgard.parsers.gnss_sinex_igs.parse_site_eccentricity Signature: (self, data) Parse SITE/ECCENTRICITY SINEX block IgsSnxParser. parse_site_id () Full name: midgard.parsers.gnss_sinex_igs.parse_site_id Signature: (self, data) Parse SITE/ID SINEX block IgsSnxParser. parse_site_receiver () Full name: midgard.parsers.gnss_sinex_igs.parse_site_receiver Signature: (self, data) Parse SITE/RECEIVER SINEX block IgsSnxParser. setup_parser () Full name: midgard.parsers.gnss_sinex_igs.setup_parser Signature: (self) midgard.parsers.rinex2_nav_header RINEX navigation header classes for file format version 2.xx Rinex2NavHeaderMixin Full name: midgard.parsers.rinex2_nav_header.Rinex2NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 2.xx Rinex2NavHeaderParser Full name: midgard.parsers.rinex2_nav_header.Rinex2NavHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 2.xx navigation header The data in the rinex file will not be parsed. Rinex2NavHeaderParser.name (str) name = 'Rinex' Rinex2NavHeaderParser. read_epochs () Full name: midgard.parsers.rinex2_nav_header.read_epochs Signature: (self, fid) -> None Do not read data from Rinex file Skip reading of data. midgard.parsers.rinex2_obs_header RINEX observation header classes for file format version 3.xx Rinex2ObsHeaderMixin Full name: midgard.parsers.rinex2_obs_header.Rinex2ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 2.xx Rinex2ObsHeaderParser Full name: midgard.parsers.rinex2_obs_header.Rinex2ObsHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 2.xx observation header The data in the rinex file will not be parsed. Rinex2ObsHeaderParser.name (str) name = 'Rinex' Rinex2ObsHeaderParser. read_epochs () Full name: midgard.parsers.rinex2_obs_header.read_epochs Signature: (self, fid) -> None Do not read data from Rinex file Skip reading of data. midgard.parsers.rinex3_clk A parser for reading RINEX clock files with version 3.xx Rinex3ClkParser Full name: midgard.parsers.rinex3_clk.Rinex3ClkParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX clock files with version 3.xx Rinex3ClkParser.name (str) name = 'Rinex' midgard.parsers.rinex3_clk_header RINEX clock header classes for file format version 3.xx Rinex3ClkHeaderMixin Full name: midgard.parsers.rinex3_clk_header.Rinex3ClkHeaderMixin Signature: () A mixin defining which RINEX clock headers are mandatory and optional in RINEX version 3.xx Rinex3ClkHeaderParser Full name: midgard.parsers.rinex3_clk_header.Rinex3ClkHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 3.xx clock header The data in the rinex file will not be parsed. Rinex3ClkHeaderParser.name (str) name = 'Rinex' Rinex3ClkHeaderParser. read_epochs () Full name: midgard.parsers.rinex3_clk_header.read_epochs Signature: (self, fid) -> None Do not read data from Rinex file Skip reading of data. midgard.parsers.rinex3_nav_header RINEX navigation header classes for file format version 3.xx Rinex3NavHeaderMixin Full name: midgard.parsers.rinex3_nav_header.Rinex3NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 3.xx Rinex3NavHeaderParser Full name: midgard.parsers.rinex3_nav_header.Rinex3NavHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 3.xx navigation header The data in the rinex file will not be parsed. Rinex3NavHeaderParser.name (str) name = 'Rinex' Rinex3NavHeaderParser. read_epochs () Full name: midgard.parsers.rinex3_nav_header.read_epochs Signature: (self, fid) -> None Do not read data from Rinex file Skip reading of data. midgard.parsers.rinex3_obs_header RINEX observation header classes for file format version 3.xx Rinex3ObsHeaderMixin Full name: midgard.parsers.rinex3_obs_header.Rinex3ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 3.xx Rinex3ObsHeaderParser Full name: midgard.parsers.rinex3_obs_header.Rinex3ObsHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 3.xx observation header The data in the rinex file will not be parsed. Rinex3ObsHeaderParser.name (str) name = 'Rinex' Rinex3ObsHeaderParser. read_epochs () Full name: midgard.parsers.rinex3_obs_header.read_epochs Signature: (self, fid) -> None Do not read data from Rinex file Skip reading of data. midgard.parsers.terrapos_position A parser for reading Terrapos position output file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_position', file_path='Gal_C1X_brdc_land_30sec_24hrs_FNAV-file.txt') data = p.as_dict() Description: Reads data from files in Terrapos position output format. TerraposPositionParser Full name: midgard.parsers.terrapos_position.TerraposPositionParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Terrapos position output file Following data are available after reading Terrapos position file: Key Description gpsweek GPS week gpssec Seconds of GPS week head Head in [deg] height Ellipsoidal height in [m] lat Latitude in [deg] lon Longitude in [deg] num_sat Number of satellites pdop Position Dilution of Precision (PDOP) pitch Pitch in [deg] reliability_east East position external reliability in [m] #TODO: Is that correct? reliability_height Height position external reliability in [m] #TODO: Is that correct? reliability_north North position external reliability in [m] #TODO: Is that correct? roll Roll in [deg] sigma_east Standard deviation of East position in [m] #TODO: Is that correct? sigma_height Standard deviation of Height position in [m] #TODO: Is that correct? sigma_north Standard deviation of North position in [m] #TODO: Is that correct? and meta -data: Key Description __data_path__ File path __parser_name__ Parser name TerraposPositionParser. setup_parser () Full name: midgard.parsers.terrapos_position.setup_parser Signature: (self) -> Dict[str, Any] Set up information needed for the parser This should return a dictionary with all parameters needed by np.genfromtxt to do the actual parsing. Returns: Dict : Parameters needed by np.genfromtxt to parse the input file. midgard.parsers.terrapos_residual A parser for reading Terrapos residual file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_residual', file_path='PPP-residuals.txt') data = p.as_dict() Description: Reads data from files in Terrapos residual format. TerraposResidualParser Full name: midgard.parsers.terrapos_residual.TerraposResidualParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Terrapos residual file Following data are available after reading Terrapos residual file: Parameter Description azimuth Azimuth of satellites in [deg] elevation Elevation of satellites in [deg] gpsweek GPS week gpssec Seconds of GPS week residual_code Code (pseudorange) residuals in [m] residual_doppler Doppler residuals in [m] residual_phase Carrier-phase residuals in [m] satellite Satellite PRN number together with GNSS identifier (e.g. G07) system GNSS identifier and meta -data: Key Description __data_path__ File path __parser_name__ Parser name TerraposResidualParser. setup_parser () Full name: midgard.parsers.terrapos_residual.setup_parser Signature: (self) -> Dict[str, Any] Set up information needed for the parser This should return a dictionary with all parameters needed by np.genfromtxt to do the actual parsing. Returns: Dict : Parameters needed by np.genfromtxt to parse the input file. TerraposResidualParser. setup_postprocessors () Full name: midgard.parsers.terrapos_residual.setup_postprocessors Signature: (self) -> List[Callable[[], NoneType]] List steps necessary for postprocessing midgard.parsers.timeseries_env A parser for reading timeseries files in ENV format Example: from midgard import parsers p = parsers.parse_file(parser_name='timeseries_env', file_path='stas.env') data = p.as_dict() Description: Reads data from files timeseries files in ENV (east, north, vertical) format TimeseriesEnvParser Full name: midgard.parsers.timeseries_env.TimeseriesEnvParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading timeseries files in ENV format Following data are available after reading timeseries ENV file: Key Description date Date in format yyMMMdd (e.g. 18MAY10). year Date in unit year. east East coordinate in [mm]. east_sigma Standard devication of east coordinate in [mm]. north North coordinate in [mm]. north_sigma Standard devication of north coordinate in [mm]. vertical Vertical coordinate in [mm]. vertical_sigma Standard devication of vertical coordinate in [mm]. and meta -data: Key Description __data_path__ File path __params__ np.genfromtxt parameters __parser_name__ Parser name TimeseriesEnvParser. as_dataset () Full name: midgard.parsers.timeseries_env.as_dataset Signature: (self, ref_pos) TimeseriesEnvParser. setup_parser () Full name: midgard.parsers.timeseries_env.setup_parser Signature: (self) -> Dict[str, Any] Set up information needed for the parser This should return a dictionary with all parameters needed by np.genfromtxt to do the actual parsing. Returns: Dict : Parameters needed by np.genfromtxt to parse the input file. midgard.parsers.vlbi_source_names A parser for reading IVS source names translation table VlbiSourceNamesParser Full name: midgard.parsers.vlbi_source_names.VlbiSourceNamesParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file VlbiSourceNamesParser. setup_parser () Full name: midgard.parsers.vlbi_source_names.setup_parser Signature: (self) -> Dict[str, Any] Set up information needed for the parser This should return a dictionary with all parameters needed by np.genfromtxt to do the actual parsing. Returns: Parameters needed by np.genfromtxt to parse the input file. VlbiSourceNamesParser. structure_data () Full name: midgard.parsers.vlbi_source_names.structure_data Signature: (self) -> None Structure raw array data into the self.data dictionary Using the IVS name as key. midgard.parsers.wip_rinex A parser for reading Rinex files rinex () Full name: midgard.parsers.wip_rinex.rinex Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on Rinex file type midgard.parsers.wip_rinex2_nav A parser for reading RINEX navigation files with version 2.xx Rinex2NavParser Full name: midgard.parsers.wip_rinex2_nav.Rinex2NavParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX navigation files with version 2.xx Rinex2NavParser.name (str) name = 'Rinex' midgard.parsers.wip_rinex2_obs A parser for reading RINEX observation files with version 2.xx Rinex2ObsParser Full name: midgard.parsers.wip_rinex2_obs.Rinex2ObsParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX observation files with version 2.xx Rinex2ObsParser.name (str) name = 'Rinex' midgard.parsers.wip_rinex3_nav A parser for reading RINEX navigation files with version 3.xx Rinex3NavParser Full name: midgard.parsers.wip_rinex3_nav.Rinex3NavParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX navigation files with version 3.xx Rinex3NavParser.name (str) name = 'Rinex' midgard.parsers.wip_rinex3_obs A parser for reading RINEX observation files with version 3.xx Rinex3ObsParser Full name: midgard.parsers.wip_rinex3_obs.Rinex3ObsParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX observation files with version 3.xx Rinex3ObsParser.EPOCH_FIELDS (dict) EPOCH_FIELDS = {'identifier': (0, 1), 'year': (2, 6), 'month': (7, 9), 'day': (10, 12), 'hour': (13, 15), 'minute': (16, 18), 'second': (19, 21), 'frac_sec': (21, 29), 'epoch_flag': (30, 32), 'num_data_lines': (33, 35)} Rinex3ObsParser. as_dataframe () Full name: midgard.parsers.wip_rinex3_obs.as_dataframe Signature: (self, system:str, index:Union[str, List[str], NoneType]=None) -> pandas.core.frame.DataFrame Return the parsed data as a Pandas DataFrame This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: sys : Which system to create a datafrom for. index : Optional name of field to use as index. May also be a list of strings. Returns: Pandas DataFrame with the parsed data. Rinex3ObsParser.name (str) name = 'Rinex' Rinex3ObsParser. parse_data_lines () Full name: midgard.parsers.wip_rinex3_obs.parse_data_lines Signature: (self, lines, epoch_info) -> Dict[str, Any] Read one section of data lines Rinex3ObsParser. parse_epoch_line () Full name: midgard.parsers.wip_rinex3_obs.parse_epoch_line Signature: (self, line) -> Dict[str, Any] Read data from Rinex file Add data to self.data midgard.parsers.wip_rinex_clk A parser for reading Rinex navigation files RinexClkParser Full name: midgard.parsers.wip_rinex_clk.RinexClkParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None Class for defining common methods for RINEX clock parsers. RinexClkParser.name (str) name = 'Rinex' rinex_clk () Full name: midgard.parsers.wip_rinex_clk.rinex_clk Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file midgard.parsers.wip_rinex_nav A parser for reading Rinex navigation files RinexNavParser Full name: midgard.parsers.wip_rinex_nav.RinexNavParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None Class for defining common methods for RINEX navigation parsers. RinexNavParser.name (str) name = 'Rinex' rinex_nav () Full name: midgard.parsers.wip_rinex_nav.rinex_nav Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file midgard.parsers.wip_rinex_obs A parser for reading Rinex observation files RinexObsParser Full name: midgard.parsers.wip_rinex_obs.RinexObsParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None Class for defining common methods for RINEX observation parsers. RinexObsParser.name (str) name = 'Rinex' rinex_obs () Full name: midgard.parsers.wip_rinex_obs.rinex_obs Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"midgard.parsers"},{"location":"api/midgard-parsers/#midgardparsers","text":"Framework for parsers Description: To add a new parser, simply create a new .py-file which defines a class inheriting from parsers.Parser. The class needs to be decorated with the midgard.dev.plugins.register decorator as follows: from midgard.parsers import parser from midgard.lib import plugins @plugins.register class MyNewParser(parser.Parser): ... To use a parser, you will typically use the parse_file -function defined below from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() The name used in parse_file to call the parser is the name of the module (file) containing the parser.","title":"midgard.parsers"},{"location":"api/midgard-parsers/#names","text":"Full name: midgard.parsers.names Signature: () -> List[str] List the names of the available parsers Returns: Names of the available parsers","title":"names()"},{"location":"api/midgard-parsers/#parse_file","text":"Full name: midgard.parsers.parse_file Signature: (parser_name:str, file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, timer_logger:Union[Callable[[str], NoneType], NoneType]=None, use_cache:bool=False, **parser_args:Any) -> midgard.parsers._parser.Parser Use the given parser on a file and return parsed data Specify parser_name and file_path to the file that should be parsed. The following parsers are available: {doc_parser_names} Data can be retrieved either as Dictionaries, Pandas DataFrames or Midgard Datasets by using one of the methods as_dict , as_dataframe or as_dataset . Example: >>> df = parse_file('rinex2_obs', 'ande3160.16o').as_dataframe() # doctest: +SKIP Args: parser_name : Name of parser file_path : Path to file that should be parsed. encoding : Encoding in file that is parsed. timer_logger : Logging function that will be used to log timing information. use_cache : Whether to use a cache to avoid parsing the same file several times. parser_args : Input arguments to the parser Returns: Parser : Parser with the parsed data","title":"parse_file()"},{"location":"api/midgard-parsers/#midgardparsers_parser","text":"Basic functionality for parsing datafiles, extended by individual parsers Description: This module contains functions and classes for parsing datafiles. It should typically be used by calling parsers.parse_file : Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser"},{"location":"api/midgard-parsers/#parser","text":"Full name: midgard.parsers._parser.Parser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file. You should inherit from one of the specific parsers like for instance ChainParser, LineParser, SinexParser etc Attributes: file_path (Path): Path to the datafile that will be read. file_encoding (String): Encoding of the datafile. parser_name (String): Name of the parser (as needed to call parsers.parse_...). data_available (Boolean): Indicator of whether data are available. data (Dict): The (observation) data read from file. meta (Dict): Metainformation read from file.","title":"Parser"},{"location":"api/midgard-parsers/#parseras_dataframe","text":"Full name: midgard.parsers._parser.as_dataframe Signature: (self, index:Union[str, List[str], NoneType]=None) -> pandas.core.frame.DataFrame Return the parsed data as a Pandas DataFrame This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: index : Optional name of field to use as index. May also be a list of strings. Returns: Pandas DataFrame with the parsed data.","title":"Parser.as_dataframe()"},{"location":"api/midgard-parsers/#parseras_dataset","text":"Full name: midgard.parsers._parser.as_dataset Signature: (self) -> NoReturn Return the parsed data as a Midgard Dataset This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Returns: Dataset : The parsed data.","title":"Parser.as_dataset()"},{"location":"api/midgard-parsers/#parseras_dict","text":"Full name: midgard.parsers._parser.as_dict Signature: (self, include_meta:bool=False) -> Dict[str, Any] Return the parsed data as a dictionary This is a basic implementation, simply returning a copy of self.data. More advanced parsers may need to reimplement this method. Args: include_meta : Whether to include meta-data in the returned dictionary (default: False). Returns: Dictionary with the parsed data.","title":"Parser.as_dict()"},{"location":"api/midgard-parsers/#parserparse","text":"Full name: midgard.parsers._parser.parse Signature: (self) -> 'Parser' Parse data This is a basic implementation that carries out the whole pipeline of reading and parsing datafiles including calculating secondary data. Subclasses should typically implement (at least) the read_data -method.","title":"Parser.parse()"},{"location":"api/midgard-parsers/#parserpostprocess_data","text":"Full name: midgard.parsers._parser.postprocess_data Signature: (self) -> None Do simple manipulations on the data after they are read Simple manipulations of data may be performed in postprocessors after they are read. They should be kept simple so that a parser returns as true representation of the data file as possible. Advanced calculations may be done inside apriori classes or similar. To add a postprocessor, define it in its own method, and override the setup_postprocessors -method to return a list of all postprocessors.","title":"Parser.postprocess_data()"},{"location":"api/midgard-parsers/#parserread_data","text":"Full name: midgard.parsers._parser.read_data Signature: (self) -> None Read data from the data file Data should be read from self.file_path and stored in the dictionary self.data . A description of the data may be placed in the dictionary self.meta . If data are not available for some reason, self.data_available should be set to False.","title":"Parser.read_data()"},{"location":"api/midgard-parsers/#parsersetup_parser","text":"Full name: midgard.parsers._parser.setup_parser Signature: (self) -> Any Set up information needed for the parser","title":"Parser.setup_parser()"},{"location":"api/midgard-parsers/#parsersetup_postprocessors","text":"Full name: midgard.parsers._parser.setup_postprocessors Signature: (self) -> List[Callable[[], NoneType]] List postprocessors that should be called after parsing","title":"Parser.setup_postprocessors()"},{"location":"api/midgard-parsers/#parserupdate_dataset","text":"Full name: midgard.parsers._parser.update_dataset Signature: (self, dset:Any) -> NoReturn Update the given dataset with the parsed data This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: dset : The dataset to update with parsed data.","title":"Parser.update_dataset()"},{"location":"api/midgard-parsers/#midgardparsers_parser_chain","text":"Basic functionality for parsing datafiles line by line Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser_chain"},{"location":"api/midgard-parsers/#chainparser","text":"Full name: midgard.parsers._parser_chain.ChainParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file with chained groups of information. You should inherit from this one, and at least specify the necessary parameters in setup_parser .","title":"ChainParser"},{"location":"api/midgard-parsers/#chainparserparse_line","text":"Full name: midgard.parsers._parser_chain.parse_line Signature: (self, line:str, cache:Dict[str, Any], parser:midgard.parsers._parser_chain.ParserDef) -> None Parse line A line is parsed by separating a line in fields. How the separation is done, is defined in the parser_def entry of the ParserDef. Args: line : Line to be parsed. cache : Store temporary data. parser : Dictionary with defined parsers with the keys 'parser_def', 'label' and 'end_marker'.","title":"ChainParser.parse_line()"},{"location":"api/midgard-parsers/#chainparserread_data","text":"Full name: midgard.parsers._parser_chain.read_data Signature: (self) -> None Read data from a data file and parse the contents","title":"ChainParser.read_data()"},{"location":"api/midgard-parsers/#chainparsersetup_parser","text":"Full name: midgard.parsers._parser_chain.setup_parser Signature: (self) -> Any Set up information needed for the parser Return an iterable of ParserDef's that describe the structure of the file that will be parsed","title":"ChainParser.setup_parser()"},{"location":"api/midgard-parsers/#parserdef","text":"Full name: midgard.parsers._parser_chain.ParserDef Signature: (end_marker:Callable[[str, int, str], bool], label:Callable[[str, int], Any], parser_def:Dict[Any, Dict[str, Any]], skip_line:Union[Callable[[str], bool], NoneType]=None, end_callback:Union[Callable[[Dict[str, Any]], NoneType], NoneType]=None) A convenience class for defining the necessary fields of a parser A single parser can read and parse one group of datalines, defined through the ParserDef by specifying how to parse each line (parser_def), how to identify each line (label), how to recognize the end of the group of lines (end_marker) and finally what (if anything) should be done after all lines in a group is read (end_callback). The end_marker, label, skip_line and end_callback parameters should all be functions with the following signatures: end_marker = func(line, line_num, next_line) label = func(line, line_num) skip_line = func(line) end_callback = func(cache) The parser definition parser_def includes the parser , field , strip and delimiter entries. The parser entry points to the parser function and the field entry defines how to separate the line in fields. The separated fields are saved either in a dictionary or in a list. In the last case the line is split on whitespace by default. With the delimiter entry the default definition can be overwritten. Leading and trailing whitespace characters are removed by default before a line is parsed. This default can be overwritten by defining the characters, which should be removed with the 'strip' entry. The parser dictionary is defined like: parser_def = { <label>: {'fields': <dict or list of fields>, 'parser': <parser function>, 'delimiter': <optional delimiter for splitting line>, 'strip': <optional characters to be removed from beginning and end of line> }} Args: end_marker : A function returning True for the last line in a group. label : A function returning a label used in the parser_def. parser_def : A dict with 'parser' and 'fields' defining the parser. skip_line : A function returning True if the line should be skipped. end_callback : A function called after reading all lines in a group.","title":"ParserDef"},{"location":"api/midgard-parsers/#midgardparsers_parser_line","text":"Basic functionality for parsing datafiles line by line using Numpy Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser_line"},{"location":"api/midgard-parsers/#lineparser","text":"Full name: midgard.parsers._parser_line.LineParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for using numpy to parse a file line by line. You should inherit from this one, and at least specify the necessary parameters in setup_parser .","title":"LineParser"},{"location":"api/midgard-parsers/#lineparserread_data","text":"Full name: midgard.parsers._parser_line.read_data Signature: (self) -> None Read data from the data file Uses the np.genfromtxt-function to parse the file. Any necessary parameters should be set by setup_parser . Override self.structure_data if the self.data-dictionary needs to be structured in a particular way.","title":"LineParser.read_data()"},{"location":"api/midgard-parsers/#lineparsersetup_parser","text":"Full name: midgard.parsers._parser_line.setup_parser Signature: (self) -> Any Set up information needed for the parser This method should return a dictionary which contains all parameters needed by np.genfromtxt to do the actual parsing.","title":"LineParser.setup_parser()"},{"location":"api/midgard-parsers/#lineparserstructure_data","text":"Full name: midgard.parsers._parser_line.structure_data Signature: (self) -> None Structure raw array data into the self.data dictionary This simple implementation creates a dictionary with one item per column in the array. Override this method for more complex use cases.","title":"LineParser.structure_data()"},{"location":"api/midgard-parsers/#midgardparsers_parser_rinex","text":"Basic functionality for parsing Rinex files Description: This module contains functions and classes for parsing Rinex files. This file defines the general structure shared by most types of Rinex files, including header information. More specific format details are implemented in subclasses. When calling the parser, you should call the apropriate parser for a given Rinex format.","title":"midgard.parsers._parser_rinex"},{"location":"api/midgard-parsers/#rinexheader","text":"Full name: midgard.parsers._parser_rinex.RinexHeader Signature: (marker:str, fields:Dict[str, Tuple[int, int]], parser:Callable[[Dict[str, str]], Dict[str, Any]]) A convenience class for defining how a Rinex header is parsed Args: marker : Marker of header (as defined in columns 60 and onward). fields : Dictionary with field names as keys, tuple of start- and end-columns as value. parser : Function that will parse the fields.","title":"RinexHeader"},{"location":"api/midgard-parsers/#rinexparser","text":"Full name: midgard.parsers._parser_rinex.RinexParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for reading Rinex header data. You should inherit from this one, and at least implement parse_epochs .","title":"RinexParser"},{"location":"api/midgard-parsers/#rinexparserget_rinex_version_type","text":"Full name: midgard.parsers._parser_rinex.get_rinex_version_type Signature: (self) -> Dict[str, str] Get version and type of Rinex file","title":"RinexParser.get_rinex_version_type()"},{"location":"api/midgard-parsers/#rinexparsername-str","text":"name = 'Rinex'","title":"RinexParser.name (str)"},{"location":"api/midgard-parsers/#rinexparserparse_approx_position","text":"Full name: midgard.parsers._parser_rinex.parse_approx_position Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse station coordinates defined in RINEX header to instance variable data","title":"RinexParser.parse_approx_position()"},{"location":"api/midgard-parsers/#rinexparserparse_comment","text":"Full name: midgard.parsers._parser_rinex.parse_comment Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse comment lines in RINEX header to instance variable header['comment']","title":"RinexParser.parse_comment()"},{"location":"api/midgard-parsers/#rinexparserparse_data_lines","text":"Full name: midgard.parsers._parser_rinex.parse_data_lines Signature: (self, lines, epoch_info)","title":"RinexParser.parse_data_lines()"},{"location":"api/midgard-parsers/#rinexparserparse_epoch_line","text":"Full name: midgard.parsers._parser_rinex.parse_epoch_line Signature: (self, line)","title":"RinexParser.parse_epoch_line()"},{"location":"api/midgard-parsers/#rinexparserparse_float","text":"Full name: midgard.parsers._parser_rinex.parse_float Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse float entries of RINEX header to instance variable header","title":"RinexParser.parse_float()"},{"location":"api/midgard-parsers/#rinexparserparse_glonass_code_phase_bias","text":"Full name: midgard.parsers._parser_rinex.parse_glonass_code_phase_bias Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse GLONASS phase correction in RINEX header to instance variable header['glonass_bias'] self.header['glonass_bias'] = { : }","title":"RinexParser.parse_glonass_code_phase_bias()"},{"location":"api/midgard-parsers/#rinexparserparse_glonass_slot","text":"Full name: midgard.parsers._parser_rinex.parse_glonass_slot Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse GLONASS slot and frequency numbers given in RINEX header to instance variable header['glonass_slot'] self.header['glonass_slot'] = { : }","title":"RinexParser.parse_glonass_slot()"},{"location":"api/midgard-parsers/#rinexparserparse_integer","text":"Full name: midgard.parsers._parser_rinex.parse_integer Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse integer entries of RINEX header to instance variable header","title":"RinexParser.parse_integer()"},{"location":"api/midgard-parsers/#rinexparserparse_leap_seconds","text":"Full name: midgard.parsers._parser_rinex.parse_leap_seconds Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header LEAP SECONDS to instance variable header self.header['leap_seconds'] = { 'leap_seconds': , 'future_past_leap_seconds': , 'week': , 'week_day': , 'time_sys': }","title":"RinexParser.parse_leap_seconds()"},{"location":"api/midgard-parsers/#rinexparserparse_phase_shift","text":"Full name: midgard.parsers._parser_rinex.parse_phase_shift Signature: (self, fields:Dict[str, str], cache:List[Dict[str, str]]) -> Dict[str, Any] Parse entries of RINEX header SYS / PHASE SHIFT to instance variable header self.header['phase_shift'] = { <sat_sys>: { <obs_type>: { corr: <correction>, sat: <[satellite list]>}}} Example of phase_shift header entry: self.header['phase_shift'] = {'G': {'L1C': {'corr': '0.00000', 'sat': ['G01', 'G02', 'G03', ...]}, 'L1W': {'corr': '0.00000', 'sat': []}}, 'R': {'L1C': {'corr': '0.00000', 'sat': ['R01', 'R02', 'R07', 'R08']}}} TODO: Maybe better to add information to header['obstypes']?","title":"RinexParser.parse_phase_shift()"},{"location":"api/midgard-parsers/#rinexparserparse_scale_factor","text":"Full name: midgard.parsers._parser_rinex.parse_scale_factor Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header SYS / SCALE FACTOR to instance variable header","title":"RinexParser.parse_scale_factor()"},{"location":"api/midgard-parsers/#rinexparserparse_string","text":"Full name: midgard.parsers._parser_rinex.parse_string Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse string entries of RINEX header to instance variable 'header'","title":"RinexParser.parse_string()"},{"location":"api/midgard-parsers/#rinexparserparse_sys_dcbs_applied","text":"Full name: midgard.parsers._parser_rinex.parse_sys_dcbs_applied Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header SYS / DCBS APPLIED to instance variable header self.header['dcbs_applied'] = { : { prg: , url: }}","title":"RinexParser.parse_sys_dcbs_applied()"},{"location":"api/midgard-parsers/#rinexparserparse_sys_obs_types","text":"Full name: midgard.parsers._parser_rinex.parse_sys_obs_types Signature: (self, fields:Dict[str, str], cache:List[Dict[str, str]]) -> Dict[str, Any] Parse observation types given in RINEX header to instance variable header['obstypes'] and data The data dictionaries obs , cycle_slip and signal_strength are initialized based on the given observation type in the RINEX header. self.header['obstypes'] = { <sat_sys>: [<ordered list with given observation types>]}","title":"RinexParser.parse_sys_obs_types()"},{"location":"api/midgard-parsers/#rinexparserparse_sys_pcvs_applied","text":"Full name: midgard.parsers._parser_rinex.parse_sys_pcvs_applied Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header SYS / PCVS APPLIED to instance variable header self.header['pcvs_applied'] = { : { prg: , url: }}","title":"RinexParser.parse_sys_pcvs_applied()"},{"location":"api/midgard-parsers/#rinexparserparse_time_of_first_obs","text":"Full name: midgard.parsers._parser_rinex.parse_time_of_first_obs Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse time of first observation given in RINEX header to instance variable header","title":"RinexParser.parse_time_of_first_obs()"},{"location":"api/midgard-parsers/#rinexparserparse_time_of_last_obs","text":"Full name: midgard.parsers._parser_rinex.parse_time_of_last_obs Signature: (self, fields:Dict[str, str]) -> Dict[str, Any] Parse time of last observation given in RINEX header to instance variable header","title":"RinexParser.parse_time_of_last_obs()"},{"location":"api/midgard-parsers/#rinexparserread_data","text":"Full name: midgard.parsers._parser_rinex.read_data Signature: (self) -> None Read data from the data file","title":"RinexParser.read_data()"},{"location":"api/midgard-parsers/#rinexparserread_epochs","text":"Full name: midgard.parsers._parser_rinex.read_epochs Signature: (self, fid) -> None Read data from Rinex file Add data to self.data","title":"RinexParser.read_epochs()"},{"location":"api/midgard-parsers/#rinexparserread_header","text":"Full name: midgard.parsers._parser_rinex.read_header Signature: (self, fid) -> None Read header from the rinex file Add header information to self.header","title":"RinexParser.read_header()"},{"location":"api/midgard-parsers/#rinexparserstructure_data","text":"Full name: midgard.parsers._parser_rinex.structure_data Signature: (self) -> None Convert lists of data to numpy arrays","title":"RinexParser.structure_data()"},{"location":"api/midgard-parsers/#parser_cache","text":"Full name: midgard.parsers._parser_rinex.parser_cache Signature: (func:Callable[[_ForwardRef('RinexParser'), Dict[str, str], List[Dict[str, str]]], Dict[str, Any]]) -> Callable[[_ForwardRef('RinexParser'), Dict[str, str]], Dict[str, Any]] Decorator for adding a cache to parser functions","title":"parser_cache()"},{"location":"api/midgard-parsers/#midgardparsers_parser_sinex","text":"Basic functionality for parsing Sinex datafiles Description: This module contains functions and classes for parsing Sinex datafiles. References: SINEX Format: https://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html","title":"midgard.parsers._parser_sinex"},{"location":"api/midgard-parsers/#sinexblock","text":"Full name: midgard.parsers._parser_sinex.SinexBlock Signature: (marker:str, fields:Tuple[midgard.parsers._parser_sinex.SinexField, ...], parser:Callable[[<built-in function array>, Tuple[str, ...]], Dict[str, Any]]) A convenience class for defining a Sinex block Args: marker : Sinex marker denoting the block. fields : Fields in Sinex block. parser : Function used to parse the data.","title":"SinexBlock"},{"location":"api/midgard-parsers/#sinexfield","text":"Full name: midgard.parsers._parser_sinex.SinexField Signature: (name:str, start_col:int, dtype:Union[str, NoneType], converter:Union[str, NoneType]=None) A convenience class for defining the fields in a Sinex block Args: name : Name of field. start_col : Starting column of field (First column is 0) dtype : String, using numpy notation, defining type of field, use None to ignore field. converter : Optional, name of converter to apply to field data.","title":"SinexField"},{"location":"api/midgard-parsers/#sinexparser","text":"Full name: midgard.parsers._parser_sinex.SinexParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, header:bool=True) -> None An abstract base class that has basic methods for parsing a Sinex file This class provides functionality for parsing a sinex file with chained groups of information. You should inherit from this one, and at least specify which Sinex blocks you are interested in by implementing setup_parser , as well as implement methods that parse each block if needed.","title":"SinexParser"},{"location":"api/midgard-parsers/#sinexparseras_dataframe","text":"Full name: midgard.parsers._parser_sinex.as_dataframe Signature: (self, index:Union[str, List[str], NoneType]=None, marker:Union[str, NoneType]=None) -> pandas.core.frame.DataFrame Return the parsed data as a Pandas DataFrame This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: marker : Only return data from this marker in the DataFrame. index : Name of field to use as index. May also be a list of strings. Returns: Pandas DataFrame with the parsed data.","title":"SinexParser.as_dataframe()"},{"location":"api/midgard-parsers/#sinexparserparse_bias_epochs","text":"Full name: midgard.parsers._parser_sinex.parse_bias_epochs Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_bias_epochs()"},{"location":"api/midgard-parsers/#sinexparserparse_blocks","text":"Full name: midgard.parsers._parser_sinex.parse_blocks Signature: (self, fid:Iterable[bytes]) -> None Parse contents of Sinex blocks Contents of Sinex blocks are stored as separate numpy-arrays in self._sinex Args: fid : Pointer to file being read.","title":"SinexParser.parse_blocks()"},{"location":"api/midgard-parsers/#sinexparserparse_file_comment","text":"Full name: midgard.parsers._parser_sinex.parse_file_comment Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_file_comment()"},{"location":"api/midgard-parsers/#sinexparserparse_file_reference","text":"Full name: midgard.parsers._parser_sinex.parse_file_reference Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_file_reference()"},{"location":"api/midgard-parsers/#sinexparserparse_header_line","text":"Full name: midgard.parsers._parser_sinex.parse_header_line Signature: (self, header_line:bytes) -> None Parse header of Sinex file Header information is stored in self.meta . Args: header_line : First line of Sinex file.","title":"SinexParser.parse_header_line()"},{"location":"api/midgard-parsers/#sinexparserparse_input_acknowledgements","text":"Full name: midgard.parsers._parser_sinex.parse_input_acknowledgements Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_input_acknowledgements()"},{"location":"api/midgard-parsers/#sinexparserparse_input_files","text":"Full name: midgard.parsers._parser_sinex.parse_input_files Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_input_files()"},{"location":"api/midgard-parsers/#sinexparserparse_input_history","text":"Full name: midgard.parsers._parser_sinex.parse_input_history Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_input_history()"},{"location":"api/midgard-parsers/#sinexparserparse_lines","text":"Full name: midgard.parsers._parser_sinex.parse_lines Signature: (self, lines:List[bytes], fields:Tuple[midgard.parsers._parser_sinex.SinexField, ...]) -> <built-in function array> Parse lines in a Sinex file Args: lines : Lines to parse. fields : Definition of sinex fields in lines. Returns: Data contained in lines.","title":"SinexParser.parse_lines()"},{"location":"api/midgard-parsers/#sinexparserparse_nutation_data","text":"Full name: midgard.parsers._parser_sinex.parse_nutation_data Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_nutation_data()"},{"location":"api/midgard-parsers/#sinexparserparse_precession_data","text":"Full name: midgard.parsers._parser_sinex.parse_precession_data Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_precession_data()"},{"location":"api/midgard-parsers/#sinexparserparse_satellite_id","text":"Full name: midgard.parsers._parser_sinex.parse_satellite_id Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_satellite_id()"},{"location":"api/midgard-parsers/#sinexparserparse_satellite_phase_center","text":"Full name: midgard.parsers._parser_sinex.parse_satellite_phase_center Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_satellite_phase_center()"},{"location":"api/midgard-parsers/#sinexparserparse_site_antenna","text":"Full name: midgard.parsers._parser_sinex.parse_site_antenna Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_antenna()"},{"location":"api/midgard-parsers/#sinexparserparse_site_data","text":"Full name: midgard.parsers._parser_sinex.parse_site_data Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_data()"},{"location":"api/midgard-parsers/#sinexparserparse_site_eccentricity","text":"Full name: midgard.parsers._parser_sinex.parse_site_eccentricity Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_eccentricity()"},{"location":"api/midgard-parsers/#sinexparserparse_site_gal_phase_center","text":"Full name: midgard.parsers._parser_sinex.parse_site_gal_phase_center Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_gal_phase_center()"},{"location":"api/midgard-parsers/#sinexparserparse_site_gps_phase_center","text":"Full name: midgard.parsers._parser_sinex.parse_site_gps_phase_center Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_gps_phase_center()"},{"location":"api/midgard-parsers/#sinexparserparse_site_id","text":"Full name: midgard.parsers._parser_sinex.parse_site_id Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_id()"},{"location":"api/midgard-parsers/#sinexparserparse_site_receiver","text":"Full name: midgard.parsers._parser_sinex.parse_site_receiver Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_receiver()"},{"location":"api/midgard-parsers/#sinexparserparse_solution_apriori","text":"Full name: midgard.parsers._parser_sinex.parse_solution_apriori Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_solution_apriori()"},{"location":"api/midgard-parsers/#sinexparserparse_solution_epochs","text":"Full name: midgard.parsers._parser_sinex.parse_solution_epochs Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_solution_epochs()"},{"location":"api/midgard-parsers/#sinexparserparse_solution_estimate","text":"Full name: midgard.parsers._parser_sinex.parse_solution_estimate Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_solution_estimate()"},{"location":"api/midgard-parsers/#sinexparserparse_solution_matrix_apriori","text":"Full name: midgard.parsers._parser_sinex.parse_solution_matrix_apriori Signature: (self:'SinexParser', data:<built-in function array>, lower_upper:str, type:str='') -> Dict[str, Any] Parser for SOLUTION/MATRIX_APRIORI data Converts the input data to a symmetric matrix and adds it to self.data['SOLUTION/MATRIX_APRIORI']. The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters Index in the SOLUTION/ESTIMATE block. Missing elements in the matrix are assumed to be zero (0); consequently, zero elements may be omitted to reduce the size of this block. Args: data : Input data, raw data for SOLUTION/MATRIX_APRIORI block. lower_upper : Either 'L' or 'U', indicating whether the matrix is given in lower or upper form. type : Information about the type of matrix, optional. Returns: Dictionary with symmetric matrix as a numpy array.","title":"SinexParser.parse_solution_matrix_apriori()"},{"location":"api/midgard-parsers/#sinexparserparse_solution_matrix_estimate","text":"Full name: midgard.parsers._parser_sinex.parse_solution_matrix_estimate Signature: (self:'SinexParser', data:<built-in function array>, lower_upper:str, type:str='') -> Dict[str, Any] Parser for SOLUTION/MATRIX_ESTIMATE data Converts the input data to a symmetric matrix and adds it to self.data['SOLUTION/MATRIX_ESTIMATE']. The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters Index in the SOLUTION/ESTIMATE block. Missing elements in the matrix are assumed to be zero (0); consequently, zero elements may be omitted to reduce the size of this block. Args: data : Input data, raw data for SOLUTION/MATRIX_ESTIMATE block. lower_upper : Either 'L' or 'U', indicating whether the matrix is given in lower or upper form. type : Information about the type of matrix, optional. Returns: Dictionary with symmetric matrix as a numpy array.","title":"SinexParser.parse_solution_matrix_estimate()"},{"location":"api/midgard-parsers/#sinexparserparse_solution_normal_equation_matrix","text":"Full name: midgard.parsers._parser_sinex.parse_solution_normal_equation_matrix Signature: (self:'SinexParser', data:<built-in function array>, lower_upper:str, type:str='') -> Dict[str, Any] Parser for SOLUTION/NORMAL_EQUATION_MATRIX data Converts the input data to a symmetric matrix and adds it to self.data['SOLUTION/NORMAL_EQUATION_MATRIX']. The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters Index in the SOLUTION/ESTIMATE block. Missing elements in the matrix are assumed to be zero (0); consequently, zero elements may be omitted to reduce the size of this block. Args: data : Input data, raw data for SOLUTION/NORMAL_EQUATION_MATRIX block. lower_upper : Either 'L' or 'U', indicating whether the matrix is given in lower or upper form. type : Information about the type of matrix, optional. Returns: Dictionary with symmetric matrix as a numpy array.","title":"SinexParser.parse_solution_normal_equation_matrix()"},{"location":"api/midgard-parsers/#sinexparserparse_solution_normal_equation_vector","text":"Full name: midgard.parsers._parser_sinex.parse_solution_normal_equation_vector Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_solution_normal_equation_vector()"},{"location":"api/midgard-parsers/#sinexparserparse_solution_statistics","text":"Full name: midgard.parsers._parser_sinex.parse_solution_statistics Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_solution_statistics()"},{"location":"api/midgard-parsers/#sinexparserparse_source_id","text":"Full name: midgard.parsers._parser_sinex.parse_source_id Signature: (self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_source_id()"},{"location":"api/midgard-parsers/#sinexparserread_data","text":"Full name: midgard.parsers._parser_sinex.read_data Signature: (self) -> None Read data from a Sinex file and parse the contents First the whole Sinex file is read and the requested blocks are stored in self._sinex. After the file has been read, a parser is called on each block so that self.data is properly populated.","title":"SinexParser.read_data()"},{"location":"api/midgard-parsers/#sinexparsersetup_parser","text":"Full name: midgard.parsers._parser_sinex.setup_parser Signature: (self) -> Any Set up information needed for the parser Each individual Sinex-parser should at least implement this method. If the order the blocks are parsed is not important, the information should be returned as a set for optimal performance. If the parsing order is important, a tuple of SinexBlock-objects may be returned instead. Returns: Iterable of blocks in the Sinex file that should be parsed.","title":"SinexParser.setup_parser()"},{"location":"api/midgard-parsers/#parsing_factory","text":"Full name: midgard.parsers._parser_sinex.parsing_factory Signature: () -> Callable[..., Dict[str, Any]] Create a default parsing function for a Sinex block The default parsing function returns a dictionary containing all fields of the block as separated arrays. This will be stored in self.data['{marker}'] with the {marker} of the current block. Returns: Simple parsing function for one Sinex block.","title":"parsing_factory()"},{"location":"api/midgard-parsers/#parsing_matrix_factory","text":"Full name: midgard.parsers._parser_sinex.parsing_matrix_factory Signature: (marker:str, size_marker:str) -> Callable[..., Dict[str, Any]] Create a parsing function for parsing a matrix within a Sinex block The default parsing function converts data to a symmetric matrix and stores it inside self.data[marker] . The size of the matrix is set to equal the number of parameters in the size_marker -block. If that block is not parsed/found. The size is set to the last given row index. If some zero elements in the matrix are omitted this might be wrong. Args: marker : Marker of Sinex block. size_marker : Marker of a different Sinex block indicating the size of the matrix. Returns: Simple parsing function for one Sinex block.","title":"parsing_matrix_factory()"},{"location":"api/midgard-parsers/#midgardparsersanubis","text":"A parser for reading Anubis xtr-files","title":"midgard.parsers.anubis"},{"location":"api/midgard-parsers/#anubisxtrparser","text":"Full name: midgard.parsers.anubis.AnubisXtrParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Anubis XTR files","title":"AnubisXtrParser"},{"location":"api/midgard-parsers/#anubisxtrparserread_data","text":"Full name: midgard.parsers.anubis.read_data Signature: (self) -> None Read data and store in .data dictionary","title":"AnubisXtrParser.read_data()"},{"location":"api/midgard-parsers/#midgardparsersbcecmp_sisre","text":"A parser for reading DLR BCEcmp Software SISRE output files Example: from midgard import parsers p = parsers.parse_file(parser_name='bcecmp_sisre', file_path='BCEcmp_GAL_FNAV_E1E5A_com_2018_032.OUT') data = p.as_dict() Description: Reads data from files in the BCEcmp Software output file format. The BCEcmp Software is developed and used by DLR.","title":"midgard.parsers.bcecmp_sisre"},{"location":"api/midgard-parsers/#bcecmpparser","text":"Full name: midgard.parsers.bcecmp_sisre.BcecmpParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading DLR BCEcmp Software output files. The following data are available after reading BCEcmp Software output file: Key Description age_min age of ephemeris in [min] clk_diff_sys Satellite clock correction difference in [m] dalong_track Along-track orbit difference in [m] dcross_track Cross-track orbit difference in [m] dradial Radial orbit difference in [m] dradial_wul Worst-user-location (wul) SISRE? satellite Satellite PRN number together with GNSS identifier (e.g. G07) sisre Signal-in-space range error [m] time Observation time used_iodc GPS: IODC (Clock issue of data indicates changes (set equal to IODE)) QZSS: IODC used_iode Ephemeris issue of data indicates changes to the broadcast ephemeris: - GPS: Ephemeris issue of data (IODE), which is set equal to IODC - Galileo: Issue of Data of the NAV batch (IODnav) - QZSS: Ephemeris issue of data (IODE) - BeiDou: Age of Data Ephemeris (AODE) - IRNSS: Issue of Data, Ephemeris and Clock (IODEC) and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"BcecmpParser"},{"location":"api/midgard-parsers/#bcecmpparsersetup_parser","text":"Full name: midgard.parsers.bcecmp_sisre.setup_parser Signature: (self) -> Iterable[midgard.parsers._parser_chain.ParserDef] Parsers defined for reading BCEcmp Software output file line by line.","title":"BcecmpParser.setup_parser()"},{"location":"api/midgard-parsers/#bcecmpparsersetup_postprocessors","text":"Full name: midgard.parsers.bcecmp_sisre.setup_postprocessors Signature: (self) -> List[Callable[[], NoneType]] List steps necessary for postprocessing","title":"BcecmpParser.setup_postprocessors()"},{"location":"api/midgard-parsers/#midgardparsersgalileo_constellation_html","text":"A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example","title":"midgard.parsers.galileo_constellation_html"},{"location":"api/midgard-parsers/#galileoconstellationhtmlparser","text":"Full name: midgard.parsers.galileo_constellation_html.GalileoConstellationHTMLParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, url:Union[str, NoneType]=None) -> None A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example","title":"GalileoConstellationHTMLParser"},{"location":"api/midgard-parsers/#galileoconstellationhtmlparserurl-str","text":"URL = 'https://www.gsc-europa.eu/system-status/Constellation-Information'","title":"GalileoConstellationHTMLParser.URL (str)"},{"location":"api/midgard-parsers/#galileoconstellationhtmlparserdownload_html","text":"Full name: midgard.parsers.galileo_constellation_html.download_html Signature: (self, url:Union[str, NoneType]=None) -> None Download html file from url TODO: Move this to files/url.py Args: url : URL to download from, if None use self.URL instead.","title":"GalileoConstellationHTMLParser.download_html()"},{"location":"api/midgard-parsers/#galileoconstellationhtmlparserread_data","text":"Full name: midgard.parsers.galileo_constellation_html.read_data Signature: (self) -> None Read tables from the HTML file The satellite table is placed in self.data, while the NAGU events are placed in self.meta[\"events\"].","title":"GalileoConstellationHTMLParser.read_data()"},{"location":"api/midgard-parsers/#galileoconstellationhtmlparsersatellite_id","text":"Full name: midgard.parsers.galileo_constellation_html.satellite_id Signature: (self, sat_id:str) -> Dict[str, Any] Get satellite info from satellite vehicle ID Args: sat_id : ID of satellite, for example E01. Returns: Dictionary with satellite info.","title":"GalileoConstellationHTMLParser.satellite_id()"},{"location":"api/midgard-parsers/#galileoconstellationhtmlparsersatellite_name","text":"Full name: midgard.parsers.galileo_constellation_html.satellite_name Signature: (self, sat_name:str) -> Dict[str, Any] Get satellite info from name Args: sat_name : Name of satellite, for example GSAT0101. Returns: Dictionary with satellite info.","title":"GalileoConstellationHTMLParser.satellite_name()"},{"location":"api/midgard-parsers/#midgardparsersgipsy_tdp","text":"A parser for reading NASA JPL Gipsy time dependent parameter (TDP) file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsy_tdp', file_path='final.tdp') data = p.as_dict() Description: Reads data from files in Gipsy time dependent parameter (TDP) format.","title":"midgard.parsers.gipsy_tdp"},{"location":"api/midgard-parsers/#gipsytdpparser","text":"Full name: midgard.parsers.gipsy_tdp.GipsyTdpParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Gipsy time dependent parameter (TDP) file Following data are available after reading Gipsy TDP output file: Key Description apriori_value Nominal value. This field contains the last value used by the model. name Parameter name. sigma The sigma associated with the value of the parameter. A negative value indicates it should be used for interpolation by the file reader read_time_variation in $GOA/libsrc/time_variation. If no sigmas are computed by the smapper, a 1.0 will be placed here. time_past_j2000 Time given in GPS seconds past J2000. value Accumulated value of the parameter at time and includes any nominal, or iterative correction. This is the only entry used by the model. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyTdpParser"},{"location":"api/midgard-parsers/#gipsytdpparsersetup_parser","text":"Full name: midgard.parsers.gipsy_tdp.setup_parser Signature: (self) -> Dict[str, Any] Set up information needed for the parser This should return a dictionary with all parameters needed by np.genfromtxt to do the actual parsing. TODO: Station name should be separated from parameter name. Returns: Dict : Parameters needed by np.genfromtxt to parse the input file.","title":"GipsyTdpParser.setup_parser()"},{"location":"api/midgard-parsers/#midgardparsersgnss_antex","text":"A parser for reading ANTEX format 1.4 data Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_antex', file_path='igs14.atx') data = p.as_dict() Description: Reads data from files in the GNSS Antenna Exchange (ANTEX) file format version 1.4 (see :cite: antex ).","title":"midgard.parsers.gnss_antex"},{"location":"api/midgard-parsers/#antexparser","text":"Full name: midgard.parsers.gnss_antex.AntexParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading ANTEX file The parser reads GNSS ANTEX format 1.4 (see :cite: antex ). The 'data' attribute is a dictionary with GNSS satellite PRN or receiver antenna as key. The GNSS satellite antenna corrections are time dependent and saved with \"valid from\" datetime object entry. The dictionary looks like: dout = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}} with following entries: Value Type Description azi numpy.ndarray Array with azimuth-elevation dependent antenna correction in [mm] with the shape: number of azimuth values x number of elevation values. azimuth numpy.ndarray List with azimuth values in [rad] corresponding to antenna corrections given in azi . cospar_id str COSPAR ID : yyyy -> year when the satellite was put in orbit, xxx -> sequential satellite number for that year, a -> alpha numeric sequence number within a launch elevation numpy.ndarray List with elevation values in [rad] corresponding to antenna corrections given in azi or noazi . str Frequency identifier (e.g. G01 - GPS L1) neu list North, East and Up eccentricities in [m]. The eccentricities of the mean antenna phase center is given relative to the antenna reference point (ARP) for receiver antennas or to the center of mass of the satellite in X-, Y- and Z-direction. noazi numpy.ndarray List with elevation dependent (non-azimuth-dependent) antenna correction in [mm]. str Satellite code e.g. GPS PRN, GLONASS slot or Galileo SVID number str Receiver antenna name together with radome code sat_code str Satellite code e.g. GPS SVN, GLONASS number or Galileo GSAT number sat_type str Satellite type (e.g. BLOCK IIA) valid_from datetime.datetime Start of validity period of satellite in GPS time valid_until datetime.datetime End of validity period of satellite in GPS time The 'meta' attribute is a dictionary with following entries: Value Type Description comment list Header commments given in list line by line pcv_type str Phase center variation type ref_antenna str Reference antenna type for relative antenna ref_serial_num str Serial number of the reference antenna sat_sys str Satellite system version str Format version Attributes: data : (dict), Contains the (observation) data read from file. data_available : (bool), Indicator of whether data are available. file_path : (pathlib.Path), File path. parser_name : (str), Parser name. meta : (dict), Contains metainformation read from file.","title":"AntexParser"},{"location":"api/midgard-parsers/#antexparserparse_comment","text":"Full name: midgard.parsers.gnss_antex.parse_comment Signature: (self, line:Dict[str, str], _:Dict[str, Any]) -> None Parse comment lines in ANTEX header.","title":"AntexParser.parse_comment()"},{"location":"api/midgard-parsers/#antexparserparse_correction","text":"Full name: midgard.parsers.gnss_antex.parse_correction Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse antenna corrections entries of ANTEX antenna section.","title":"AntexParser.parse_correction()"},{"location":"api/midgard-parsers/#antexparserparse_default_meta","text":"Full name: midgard.parsers.gnss_antex.parse_default_meta Signature: (self, line:Dict[str, str], _:Dict[str, Any]) -> None Add the contents of line to meta Args: line : Dict containing the fields of a line.","title":"AntexParser.parse_default_meta()"},{"location":"api/midgard-parsers/#antexparserparse_num_of_frequencies","text":"Full name: midgard.parsers.gnss_antex.parse_num_of_frequencies Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse '# OF FREQUENCIES' entry of ANTEX antenna section.","title":"AntexParser.parse_num_of_frequencies()"},{"location":"api/midgard-parsers/#antexparserparse_section_float","text":"Full name: midgard.parsers.gnss_antex.parse_section_float Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse float entries of ANTEX header.","title":"AntexParser.parse_section_float()"},{"location":"api/midgard-parsers/#antexparserparse_section_string","text":"Full name: midgard.parsers.gnss_antex.parse_section_string Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse string entries of ANTEX header.","title":"AntexParser.parse_section_string()"},{"location":"api/midgard-parsers/#antexparserparse_string","text":"Full name: midgard.parsers.gnss_antex.parse_string Signature: (self, line:Dict[str, str], _:Dict[str, Any]) -> None Parse string entries of ANTEX header.","title":"AntexParser.parse_string()"},{"location":"api/midgard-parsers/#antexparserparse_valid_from","text":"Full name: midgard.parsers.gnss_antex.parse_valid_from Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse 'VALID FROM' entries of ANTEX antenna section.","title":"AntexParser.parse_valid_from()"},{"location":"api/midgard-parsers/#antexparserparse_valid_until","text":"Full name: midgard.parsers.gnss_antex.parse_valid_until Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse 'VALID UNTIL' entries of ANTEX antenna section.","title":"AntexParser.parse_valid_until()"},{"location":"api/midgard-parsers/#antexparsersave_correction","text":"Full name: midgard.parsers.gnss_antex.save_correction Signature: (self, line:Dict[str, str], cache:Dict[str, Any]) -> None Save antenna correction in data structures. The antenna corrections are saved after reading of corrections for one frequency. Antenna correction data are saved in following data structure, whereby satellite antenna corrections are time dependent: self.data = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }} }","title":"AntexParser.save_correction()"},{"location":"api/midgard-parsers/#antexparsersetup_parser","text":"Full name: midgard.parsers.gnss_antex.setup_parser Signature: (self) -> Iterable[midgard.parsers._parser_chain.ParserDef] Parsers defined for reading ANTEX file line by line. First the ANTEX header information are read and afterwards the ANTEX corrections.","title":"AntexParser.setup_parser()"},{"location":"api/midgard-parsers/#midgardparsersgnss_sinex_igs","text":"A parser for reading data from igs.snx file based on IGS sitelog files in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_sinex_igs', file_path='igs.snx') data = p.as_dict() Description: Reads station information (e.g. approximated station coordinates, receiver and antenna type, station eccentricities, ...) igs.snx file in SINEX format.","title":"midgard.parsers.gnss_sinex_igs"},{"location":"api/midgard-parsers/#igssnxparser","text":"Full name: midgard.parsers.gnss_sinex_igs.IgsSnxParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, header:bool=True) -> None A parser for reading data from igs.snx file based on IGS sitelog files in SINEX format site - Site dictionary, whereby keys are the site identifiers and values are a site entry dictionary with the keys 'site_antenna', 'site_eccentricity', 'site_id' and 'site_receiver'. The site dictionary has following strucuture: self.site[site] = { 'site_antenna': [], # SITE/ANTENNA SINEX block information 'site_eccentricity': [], # SITE/ECCENTRICITY block information 'site_id': {}, # SITE/ID block information 'site_receiver': [], # SITE/RECEIVER block information } with the site entry dictionary entries site_antenna[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'antenna_type': antenna_type, 'radome_type': radome_type, 'serial_number': serial_number } site_eccentricity[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'reference_system': reference_system, 'vector_1': vector_1, 'vector_2': vector_2, 'vector_3': vector_3, 'vector_type': UNE } site_id = { 'point_code': point_code, 'domes': domes, 'marker': marker, 'obs_code': obs_code, 'description': description, 'approx_lon': approx_lon, 'approx_lat': approx_lat, 'approx_height': approx_height } site_receiver[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'receiver_type': receiver_type, 'serial_number': serial_number, 'firmware': firmware } The counter 'ii' ranges from 0 to n and depends on how many antenna type, receiver type and antenna monument changes were done at each site. Note also, that time entries (e.g. start_time, end_time) are given in Modified Julian Date. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class.","title":"IgsSnxParser"},{"location":"api/midgard-parsers/#igssnxparserparse_site_antenna","text":"Full name: midgard.parsers.gnss_sinex_igs.parse_site_antenna Signature: (self, data) Parse SITE/ANTENNA SINEX block","title":"IgsSnxParser.parse_site_antenna()"},{"location":"api/midgard-parsers/#igssnxparserparse_site_eccentricity","text":"Full name: midgard.parsers.gnss_sinex_igs.parse_site_eccentricity Signature: (self, data) Parse SITE/ECCENTRICITY SINEX block","title":"IgsSnxParser.parse_site_eccentricity()"},{"location":"api/midgard-parsers/#igssnxparserparse_site_id","text":"Full name: midgard.parsers.gnss_sinex_igs.parse_site_id Signature: (self, data) Parse SITE/ID SINEX block","title":"IgsSnxParser.parse_site_id()"},{"location":"api/midgard-parsers/#igssnxparserparse_site_receiver","text":"Full name: midgard.parsers.gnss_sinex_igs.parse_site_receiver Signature: (self, data) Parse SITE/RECEIVER SINEX block","title":"IgsSnxParser.parse_site_receiver()"},{"location":"api/midgard-parsers/#igssnxparsersetup_parser","text":"Full name: midgard.parsers.gnss_sinex_igs.setup_parser Signature: (self)","title":"IgsSnxParser.setup_parser()"},{"location":"api/midgard-parsers/#midgardparsersrinex2_nav_header","text":"RINEX navigation header classes for file format version 2.xx","title":"midgard.parsers.rinex2_nav_header"},{"location":"api/midgard-parsers/#rinex2navheadermixin","text":"Full name: midgard.parsers.rinex2_nav_header.Rinex2NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 2.xx","title":"Rinex2NavHeaderMixin"},{"location":"api/midgard-parsers/#rinex2navheaderparser","text":"Full name: midgard.parsers.rinex2_nav_header.Rinex2NavHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 2.xx navigation header The data in the rinex file will not be parsed.","title":"Rinex2NavHeaderParser"},{"location":"api/midgard-parsers/#rinex2navheaderparsername-str","text":"name = 'Rinex'","title":"Rinex2NavHeaderParser.name (str)"},{"location":"api/midgard-parsers/#rinex2navheaderparserread_epochs","text":"Full name: midgard.parsers.rinex2_nav_header.read_epochs Signature: (self, fid) -> None Do not read data from Rinex file Skip reading of data.","title":"Rinex2NavHeaderParser.read_epochs()"},{"location":"api/midgard-parsers/#midgardparsersrinex2_obs_header","text":"RINEX observation header classes for file format version 3.xx","title":"midgard.parsers.rinex2_obs_header"},{"location":"api/midgard-parsers/#rinex2obsheadermixin","text":"Full name: midgard.parsers.rinex2_obs_header.Rinex2ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 2.xx","title":"Rinex2ObsHeaderMixin"},{"location":"api/midgard-parsers/#rinex2obsheaderparser","text":"Full name: midgard.parsers.rinex2_obs_header.Rinex2ObsHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 2.xx observation header The data in the rinex file will not be parsed.","title":"Rinex2ObsHeaderParser"},{"location":"api/midgard-parsers/#rinex2obsheaderparsername-str","text":"name = 'Rinex'","title":"Rinex2ObsHeaderParser.name (str)"},{"location":"api/midgard-parsers/#rinex2obsheaderparserread_epochs","text":"Full name: midgard.parsers.rinex2_obs_header.read_epochs Signature: (self, fid) -> None Do not read data from Rinex file Skip reading of data.","title":"Rinex2ObsHeaderParser.read_epochs()"},{"location":"api/midgard-parsers/#midgardparsersrinex3_clk","text":"A parser for reading RINEX clock files with version 3.xx","title":"midgard.parsers.rinex3_clk"},{"location":"api/midgard-parsers/#rinex3clkparser","text":"Full name: midgard.parsers.rinex3_clk.Rinex3ClkParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX clock files with version 3.xx","title":"Rinex3ClkParser"},{"location":"api/midgard-parsers/#rinex3clkparsername-str","text":"name = 'Rinex'","title":"Rinex3ClkParser.name (str)"},{"location":"api/midgard-parsers/#midgardparsersrinex3_clk_header","text":"RINEX clock header classes for file format version 3.xx","title":"midgard.parsers.rinex3_clk_header"},{"location":"api/midgard-parsers/#rinex3clkheadermixin","text":"Full name: midgard.parsers.rinex3_clk_header.Rinex3ClkHeaderMixin Signature: () A mixin defining which RINEX clock headers are mandatory and optional in RINEX version 3.xx","title":"Rinex3ClkHeaderMixin"},{"location":"api/midgard-parsers/#rinex3clkheaderparser","text":"Full name: midgard.parsers.rinex3_clk_header.Rinex3ClkHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 3.xx clock header The data in the rinex file will not be parsed.","title":"Rinex3ClkHeaderParser"},{"location":"api/midgard-parsers/#rinex3clkheaderparsername-str","text":"name = 'Rinex'","title":"Rinex3ClkHeaderParser.name (str)"},{"location":"api/midgard-parsers/#rinex3clkheaderparserread_epochs","text":"Full name: midgard.parsers.rinex3_clk_header.read_epochs Signature: (self, fid) -> None Do not read data from Rinex file Skip reading of data.","title":"Rinex3ClkHeaderParser.read_epochs()"},{"location":"api/midgard-parsers/#midgardparsersrinex3_nav_header","text":"RINEX navigation header classes for file format version 3.xx","title":"midgard.parsers.rinex3_nav_header"},{"location":"api/midgard-parsers/#rinex3navheadermixin","text":"Full name: midgard.parsers.rinex3_nav_header.Rinex3NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 3.xx","title":"Rinex3NavHeaderMixin"},{"location":"api/midgard-parsers/#rinex3navheaderparser","text":"Full name: midgard.parsers.rinex3_nav_header.Rinex3NavHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 3.xx navigation header The data in the rinex file will not be parsed.","title":"Rinex3NavHeaderParser"},{"location":"api/midgard-parsers/#rinex3navheaderparsername-str","text":"name = 'Rinex'","title":"Rinex3NavHeaderParser.name (str)"},{"location":"api/midgard-parsers/#rinex3navheaderparserread_epochs","text":"Full name: midgard.parsers.rinex3_nav_header.read_epochs Signature: (self, fid) -> None Do not read data from Rinex file Skip reading of data.","title":"Rinex3NavHeaderParser.read_epochs()"},{"location":"api/midgard-parsers/#midgardparsersrinex3_obs_header","text":"RINEX observation header classes for file format version 3.xx","title":"midgard.parsers.rinex3_obs_header"},{"location":"api/midgard-parsers/#rinex3obsheadermixin","text":"Full name: midgard.parsers.rinex3_obs_header.Rinex3ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 3.xx","title":"Rinex3ObsHeaderMixin"},{"location":"api/midgard-parsers/#rinex3obsheaderparser","text":"Full name: midgard.parsers.rinex3_obs_header.Rinex3ObsHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 3.xx observation header The data in the rinex file will not be parsed.","title":"Rinex3ObsHeaderParser"},{"location":"api/midgard-parsers/#rinex3obsheaderparsername-str","text":"name = 'Rinex'","title":"Rinex3ObsHeaderParser.name (str)"},{"location":"api/midgard-parsers/#rinex3obsheaderparserread_epochs","text":"Full name: midgard.parsers.rinex3_obs_header.read_epochs Signature: (self, fid) -> None Do not read data from Rinex file Skip reading of data.","title":"Rinex3ObsHeaderParser.read_epochs()"},{"location":"api/midgard-parsers/#midgardparsersterrapos_position","text":"A parser for reading Terrapos position output file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_position', file_path='Gal_C1X_brdc_land_30sec_24hrs_FNAV-file.txt') data = p.as_dict() Description: Reads data from files in Terrapos position output format.","title":"midgard.parsers.terrapos_position"},{"location":"api/midgard-parsers/#terrapospositionparser","text":"Full name: midgard.parsers.terrapos_position.TerraposPositionParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Terrapos position output file Following data are available after reading Terrapos position file: Key Description gpsweek GPS week gpssec Seconds of GPS week head Head in [deg] height Ellipsoidal height in [m] lat Latitude in [deg] lon Longitude in [deg] num_sat Number of satellites pdop Position Dilution of Precision (PDOP) pitch Pitch in [deg] reliability_east East position external reliability in [m] #TODO: Is that correct? reliability_height Height position external reliability in [m] #TODO: Is that correct? reliability_north North position external reliability in [m] #TODO: Is that correct? roll Roll in [deg] sigma_east Standard deviation of East position in [m] #TODO: Is that correct? sigma_height Standard deviation of Height position in [m] #TODO: Is that correct? sigma_north Standard deviation of North position in [m] #TODO: Is that correct? and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"TerraposPositionParser"},{"location":"api/midgard-parsers/#terrapospositionparsersetup_parser","text":"Full name: midgard.parsers.terrapos_position.setup_parser Signature: (self) -> Dict[str, Any] Set up information needed for the parser This should return a dictionary with all parameters needed by np.genfromtxt to do the actual parsing. Returns: Dict : Parameters needed by np.genfromtxt to parse the input file.","title":"TerraposPositionParser.setup_parser()"},{"location":"api/midgard-parsers/#midgardparsersterrapos_residual","text":"A parser for reading Terrapos residual file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_residual', file_path='PPP-residuals.txt') data = p.as_dict() Description: Reads data from files in Terrapos residual format.","title":"midgard.parsers.terrapos_residual"},{"location":"api/midgard-parsers/#terraposresidualparser","text":"Full name: midgard.parsers.terrapos_residual.TerraposResidualParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Terrapos residual file Following data are available after reading Terrapos residual file: Parameter Description azimuth Azimuth of satellites in [deg] elevation Elevation of satellites in [deg] gpsweek GPS week gpssec Seconds of GPS week residual_code Code (pseudorange) residuals in [m] residual_doppler Doppler residuals in [m] residual_phase Carrier-phase residuals in [m] satellite Satellite PRN number together with GNSS identifier (e.g. G07) system GNSS identifier and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"TerraposResidualParser"},{"location":"api/midgard-parsers/#terraposresidualparsersetup_parser","text":"Full name: midgard.parsers.terrapos_residual.setup_parser Signature: (self) -> Dict[str, Any] Set up information needed for the parser This should return a dictionary with all parameters needed by np.genfromtxt to do the actual parsing. Returns: Dict : Parameters needed by np.genfromtxt to parse the input file.","title":"TerraposResidualParser.setup_parser()"},{"location":"api/midgard-parsers/#terraposresidualparsersetup_postprocessors","text":"Full name: midgard.parsers.terrapos_residual.setup_postprocessors Signature: (self) -> List[Callable[[], NoneType]] List steps necessary for postprocessing","title":"TerraposResidualParser.setup_postprocessors()"},{"location":"api/midgard-parsers/#midgardparserstimeseries_env","text":"A parser for reading timeseries files in ENV format Example: from midgard import parsers p = parsers.parse_file(parser_name='timeseries_env', file_path='stas.env') data = p.as_dict() Description: Reads data from files timeseries files in ENV (east, north, vertical) format","title":"midgard.parsers.timeseries_env"},{"location":"api/midgard-parsers/#timeseriesenvparser","text":"Full name: midgard.parsers.timeseries_env.TimeseriesEnvParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading timeseries files in ENV format Following data are available after reading timeseries ENV file: Key Description date Date in format yyMMMdd (e.g. 18MAY10). year Date in unit year. east East coordinate in [mm]. east_sigma Standard devication of east coordinate in [mm]. north North coordinate in [mm]. north_sigma Standard devication of north coordinate in [mm]. vertical Vertical coordinate in [mm]. vertical_sigma Standard devication of vertical coordinate in [mm]. and meta -data: Key Description __data_path__ File path __params__ np.genfromtxt parameters __parser_name__ Parser name","title":"TimeseriesEnvParser"},{"location":"api/midgard-parsers/#timeseriesenvparseras_dataset","text":"Full name: midgard.parsers.timeseries_env.as_dataset Signature: (self, ref_pos)","title":"TimeseriesEnvParser.as_dataset()"},{"location":"api/midgard-parsers/#timeseriesenvparsersetup_parser","text":"Full name: midgard.parsers.timeseries_env.setup_parser Signature: (self) -> Dict[str, Any] Set up information needed for the parser This should return a dictionary with all parameters needed by np.genfromtxt to do the actual parsing. Returns: Dict : Parameters needed by np.genfromtxt to parse the input file.","title":"TimeseriesEnvParser.setup_parser()"},{"location":"api/midgard-parsers/#midgardparsersvlbi_source_names","text":"A parser for reading IVS source names translation table","title":"midgard.parsers.vlbi_source_names"},{"location":"api/midgard-parsers/#vlbisourcenamesparser","text":"Full name: midgard.parsers.vlbi_source_names.VlbiSourceNamesParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file","title":"VlbiSourceNamesParser"},{"location":"api/midgard-parsers/#vlbisourcenamesparsersetup_parser","text":"Full name: midgard.parsers.vlbi_source_names.setup_parser Signature: (self) -> Dict[str, Any] Set up information needed for the parser This should return a dictionary with all parameters needed by np.genfromtxt to do the actual parsing. Returns: Parameters needed by np.genfromtxt to parse the input file.","title":"VlbiSourceNamesParser.setup_parser()"},{"location":"api/midgard-parsers/#vlbisourcenamesparserstructure_data","text":"Full name: midgard.parsers.vlbi_source_names.structure_data Signature: (self) -> None Structure raw array data into the self.data dictionary Using the IVS name as key.","title":"VlbiSourceNamesParser.structure_data()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex","text":"A parser for reading Rinex files","title":"midgard.parsers.wip_rinex"},{"location":"api/midgard-parsers/#rinex","text":"Full name: midgard.parsers.wip_rinex.rinex Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on Rinex file type","title":"rinex()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex2_nav","text":"A parser for reading RINEX navigation files with version 2.xx","title":"midgard.parsers.wip_rinex2_nav"},{"location":"api/midgard-parsers/#rinex2navparser","text":"Full name: midgard.parsers.wip_rinex2_nav.Rinex2NavParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX navigation files with version 2.xx","title":"Rinex2NavParser"},{"location":"api/midgard-parsers/#rinex2navparsername-str","text":"name = 'Rinex'","title":"Rinex2NavParser.name (str)"},{"location":"api/midgard-parsers/#midgardparserswip_rinex2_obs","text":"A parser for reading RINEX observation files with version 2.xx","title":"midgard.parsers.wip_rinex2_obs"},{"location":"api/midgard-parsers/#rinex2obsparser","text":"Full name: midgard.parsers.wip_rinex2_obs.Rinex2ObsParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX observation files with version 2.xx","title":"Rinex2ObsParser"},{"location":"api/midgard-parsers/#rinex2obsparsername-str","text":"name = 'Rinex'","title":"Rinex2ObsParser.name (str)"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_nav","text":"A parser for reading RINEX navigation files with version 3.xx","title":"midgard.parsers.wip_rinex3_nav"},{"location":"api/midgard-parsers/#rinex3navparser","text":"Full name: midgard.parsers.wip_rinex3_nav.Rinex3NavParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX navigation files with version 3.xx","title":"Rinex3NavParser"},{"location":"api/midgard-parsers/#rinex3navparsername-str","text":"name = 'Rinex'","title":"Rinex3NavParser.name (str)"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_obs","text":"A parser for reading RINEX observation files with version 3.xx","title":"midgard.parsers.wip_rinex3_obs"},{"location":"api/midgard-parsers/#rinex3obsparser","text":"Full name: midgard.parsers.wip_rinex3_obs.Rinex3ObsParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX observation files with version 3.xx","title":"Rinex3ObsParser"},{"location":"api/midgard-parsers/#rinex3obsparserepoch_fields-dict","text":"EPOCH_FIELDS = {'identifier': (0, 1), 'year': (2, 6), 'month': (7, 9), 'day': (10, 12), 'hour': (13, 15), 'minute': (16, 18), 'second': (19, 21), 'frac_sec': (21, 29), 'epoch_flag': (30, 32), 'num_data_lines': (33, 35)}","title":"Rinex3ObsParser.EPOCH_FIELDS (dict)"},{"location":"api/midgard-parsers/#rinex3obsparseras_dataframe","text":"Full name: midgard.parsers.wip_rinex3_obs.as_dataframe Signature: (self, system:str, index:Union[str, List[str], NoneType]=None) -> pandas.core.frame.DataFrame Return the parsed data as a Pandas DataFrame This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: sys : Which system to create a datafrom for. index : Optional name of field to use as index. May also be a list of strings. Returns: Pandas DataFrame with the parsed data.","title":"Rinex3ObsParser.as_dataframe()"},{"location":"api/midgard-parsers/#rinex3obsparsername-str","text":"name = 'Rinex'","title":"Rinex3ObsParser.name (str)"},{"location":"api/midgard-parsers/#rinex3obsparserparse_data_lines","text":"Full name: midgard.parsers.wip_rinex3_obs.parse_data_lines Signature: (self, lines, epoch_info) -> Dict[str, Any] Read one section of data lines","title":"Rinex3ObsParser.parse_data_lines()"},{"location":"api/midgard-parsers/#rinex3obsparserparse_epoch_line","text":"Full name: midgard.parsers.wip_rinex3_obs.parse_epoch_line Signature: (self, line) -> Dict[str, Any] Read data from Rinex file Add data to self.data","title":"Rinex3ObsParser.parse_epoch_line()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex_clk","text":"A parser for reading Rinex navigation files","title":"midgard.parsers.wip_rinex_clk"},{"location":"api/midgard-parsers/#rinexclkparser","text":"Full name: midgard.parsers.wip_rinex_clk.RinexClkParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None Class for defining common methods for RINEX clock parsers.","title":"RinexClkParser"},{"location":"api/midgard-parsers/#rinexclkparsername-str","text":"name = 'Rinex'","title":"RinexClkParser.name (str)"},{"location":"api/midgard-parsers/#rinex_clk","text":"Full name: midgard.parsers.wip_rinex_clk.rinex_clk Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"rinex_clk()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex_nav","text":"A parser for reading Rinex navigation files","title":"midgard.parsers.wip_rinex_nav"},{"location":"api/midgard-parsers/#rinexnavparser","text":"Full name: midgard.parsers.wip_rinex_nav.RinexNavParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None Class for defining common methods for RINEX navigation parsers.","title":"RinexNavParser"},{"location":"api/midgard-parsers/#rinexnavparsername-str","text":"name = 'Rinex'","title":"RinexNavParser.name (str)"},{"location":"api/midgard-parsers/#rinex_nav","text":"Full name: midgard.parsers.wip_rinex_nav.rinex_nav Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"rinex_nav()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex_obs","text":"A parser for reading Rinex observation files","title":"midgard.parsers.wip_rinex_obs"},{"location":"api/midgard-parsers/#rinexobsparser","text":"Full name: midgard.parsers.wip_rinex_obs.RinexObsParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None Class for defining common methods for RINEX observation parsers.","title":"RinexObsParser"},{"location":"api/midgard-parsers/#rinexobsparsername-str","text":"name = 'Rinex'","title":"RinexObsParser.name (str)"},{"location":"api/midgard-parsers/#rinex_obs","text":"Full name: midgard.parsers.wip_rinex_obs.rinex_obs Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"rinex_obs()"},{"location":"api/midgard-plot/","text":"midgard.plot midgard.plot.matplotlib_extension get_statistic () Full name: midgard.plot.matplotlib_extension.get_statistic Signature: (data:'ndarray', funcs:List[str]=['rms', 'mean', 'std', 'min', 'max', 'percentile'], unit:str='') -> List[str] Get text string with statistical information List of statistical functions ( funcs ), which can be chosen: Function Description max Maximal value of data array min Minimal value of data array mean Mean value of data array percentile 95th percentile of data array rms Root mean square of data array std Standard deviation of data array Args: data: Array with data. funcs: List with statistical choices Returns: List with strings representing statistical information plot_scatter_subplot_row () Full name: midgard.plot.matplotlib_extension.plot_scatter_subplot_row Signature: (ax:'AxesSubplot', x_array:'ndarray', y_array:'ndarray', xlabel:str='', ylabel:str='', x_unit:str='', y_unit:str='', label:str='', color:Union[NoneType, _ForwardRef('ndarray')]=None, opt_args:Union[Dict[str, Any], NoneType]=None) -> None Generate single row of scatter subplot Example: Following options can be selected: Option Value Description alpha Blending values of markers (0: transparent, 1: opaque) fsize_subtitle Fontsize of subplot title (statistical information) marker <'.' '-'> markersize Marker size reg_line <True False> statistic Plot statistical information. Following function can be defined: 'max', 'mean', 'min', 'rms', 'std', 'percentile' (see function get_statistic for more information) Args: ax: Axes object needed for plotting subplot row. x_array: Array with x-axis data to plot. y_array: Array with y-axis data to plot. xlabel: X-axis label. ylabels: X-axis label. x_unit: X-axis unit. y_unit: Y-axis unit. label: Legend label. color: Marker color. opt_args: Dictionary with options, which overwrite default plot configuration. plot_scatter_subplots () Full name: midgard.plot.matplotlib_extension.plot_scatter_subplots Signature: (x_array:'ndarray', y_arrays:List[_ForwardRef('ndarray')], xlabel:str, ylabels:List[str], x_unit:str='', y_unit:str='', figure_path:str='plot_scatter_subplot.png', opt_args:Union[Dict[str, Any], NoneType]=None) -> None Generate scatter subplot The subplot has only one column. The number of rows is defined via the chosen number of y-axis data. Example: Following opt_arg options can be selected: Option Value Description dpi Resolution of file in dots per inch figsize (num, num) Figure size fsize_subtitle Fontsize of subplot title (statistical information) marker <'.' '-'> plot_to <console file> reg_line <True False> sharex <True False> sharey <True False> statistic Plot statistical information. Following function can be defined: 'max', 'mean', 'min', 'rms', 'std', 'percentile' (see function _get_statistic for more information) title Main title of subplots Args: x_array: Array with x-axis data to plot. y_arrays: List of arrays with y-axis data to plot. xlabel: X-axis label. ylabels: List with y-axis labels. It should corresponds to given number of y-axis arrays. x_unit: X-axis unit. y_unit: Y-axis unit. figure_path: Figure path. opt_args: Dictionary with options, which overwrite default plot configuration.","title":"midgard.plot"},{"location":"api/midgard-plot/#midgardplot","text":"","title":"midgard.plot"},{"location":"api/midgard-plot/#midgardplotmatplotlib_extension","text":"","title":"midgard.plot.matplotlib_extension"},{"location":"api/midgard-plot/#get_statistic","text":"Full name: midgard.plot.matplotlib_extension.get_statistic Signature: (data:'ndarray', funcs:List[str]=['rms', 'mean', 'std', 'min', 'max', 'percentile'], unit:str='') -> List[str] Get text string with statistical information List of statistical functions ( funcs ), which can be chosen: Function Description max Maximal value of data array min Minimal value of data array mean Mean value of data array percentile 95th percentile of data array rms Root mean square of data array std Standard deviation of data array Args: data: Array with data. funcs: List with statistical choices Returns: List with strings representing statistical information","title":"get_statistic()"},{"location":"api/midgard-plot/#plot_scatter_subplot_row","text":"Full name: midgard.plot.matplotlib_extension.plot_scatter_subplot_row Signature: (ax:'AxesSubplot', x_array:'ndarray', y_array:'ndarray', xlabel:str='', ylabel:str='', x_unit:str='', y_unit:str='', label:str='', color:Union[NoneType, _ForwardRef('ndarray')]=None, opt_args:Union[Dict[str, Any], NoneType]=None) -> None Generate single row of scatter subplot Example: Following options can be selected: Option Value Description alpha Blending values of markers (0: transparent, 1: opaque) fsize_subtitle Fontsize of subplot title (statistical information) marker <'.' '-'> markersize Marker size reg_line <True False> statistic Plot statistical information. Following function can be defined: 'max', 'mean', 'min', 'rms', 'std', 'percentile' (see function get_statistic for more information) Args: ax: Axes object needed for plotting subplot row. x_array: Array with x-axis data to plot. y_array: Array with y-axis data to plot. xlabel: X-axis label. ylabels: X-axis label. x_unit: X-axis unit. y_unit: Y-axis unit. label: Legend label. color: Marker color. opt_args: Dictionary with options, which overwrite default plot configuration.","title":"plot_scatter_subplot_row()"},{"location":"api/midgard-plot/#plot_scatter_subplots","text":"Full name: midgard.plot.matplotlib_extension.plot_scatter_subplots Signature: (x_array:'ndarray', y_arrays:List[_ForwardRef('ndarray')], xlabel:str, ylabels:List[str], x_unit:str='', y_unit:str='', figure_path:str='plot_scatter_subplot.png', opt_args:Union[Dict[str, Any], NoneType]=None) -> None Generate scatter subplot The subplot has only one column. The number of rows is defined via the chosen number of y-axis data. Example: Following opt_arg options can be selected: Option Value Description dpi Resolution of file in dots per inch figsize (num, num) Figure size fsize_subtitle Fontsize of subplot title (statistical information) marker <'.' '-'> plot_to <console file> reg_line <True False> sharex <True False> sharey <True False> statistic Plot statistical information. Following function can be defined: 'max', 'mean', 'min', 'rms', 'std', 'percentile' (see function _get_statistic for more information) title Main title of subplots Args: x_array: Array with x-axis data to plot. y_arrays: List of arrays with y-axis data to plot. xlabel: X-axis label. ylabels: List with y-axis labels. It should corresponds to given number of y-axis arrays. x_unit: X-axis unit. y_unit: Y-axis unit. figure_path: Figure path. opt_args: Dictionary with options, which overwrite default plot configuration.","title":"plot_scatter_subplots()"},{"location":"api/midgard-site_info/","text":"midgard.site_info midgard.site_info.antenna Antenna site information classes Description: The antenna module generates a antenna object based on site information from the SINEX file or other sources. Example for getting antenna object: from midgard.site_info import antenna antenna.Antenna.get(source=\"sinex\", station=\"ales\", date=datetime(2018, 10, 1)) Following steps are carried out for getting a antenna object: 1. Plugins modulen register AntennaHistory classes (e.g. AntennaHistorySinex) and updates the 'sources' attribute of the AntennaHistory class. 2. The Antenna object is initialized by calling the Antenna.get function. 3. The AntennaHistory.get function is called via the Antenna.get function. Here the correct AntennaHistory class is choosen by accessing the registered 'sources' attribute of the AntennaHistory class. 4. The AntennaBase.get function reads the antenna information via the _read_history() function of the AntennaHistorySinex or other calls. The antenna information is selected via a given date. Antenna Full name: midgard.site_info.antenna.Antenna Signature: () Main antenna class for getting antenna object depending on site information source The site information source can be e.g. a SINEX file. Antenna. get () Full name: midgard.site_info.antenna.get Signature: (source:str, station:str, date:datetime.datetime) -> Union[_ForwardRef('AntennaSinex'), Any] Get antenna object depending on given source Args: station : Station name. date : Date for getting site information source : Site information source e.g. 'sinex' (SINEX file) Returns: Antenna object Antenna.sources (dict) sources = {} AntennaBase Full name: midgard.site_info.antenna.AntennaBase Signature: (station:str, antenna_info:Dict[str, Any]) -> None Antenna base class defining common attributes and methods AntennaBase.fields (dict) fields = {'date_installed': 'date_installed', 'date_removed': 'date_removed', 'type': 'type', 'serial_number': 'serial_number', 'radome_type': 'radome_type', 'radome_serial_number': 'radome_serial_number'} AntennaBase.source (NoneType) source = None AntennaHistory Full name: midgard.site_info.antenna.AntennaHistory Signature: () AntennaHistory. date_installed () Full name: midgard.site_info.antenna.date_installed Signature: (source:str, station:str) -> List[datetime.datetime] Get all antenna installation dates for an given station Returns: List with antenna installation site dates AntennaHistory. date_removed () Full name: midgard.site_info.antenna.date_removed Signature: (source:str, station:str) -> List[datetime.datetime] Get all antenna removing dates for an given station Returns: List with antenna removing site dates AntennaHistory. get () Full name: midgard.site_info.antenna.get Signature: (source:str, station:str) -> Union[_ForwardRef('AntennaHistorySinex'), Any] Get antenna history class depending on given source Returns: Antenna history class depending on given source AntennaHistory. register_source () Full name: midgard.site_info.antenna.register_source Signature: (source_cls:Union[_ForwardRef('AntennaHistorySinex'), Any]) -> Union[_ForwardRef('AntennaHistorySinex'), Any] Register antenna history class in source attribute This routine is called via plugins module, which register existing antenna history classes (e.g. AntennaHistorySinex). Args: source_cls : Antenna history class Returns: Antenna history class AntennaHistory.sources (dict) sources = {'sinex': <class 'midgard.site_info.antenna.AntennaHistorySinex'>} AntennaHistoryBase Full name: midgard.site_info.antenna.AntennaHistoryBase Signature: (station:str) -> None Antenna history base class defining common attributes and methods AntennaHistoryBase. get () Full name: midgard.site_info.antenna.get Signature: (self, date:datetime.datetime) -> Union[_ForwardRef('AntennaSinex'), Any] Get antenna object for given date Args: date : Date for which antenna information is chosen Returns: Antenna object for given date AntennaHistoryBase.source (NoneType) source = None AntennaHistorySinex Full name: midgard.site_info.antenna.AntennaHistorySinex Signature: (station:str) -> None AntennaHistorySinex. get () Full name: midgard.site_info.antenna.get Signature: (self, date:datetime.datetime) -> Union[_ForwardRef('AntennaSinex'), Any] Get antenna object for given date Args: date : Date for which antenna information is chosen Returns: Antenna object for given date AntennaHistorySinex.source (str) source = 'sinex' AntennaSinex Full name: midgard.site_info.antenna.AntennaSinex Signature: (station:str, antenna_info:Dict[str, Any]) -> None Antenna class handling SINEX file antenna station information AntennaSinex.fields (dict) fields = {'type': 'antennaTypeName', 'serial_number': 'serialNumber', 'radome_type': 'radomeType', 'radome_serial_number': 'radomeSnr'} AntennaSinex.source (str) source = 'sinex'","title":"midgard.site_info"},{"location":"api/midgard-site_info/#midgardsite_info","text":"","title":"midgard.site_info"},{"location":"api/midgard-site_info/#midgardsite_infoantenna","text":"Antenna site information classes Description: The antenna module generates a antenna object based on site information from the SINEX file or other sources. Example for getting antenna object: from midgard.site_info import antenna antenna.Antenna.get(source=\"sinex\", station=\"ales\", date=datetime(2018, 10, 1)) Following steps are carried out for getting a antenna object: 1. Plugins modulen register AntennaHistory classes (e.g. AntennaHistorySinex) and updates the 'sources' attribute of the AntennaHistory class. 2. The Antenna object is initialized by calling the Antenna.get function. 3. The AntennaHistory.get function is called via the Antenna.get function. Here the correct AntennaHistory class is choosen by accessing the registered 'sources' attribute of the AntennaHistory class. 4. The AntennaBase.get function reads the antenna information via the _read_history() function of the AntennaHistorySinex or other calls. The antenna information is selected via a given date.","title":"midgard.site_info.antenna"},{"location":"api/midgard-site_info/#antenna","text":"Full name: midgard.site_info.antenna.Antenna Signature: () Main antenna class for getting antenna object depending on site information source The site information source can be e.g. a SINEX file.","title":"Antenna"},{"location":"api/midgard-site_info/#antennaget","text":"Full name: midgard.site_info.antenna.get Signature: (source:str, station:str, date:datetime.datetime) -> Union[_ForwardRef('AntennaSinex'), Any] Get antenna object depending on given source Args: station : Station name. date : Date for getting site information source : Site information source e.g. 'sinex' (SINEX file) Returns: Antenna object","title":"Antenna.get()"},{"location":"api/midgard-site_info/#antennasources-dict","text":"sources = {}","title":"Antenna.sources (dict)"},{"location":"api/midgard-site_info/#antennabase","text":"Full name: midgard.site_info.antenna.AntennaBase Signature: (station:str, antenna_info:Dict[str, Any]) -> None Antenna base class defining common attributes and methods","title":"AntennaBase"},{"location":"api/midgard-site_info/#antennabasefields-dict","text":"fields = {'date_installed': 'date_installed', 'date_removed': 'date_removed', 'type': 'type', 'serial_number': 'serial_number', 'radome_type': 'radome_type', 'radome_serial_number': 'radome_serial_number'}","title":"AntennaBase.fields (dict)"},{"location":"api/midgard-site_info/#antennabasesource-nonetype","text":"source = None","title":"AntennaBase.source (NoneType)"},{"location":"api/midgard-site_info/#antennahistory","text":"Full name: midgard.site_info.antenna.AntennaHistory Signature: ()","title":"AntennaHistory"},{"location":"api/midgard-site_info/#antennahistorydate_installed","text":"Full name: midgard.site_info.antenna.date_installed Signature: (source:str, station:str) -> List[datetime.datetime] Get all antenna installation dates for an given station Returns: List with antenna installation site dates","title":"AntennaHistory.date_installed()"},{"location":"api/midgard-site_info/#antennahistorydate_removed","text":"Full name: midgard.site_info.antenna.date_removed Signature: (source:str, station:str) -> List[datetime.datetime] Get all antenna removing dates for an given station Returns: List with antenna removing site dates","title":"AntennaHistory.date_removed()"},{"location":"api/midgard-site_info/#antennahistoryget","text":"Full name: midgard.site_info.antenna.get Signature: (source:str, station:str) -> Union[_ForwardRef('AntennaHistorySinex'), Any] Get antenna history class depending on given source Returns: Antenna history class depending on given source","title":"AntennaHistory.get()"},{"location":"api/midgard-site_info/#antennahistoryregister_source","text":"Full name: midgard.site_info.antenna.register_source Signature: (source_cls:Union[_ForwardRef('AntennaHistorySinex'), Any]) -> Union[_ForwardRef('AntennaHistorySinex'), Any] Register antenna history class in source attribute This routine is called via plugins module, which register existing antenna history classes (e.g. AntennaHistorySinex). Args: source_cls : Antenna history class Returns: Antenna history class","title":"AntennaHistory.register_source()"},{"location":"api/midgard-site_info/#antennahistorysources-dict","text":"sources = {'sinex': <class 'midgard.site_info.antenna.AntennaHistorySinex'>}","title":"AntennaHistory.sources (dict)"},{"location":"api/midgard-site_info/#antennahistorybase","text":"Full name: midgard.site_info.antenna.AntennaHistoryBase Signature: (station:str) -> None Antenna history base class defining common attributes and methods","title":"AntennaHistoryBase"},{"location":"api/midgard-site_info/#antennahistorybaseget","text":"Full name: midgard.site_info.antenna.get Signature: (self, date:datetime.datetime) -> Union[_ForwardRef('AntennaSinex'), Any] Get antenna object for given date Args: date : Date for which antenna information is chosen Returns: Antenna object for given date","title":"AntennaHistoryBase.get()"},{"location":"api/midgard-site_info/#antennahistorybasesource-nonetype","text":"source = None","title":"AntennaHistoryBase.source (NoneType)"},{"location":"api/midgard-site_info/#antennahistorysinex","text":"Full name: midgard.site_info.antenna.AntennaHistorySinex Signature: (station:str) -> None","title":"AntennaHistorySinex"},{"location":"api/midgard-site_info/#antennahistorysinexget","text":"Full name: midgard.site_info.antenna.get Signature: (self, date:datetime.datetime) -> Union[_ForwardRef('AntennaSinex'), Any] Get antenna object for given date Args: date : Date for which antenna information is chosen Returns: Antenna object for given date","title":"AntennaHistorySinex.get()"},{"location":"api/midgard-site_info/#antennahistorysinexsource-str","text":"source = 'sinex'","title":"AntennaHistorySinex.source (str)"},{"location":"api/midgard-site_info/#antennasinex","text":"Full name: midgard.site_info.antenna.AntennaSinex Signature: (station:str, antenna_info:Dict[str, Any]) -> None Antenna class handling SINEX file antenna station information","title":"AntennaSinex"},{"location":"api/midgard-site_info/#antennasinexfields-dict","text":"fields = {'type': 'antennaTypeName', 'serial_number': 'serialNumber', 'radome_type': 'radomeType', 'radome_serial_number': 'radomeSnr'}","title":"AntennaSinex.fields (dict)"},{"location":"api/midgard-site_info/#antennasinexsource-str","text":"source = 'sinex'","title":"AntennaSinex.source (str)"},{"location":"api/midgard-writers/","text":"midgard.writers Framework for writing output in different formats Description: Each output format / output destination should be defined in a separate .py-file. The function inside the .py-file that should be called need to be decorated with the :func: ~midgard.dev.plugins.register decorator as follows:: from midgard.dev import plugins @plugins.register def write_as_fancy_format(arg_1, arg_2): ... names () Full name: midgard.writers.names Signature: () -> List[str] List the names of the available writers Returns: List of strings with the names of the available writers. write () Full name: midgard.writers.write Signature: (writer:str, **writer_args:Any) -> None Call one writer Args: writer : Name of writer. writer_args : Arguments passed on to writer.","title":"midgard.writers"},{"location":"api/midgard-writers/#midgardwriters","text":"Framework for writing output in different formats Description: Each output format / output destination should be defined in a separate .py-file. The function inside the .py-file that should be called need to be decorated with the :func: ~midgard.dev.plugins.register decorator as follows:: from midgard.dev import plugins @plugins.register def write_as_fancy_format(arg_1, arg_2): ...","title":"midgard.writers"},{"location":"api/midgard-writers/#names","text":"Full name: midgard.writers.names Signature: () -> List[str] List the names of the available writers Returns: List of strings with the names of the available writers.","title":"names()"},{"location":"api/midgard-writers/#write","text":"Full name: midgard.writers.write Signature: (writer:str, **writer_args:Any) -> None Call one writer Args: writer : Name of writer. writer_args : Arguments passed on to writer.","title":"write()"},{"location":"api/midgard/","text":"midgard Midgard, the Python Geodesy library Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting. Midgard comes organized into different subpackages: data dev site_info files config ionosphere parsers math gnss writers plot collections Look for help inside each subpackage: >>> from midgard import subpackage # doctest: +SKIP >>> help(subpackage) # doctest: +SKIP Current maintainers: Michael D\u00e4hnn michael.daehnn@kartverket.no Ingrid Fausk ingrid.fausk@kartverket.no Ann-Silje Kirkvik ann-silje.kirkvik@kartverket.no Mohammed Ouassou mohammed.ouassou@kartverket.no Hans Sverre Smal\u00f8 hans.sverre.smalo@kartverket.no","title":"midgard"},{"location":"howto/testing/","text":"Testing It will be shortly described how the source code testing is done in Midgard. pytest is used by Midgard for testing the library modules. All module tests of Midgard are located in directory ./midgard/tests . The tests directory mirrors the official directory structure under ./midgard/midgard . For example the test for the modul ./midgard/midgard/math/interpolation.py can be found under ./midgard/tests/math/test_interpolation.py . In Midgard the test files follow the naming convention test_<module name>.py (e.g. test_interpolation.py ). Information about how to write pytest tests can be found under https://pytest.org/ . The written test can be excecuted as follows: All Midgard tests can be excecuted by calling make test in main directory ./midgard . If no arguments are specified pytest searches recursively after test_*.py files starting from the current directory. A single modul test can be carried out for example by pytest tests/ionosphere/test_klobuchar.py . An overview over passed and failed tests are given after excecuting pytest .","title":"Testing"},{"location":"howto/testing/#testing","text":"It will be shortly described how the source code testing is done in Midgard. pytest is used by Midgard for testing the library modules. All module tests of Midgard are located in directory ./midgard/tests . The tests directory mirrors the official directory structure under ./midgard/midgard . For example the test for the modul ./midgard/midgard/math/interpolation.py can be found under ./midgard/tests/math/test_interpolation.py . In Midgard the test files follow the naming convention test_<module name>.py (e.g. test_interpolation.py ). Information about how to write pytest tests can be found under https://pytest.org/ . The written test can be excecuted as follows: All Midgard tests can be excecuted by calling make test in main directory ./midgard . If no arguments are specified pytest searches recursively after test_*.py files starting from the current directory. A single modul test can be carried out for example by pytest tests/ionosphere/test_klobuchar.py . An overview over passed and failed tests are given after excecuting pytest .","title":"Testing"}]}