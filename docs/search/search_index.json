{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Midgard, the Python Geodesy library Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting. Installing Midgard Midgard is available at PyPI . You can install it by simply running pip install midgard Installing Midgard from source Midgard depends on several other brilliant Python packages, like for instance numpy, scipy, astropy etc. We recommend using the Anaconda distribution to ease the installation of these dependencies. Install Anaconda Go to www.anaconda.com/download , and download Anaconda for Python 3. Download the Midgard source code If you have not already done so, download the Midgard source code from Github: github.com/kartverket/midgard . Then enter the main midgard directory before running the install command below. cd midgard Install dependencies You should now install the necessary dependencies using the environment.yml -file. You can do this either in your current conda environment, or choose to create a new midgard -environment. In order to use midgard in other projects you need to install midgard in the same environment as those projects. To install midgard in your current environment, do conda env update -f environment.yml To install midgard in a new environment named midgard and activate it, do conda env create -n midgard -f environment.yml conda activate midgard Install the Midgard package To do the actual installation of Midgard, use the flit packaging tool: flit install --dep production If you want to develop the Midgard package, install it in editable mode using flit install -s On Windows, you can install in editable mode using flit install --pth-file Using Midgard Midgard comes organized into different subpackages. To see info about the different subpackages, use the Python help system: >>> import midgard >>> help(midgard)","title":"Home"},{"location":"#midgard-the-python-geodesy-library","text":"Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting.","title":"Midgard, the Python Geodesy library"},{"location":"#installing-midgard","text":"Midgard is available at PyPI . You can install it by simply running pip install midgard","title":"Installing Midgard"},{"location":"#installing-midgard-from-source","text":"Midgard depends on several other brilliant Python packages, like for instance numpy, scipy, astropy etc. We recommend using the Anaconda distribution to ease the installation of these dependencies.","title":"Installing Midgard from source"},{"location":"#install-anaconda","text":"Go to www.anaconda.com/download , and download Anaconda for Python 3.","title":"Install Anaconda"},{"location":"#download-the-midgard-source-code","text":"If you have not already done so, download the Midgard source code from Github: github.com/kartverket/midgard . Then enter the main midgard directory before running the install command below. cd midgard","title":"Download the Midgard source code"},{"location":"#install-dependencies","text":"You should now install the necessary dependencies using the environment.yml -file. You can do this either in your current conda environment, or choose to create a new midgard -environment. In order to use midgard in other projects you need to install midgard in the same environment as those projects. To install midgard in your current environment, do conda env update -f environment.yml To install midgard in a new environment named midgard and activate it, do conda env create -n midgard -f environment.yml conda activate midgard","title":"Install dependencies"},{"location":"#install-the-midgard-package","text":"To do the actual installation of Midgard, use the flit packaging tool: flit install --dep production If you want to develop the Midgard package, install it in editable mode using flit install -s On Windows, you can install in editable mode using flit install --pth-file","title":"Install the Midgard package"},{"location":"#using-midgard","text":"Midgard comes organized into different subpackages. To see info about the different subpackages, use the Python help system: >>> import midgard >>> help(midgard)","title":"Using Midgard"},{"location":"api/midgard-collections-dataset-dataset/","text":"midgard.collections.dataset.dataset","title":"midgard.collections.dataset.dataset"},{"location":"api/midgard-collections-dataset-dataset/#midgardcollectionsdatasetdataset","text":"","title":"midgard.collections.dataset.dataset"},{"location":"api/midgard-collections-dataset-table/","text":"midgard.collections.dataset.table","title":"midgard.collections.dataset.table"},{"location":"api/midgard-collections-dataset-table/#midgardcollectionsdatasettable","text":"","title":"midgard.collections.dataset.table"},{"location":"api/midgard-collections-dataset/","text":"midgard.collections.dataset","title":"midgard.collections.dataset"},{"location":"api/midgard-collections-dataset/#midgardcollectionsdataset","text":"","title":"midgard.collections.dataset"},{"location":"api/midgard-collections-enums/","text":"midgard.collections.enums Framework for working with enumerations Description: Custom enumerations used for structured names. LogLevel LogLevel(value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show LogLevel.all (LogLevel) all = <LogLevel.all: 1> LogLevel.check (LogLevel) check = <LogLevel.check: 7> LogLevel.debug (LogLevel) debug = <LogLevel.debug: 2> LogLevel.dev (LogLevel) dev = <LogLevel.dev: 4> LogLevel.error (LogLevel) error = <LogLevel.error: 8> LogLevel.fatal (LogLevel) fatal = <LogLevel.fatal: 9> LogLevel.info (LogLevel) info = <LogLevel.info: 5> LogLevel.none (LogLevel) none = <LogLevel.none: 10> LogLevel.time (LogLevel) time = <LogLevel.time: 3> LogLevel.warn (LogLevel) warn = <LogLevel.warn: 6> enums() enums() -> List[str] Return a list of available enums Returns: Names of available enums. get_enum() get_enum(name:str) -> enum.EnumMeta Return a named Enumeration Names are defined by the @register_enum-decorator. If the name-parameter is not a valid enum, the function will raise an UnknownEnumError and list the available enumerations. Args: name : Name used for Enumeration. Returns: Enumeration with the given name. get_value() get_value(name:str, value:str) -> enum.Enum Return the value of a named Enumeration Names are defined by the @register_enum-decorator. Args: name : Name used for Enumeration. value : Value of Enumeration. Returns: Value of enumeration with the given name. register_enum() register_enum(name:str) -> Callable[[enum.EnumMeta], enum.EnumMeta] Register a named Enumeration This allows for getting Enumerations with the get_enum-function. Args: name : Name used for Enumeration. Returns: Decorator that registers an Enumeration.","title":"midgard.collections.enums"},{"location":"api/midgard-collections-enums/#midgardcollectionsenums","text":"Framework for working with enumerations Description: Custom enumerations used for structured names.","title":"midgard.collections.enums"},{"location":"api/midgard-collections-enums/#loglevel","text":"LogLevel(value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show","title":"LogLevel"},{"location":"api/midgard-collections-enums/#loglevelall-loglevel","text":"all = <LogLevel.all: 1>","title":"LogLevel.all (LogLevel)"},{"location":"api/midgard-collections-enums/#loglevelcheck-loglevel","text":"check = <LogLevel.check: 7>","title":"LogLevel.check (LogLevel)"},{"location":"api/midgard-collections-enums/#logleveldebug-loglevel","text":"debug = <LogLevel.debug: 2>","title":"LogLevel.debug (LogLevel)"},{"location":"api/midgard-collections-enums/#logleveldev-loglevel","text":"dev = <LogLevel.dev: 4>","title":"LogLevel.dev (LogLevel)"},{"location":"api/midgard-collections-enums/#loglevelerror-loglevel","text":"error = <LogLevel.error: 8>","title":"LogLevel.error (LogLevel)"},{"location":"api/midgard-collections-enums/#loglevelfatal-loglevel","text":"fatal = <LogLevel.fatal: 9>","title":"LogLevel.fatal (LogLevel)"},{"location":"api/midgard-collections-enums/#loglevelinfo-loglevel","text":"info = <LogLevel.info: 5>","title":"LogLevel.info (LogLevel)"},{"location":"api/midgard-collections-enums/#loglevelnone-loglevel","text":"none = <LogLevel.none: 10>","title":"LogLevel.none (LogLevel)"},{"location":"api/midgard-collections-enums/#logleveltime-loglevel","text":"time = <LogLevel.time: 3>","title":"LogLevel.time (LogLevel)"},{"location":"api/midgard-collections-enums/#loglevelwarn-loglevel","text":"warn = <LogLevel.warn: 6>","title":"LogLevel.warn (LogLevel)"},{"location":"api/midgard-collections-enums/#enums","text":"enums() -> List[str] Return a list of available enums Returns: Names of available enums.","title":"enums()"},{"location":"api/midgard-collections-enums/#get_enum","text":"get_enum(name:str) -> enum.EnumMeta Return a named Enumeration Names are defined by the @register_enum-decorator. If the name-parameter is not a valid enum, the function will raise an UnknownEnumError and list the available enumerations. Args: name : Name used for Enumeration. Returns: Enumeration with the given name.","title":"get_enum()"},{"location":"api/midgard-collections-enums/#get_value","text":"get_value(name:str, value:str) -> enum.Enum Return the value of a named Enumeration Names are defined by the @register_enum-decorator. Args: name : Name used for Enumeration. value : Value of Enumeration. Returns: Value of enumeration with the given name.","title":"get_value()"},{"location":"api/midgard-collections-enums/#register_enum","text":"register_enum(name:str) -> Callable[[enum.EnumMeta], enum.EnumMeta] Register a named Enumeration This allows for getting Enumerations with the get_enum-function. Args: name : Name used for Enumeration. Returns: Decorator that registers an Enumeration.","title":"register_enum()"},{"location":"api/midgard-collections/","text":"midgard.collections","title":"midgard.collections"},{"location":"api/midgard-collections/#midgardcollections","text":"","title":"midgard.collections"},{"location":"api/midgard-config-config/","text":"midgard.config.config Midgard library module for handling of configuration settings Description: A Configuration consists of one or several sections. Each ConfigurationSection consists of one or more entries. Each ConfigurationEntry consists of a key and a value. Examples: For basic use, an entry is looked up by simple attribute access. For instance if cfg is a Configuration with the section midgard which has an entry foo = bar : >>> cfg = Configuration(\"config_name\") >>> cfg.update(\"midgard\", \"foo\", \"bar\") >>> cfg.midgard.foo ConfigurationEntry(key='foo', value='bar') ConfigurationEntry has several access methods that convert the entry to a given data type: >>> cfg.update(\"midgard\", \"foo_pi\", 3.14, source=\"command line\") >>> cfg.midgard.foo_pi ConfigurationEntry(key='foo_pi', value='3.14') >>> cfg.midgard.foo_pi.float 3.14 >>> cfg.midgard.foo_pi.str '3.14' >>> cfg.midgard.foo_pi.tuple ('3.14',) Sources: Each configuration entry records its source. That is, where that entry was defined. Examples include read from file, set as a command line option, or programmatically from a dictionary. The source can be looked up on an individual entry, or for all entries in a configuration. >>> cfg.midgard.foo_pi.source 'command line' >>> cfg.sources # doctest: +SKIP {'/home/midgard/midgard.conf', 'command line'} Profiles: Fallback Configuration: Master Section: Replacement Variables: Help text and Type hints: CasedConfigParser CasedConfigParser(defaults=None, dict_type=<class 'collections.OrderedDict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x7f83b54f71a0>, converters=<object object at 0x7f83b54f71a0>) ConfigParser with case-sensitive keys CasedConfigParser.BOOLEAN_STATES (dict) BOOLEAN_STATES = {'1': True, 'yes': True, 'true': True, 'on': True, '0': False, 'no': False, 'false': False, 'off': False} CasedConfigParser.NONSPACECRE (SRE_Pattern) NONSPACECRE = re.compile('\\\\S') CasedConfigParser.OPTCRE (SRE_Pattern) OPTCRE = re.compile('\\n (?P<option>.*?) # very permissive!\\n \\\\s*(?P<vi>=|:)\\\\s* # any number of space/tab,\\n # followed by any of t, re.VERBOSE) CasedConfigParser.OPTCRE_NV (SRE_Pattern) OPTCRE_NV = re.compile('\\n (?P<option>.*?) # very permissive!\\n \\\\s*(?: # any number of space/tab,\\n (?P<vi>=|:)\\\\s* # optionally followed , re.VERBOSE) CasedConfigParser.SECTCRE (SRE_Pattern) SECTCRE = re.compile('\\n \\\\[ # [\\n (?P<header>[^]]+) # very permissive!\\n \\\\] # ]\\n ', re.VERBOSE) CasedConfigParser.optionxform() optionxform(self, optionstr:str) -> str Do not turn optionstr (key) into lowercase Configuration Configuration(name:str) -> None Represents a Configuration Configuration.as_dict() as_dict(self, getters:Union[Dict[str, Dict[str, str]], NoneType]=None, default_getter:str='str') -> Dict[str, Dict[str, Any]] The configuration represented as a dictionary Args: getters : How to get the value of each entry in each section. default_getter : How to get the value of entries not specified in getters. Returns: Representation of the configuration as a nested dictionary. Configuration.as_str() as_str(self, width:Union[int, NoneType]=None, key_width:int=30, only_used:bool=False, metadata:bool=True) -> str The configuration represented as a string This is simililar to what is shown by str(configuration) (and implemented by __str__ ), but has more flexibility. Args: width : Width of text for wrapping. Default is width of console. key_width : Width of the key column. Default is 30 characters. only_used : Only include configuration entries that has been used so far. metadata : Include metadata like type and help text. Returns: String representation of the configuration. Configuration.clear() clear(self) -> None Clear the configuration Configuration.clear_vars() clear_vars(self) -> None Clear the configuration variables Configuration.get() get(self, key:str, value:Union[str, NoneType]=None, section:Union[str, NoneType]=None, default:Union[str, NoneType]=None) -> 'ConfigurationEntry' Get an entry from a configuration with possibility for override and default value A value for an entry is found using the following priorities: 1. An explicit value given in `value`. None is used as a marker for no value. 2. Looked up in the current configuration. 3. Looked up in any fallback confiurations that are defined. 4. The default value is used. If value is not None, that value is simply returned as a ConfigurationEntry . If default is not given (is None), and a value is not found in any other way, a MissingEntryError is raised. Args: key : Name of option (key in the configuration entry). value : Value of entry. Used for overriding the configuration. section : Section in the configuration in which to look up the key. default : Default value that is returned if value is not found any other way. Returns: Entry representing the value. Configuration.read_from_file() read_from_file(cfg_name:str, *file_paths:Union[str, pathlib.Path]) -> 'Configuration' Read a configuration from one or more files Args: file_paths : File(s) that will be read. Returns: A Configuration representing the file(s). Configuration.update() update(self, section:str, key:str, value:str, *, profile:Union[str, NoneType]=None, source:str='unknown', meta:Union[Dict[str, str], NoneType]=None, allow_new:bool=True, _update_sections:bool=True) -> None Update a configuration section with a configuration entry If allow_new is False, the configuration entry must already exist. If it is True the update is allowed to create a new section and a new entry is necessary. The _update_sections flag can be used to not update the sections of the configuration, only the profiles. This should typically not be done, but is used by some of the other update methods which update the sections themselves. Args: section : Section to update. key : Key of entry. value : Value of entry. profile : Profile to update. source : Source of the update. meta : Metadata like help text and type hints for the entry. allow_new : Whether to allow the creation of a new section and entry. Configuration.update_from_config_section() update_from_config_section(self, other_section:'ConfigurationSection', section:Union[str, NoneType]=None, allow_new:bool=True) -> None Configuration.update_from_dict() update_from_dict(self, cfg_dict:Dict[str, Any], section:Union[str, NoneType]=None, source:str='dictionary', allow_new:bool=True) -> None Configuration.update_from_file() update_from_file(self, file_path:Union[str, pathlib.Path], allow_new:bool=True, interpolate:bool=False, case_sensitive:bool=False) -> None Update the configuration from a configuration file The Python ConfigParser is used to read the file. The file format that is supported is described at https://docs.python.org/library/configparser.html Different profiles in a configuration file is denoted by double underscores in the sections names. For instance does the following configuration have a foo profile in the spam section (in addition to the default profile): [spam] ... [spam__foo] ... If interpolate is set to True, ExtendedInterpolation of variables in the configuration file is used. See https://docs.python.org/library/configparser.html#configparser.ExtendedInterpolation for details. Args: file_path : Path to the configuration file. allow_new : Whether to allow the creation of new sections and entries. interpolate : Whether to interpolate variables in the configuration file. case_sensitive : Whether to read keys as case sensitive (or convert to lower case). Configuration.update_from_options() update_from_options(self, options:Union[List[str], NoneType]=None, profile:Union[str, NoneType]=None, source:str='command line', allow_new:bool=False) -> None Configuration.update_on_file() update_on_file(file_path:Union[str, pathlib.Path], **as_str_args:Any) -> Generator Context manager for updating a configuration on file Configuration.update_vars() update_vars(self, new_vars:Dict[str, Any]) -> None Update the configuration variables Configuration.write_to_file() write_to_file(self, file_path:Union[str, pathlib.Path], **as_str_args:Any) -> None Write the configuration to a file In addition to the file path, arguments can be specified and will be passed on to the as_str() function. See as_str() for more information. Todo: Use files.open_path ConfigurationEntry ConfigurationEntry(key:str, value:Any, *, source:str='', meta:Union[Dict[str, str], NoneType]=None, vars_dict:Union[Dict[str, Any], NoneType]=None, _used_as:Union[Set[str], NoneType]=None) -> None ConfigurationEntry.as_bool() as_bool(self) -> bool Value of ConfigurationEntry converted to a boolean The conversion is done by looking up the string value of the entry in _BOOLEAN_STATES. ConfigurationEntry.as_date() as_date(self, format:str='%Y-%m-%d') -> datetime.date Value of ConfigurationEntry converted to a date object Args: format (String): Format string, see strftime for information about the string. Returns: Date : Value of entry. ConfigurationEntry.as_datetime() as_datetime(self, format:str='%Y-%m-%d %H:%M:%S') -> datetime.datetime Value of ConfigurationEntry converted to a datetime object Args: format (String): Format string, see strftime for information about the string. Returns: Datetime : Value of entry. ConfigurationEntry.as_dict() as_dict(self, item_split_re:str='[\\\\s,]', key_value_split_re:str='[:]', convert:Callable=<class 'str'>, maxsplit:int=0) -> Dict[str, Any] Value of ConfigurationEntry converted to a dictionary By default the dictionary is created by splitting items at commas and whitespace, and key from value at colons. Args: item_split_re : Regular expression used to split entry into items. key_value_split_re : Regular expression used to split items into keys and values. convert : Function used to convert each value in the dictionary. maxsplit : If nonzero, at most maxsplit splits occur when splitting entry into items. Returns: Value of entry as dict. ConfigurationEntry.as_enum() as_enum(self, enum:str) -> enum.Enum Value of ConfigurationEntry converted to an enumeration Args: enum (String): Name of Enum. Returns: Enum : Value of entry as Enum. ConfigurationEntry.as_float() as_float(self) -> float Value of ConfigurationEntry converted to a float ConfigurationEntry.as_int() as_int(self) -> int Value of ConfigurationEntry converted to an integer ConfigurationEntry.as_list() as_list(self, split_re:str='[\\\\s,]', convert:Callable=<class 'str'>, maxsplit:int=0) -> List[Any] Value of ConfigurationEntry converted to a list The entry is converted to a list by using the split_re -regular expression. By default the entry will be split at commas and whitespace. Args: split_re : Regular expression used to split entry into list. convert : Function used to convert each element of the list. maxsplit : If nonzero, at most maxsplit splits occur. Returns: Value of entry as list. ConfigurationEntry.as_list_of_lists() as_list_of_lists(self, split_res:Tuple[str, ...]=('[\\\\s,]', '[^_\\\\w]'), num_elements:Union[int, NoneType]=None, convert:Callable=<class 'str'>) -> List[List[Any]] ConfigurationEntry.as_path() as_path(self) -> pathlib.Path Value of ConfigurationEntry interpreted as a path string ConfigurationEntry.as_str() as_str(self) -> str Value of ConfigurationEntry as string ConfigurationEntry.as_tuple() as_tuple(self, split_re:str='[\\\\s,]', convert:Callable=<class 'str'>, maxsplit:int=0) -> Tuple[Any, ...] Value of ConfigurationEntry converted to a tuple The entry is converted to a tuple by using the split_re -regular expression. By default the entry will be split at commas and whitespace. Args: split_re : Regular expression used to split entry into tuple. convert : Function used to convert each element of the tuple. maxsplit : If nonzero, at most maxsplit splits occur. Returns: Value of entry as tuple. ConfigurationEntry.entry_as_str() entry_as_str(self, width:Union[int, NoneType]=None, key_width:int=30, metadata:bool=True) -> str The configuration entry represented as a string This is simililar to what is shown by str(entry) (and implemented by __str__ ), but has more flexibility. Args: width : Width of text for wrapping. Default is width of console. key_width : Width of the key column. Default is 30 characters. metadata : Include metadata like type and help text. Returns: String representation of the configuration entry. ConfigurationEntry.replace() replace(self, default:Union[str, NoneType]=None, **replace_vars:str) -> 'ConfigurationEntry' ConfigurationSection ConfigurationSection(name:str) -> None ConfigurationSection.as_dict() as_dict(self, getters:Dict[str, str]=None, default_getter:str='str') -> Dict[str, Any] The configuration section represented as a dictionary Args: getters : How to get the value of each entry in the section. default_getter : How to get the value of entries not specified in getters. Returns: Representation of the configuration section as a dictionary. ConfigurationSection.as_list() as_list(self) -> List[str] List of keys of entries in configuration section Returns: List of keys of entries in configuration section. ConfigurationSection.as_str() as_str(self, width:Union[int, NoneType]=None, key_width:int=30, only_used:bool=False, metadata:bool=True) -> str The configuration section represented as a string This is simililar to what is shown by str(section) (and implemented by __str__ ), but has more flexibility. Args: width : Width of text for wrapping. Default is width of console. key_width : Width of the key column. Default is 30 characters. only_used : Only include configuration entries that has been used so far. metadata : Include metadata like type and help text. Returns: String representation of the configuration section. FMT_date (str) FMT_date = '%Y-%m-%d' FMT_datetime (str) FMT_datetime = '%Y-%m-%d %H:%M:%S' FMT_dt_file (str) FMT_dt_file = '%Y%m%d-%H%M%S'","title":"midgard.config.config"},{"location":"api/midgard-config-config/#midgardconfigconfig","text":"Midgard library module for handling of configuration settings Description: A Configuration consists of one or several sections. Each ConfigurationSection consists of one or more entries. Each ConfigurationEntry consists of a key and a value. Examples: For basic use, an entry is looked up by simple attribute access. For instance if cfg is a Configuration with the section midgard which has an entry foo = bar : >>> cfg = Configuration(\"config_name\") >>> cfg.update(\"midgard\", \"foo\", \"bar\") >>> cfg.midgard.foo ConfigurationEntry(key='foo', value='bar') ConfigurationEntry has several access methods that convert the entry to a given data type: >>> cfg.update(\"midgard\", \"foo_pi\", 3.14, source=\"command line\") >>> cfg.midgard.foo_pi ConfigurationEntry(key='foo_pi', value='3.14') >>> cfg.midgard.foo_pi.float 3.14 >>> cfg.midgard.foo_pi.str '3.14' >>> cfg.midgard.foo_pi.tuple ('3.14',) Sources: Each configuration entry records its source. That is, where that entry was defined. Examples include read from file, set as a command line option, or programmatically from a dictionary. The source can be looked up on an individual entry, or for all entries in a configuration. >>> cfg.midgard.foo_pi.source 'command line' >>> cfg.sources # doctest: +SKIP {'/home/midgard/midgard.conf', 'command line'} Profiles: Fallback Configuration: Master Section: Replacement Variables: Help text and Type hints:","title":"midgard.config.config"},{"location":"api/midgard-config-config/#casedconfigparser","text":"CasedConfigParser(defaults=None, dict_type=<class 'collections.OrderedDict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x7f83b54f71a0>, converters=<object object at 0x7f83b54f71a0>) ConfigParser with case-sensitive keys","title":"CasedConfigParser"},{"location":"api/midgard-config-config/#casedconfigparserboolean_states-dict","text":"BOOLEAN_STATES = {'1': True, 'yes': True, 'true': True, 'on': True, '0': False, 'no': False, 'false': False, 'off': False}","title":"CasedConfigParser.BOOLEAN_STATES (dict)"},{"location":"api/midgard-config-config/#casedconfigparsernonspacecre-sre_pattern","text":"NONSPACECRE = re.compile('\\\\S')","title":"CasedConfigParser.NONSPACECRE (SRE_Pattern)"},{"location":"api/midgard-config-config/#casedconfigparseroptcre-sre_pattern","text":"OPTCRE = re.compile('\\n (?P<option>.*?) # very permissive!\\n \\\\s*(?P<vi>=|:)\\\\s* # any number of space/tab,\\n # followed by any of t, re.VERBOSE)","title":"CasedConfigParser.OPTCRE (SRE_Pattern)"},{"location":"api/midgard-config-config/#casedconfigparseroptcre_nv-sre_pattern","text":"OPTCRE_NV = re.compile('\\n (?P<option>.*?) # very permissive!\\n \\\\s*(?: # any number of space/tab,\\n (?P<vi>=|:)\\\\s* # optionally followed , re.VERBOSE)","title":"CasedConfigParser.OPTCRE_NV (SRE_Pattern)"},{"location":"api/midgard-config-config/#casedconfigparsersectcre-sre_pattern","text":"SECTCRE = re.compile('\\n \\\\[ # [\\n (?P<header>[^]]+) # very permissive!\\n \\\\] # ]\\n ', re.VERBOSE)","title":"CasedConfigParser.SECTCRE (SRE_Pattern)"},{"location":"api/midgard-config-config/#casedconfigparseroptionxform","text":"optionxform(self, optionstr:str) -> str Do not turn optionstr (key) into lowercase","title":"CasedConfigParser.optionxform()"},{"location":"api/midgard-config-config/#configuration","text":"Configuration(name:str) -> None Represents a Configuration","title":"Configuration"},{"location":"api/midgard-config-config/#configurationas_dict","text":"as_dict(self, getters:Union[Dict[str, Dict[str, str]], NoneType]=None, default_getter:str='str') -> Dict[str, Dict[str, Any]] The configuration represented as a dictionary Args: getters : How to get the value of each entry in each section. default_getter : How to get the value of entries not specified in getters. Returns: Representation of the configuration as a nested dictionary.","title":"Configuration.as_dict()"},{"location":"api/midgard-config-config/#configurationas_str","text":"as_str(self, width:Union[int, NoneType]=None, key_width:int=30, only_used:bool=False, metadata:bool=True) -> str The configuration represented as a string This is simililar to what is shown by str(configuration) (and implemented by __str__ ), but has more flexibility. Args: width : Width of text for wrapping. Default is width of console. key_width : Width of the key column. Default is 30 characters. only_used : Only include configuration entries that has been used so far. metadata : Include metadata like type and help text. Returns: String representation of the configuration.","title":"Configuration.as_str()"},{"location":"api/midgard-config-config/#configurationclear","text":"clear(self) -> None Clear the configuration","title":"Configuration.clear()"},{"location":"api/midgard-config-config/#configurationclear_vars","text":"clear_vars(self) -> None Clear the configuration variables","title":"Configuration.clear_vars()"},{"location":"api/midgard-config-config/#configurationget","text":"get(self, key:str, value:Union[str, NoneType]=None, section:Union[str, NoneType]=None, default:Union[str, NoneType]=None) -> 'ConfigurationEntry' Get an entry from a configuration with possibility for override and default value A value for an entry is found using the following priorities: 1. An explicit value given in `value`. None is used as a marker for no value. 2. Looked up in the current configuration. 3. Looked up in any fallback confiurations that are defined. 4. The default value is used. If value is not None, that value is simply returned as a ConfigurationEntry . If default is not given (is None), and a value is not found in any other way, a MissingEntryError is raised. Args: key : Name of option (key in the configuration entry). value : Value of entry. Used for overriding the configuration. section : Section in the configuration in which to look up the key. default : Default value that is returned if value is not found any other way. Returns: Entry representing the value.","title":"Configuration.get()"},{"location":"api/midgard-config-config/#configurationread_from_file","text":"read_from_file(cfg_name:str, *file_paths:Union[str, pathlib.Path]) -> 'Configuration' Read a configuration from one or more files Args: file_paths : File(s) that will be read. Returns: A Configuration representing the file(s).","title":"Configuration.read_from_file()"},{"location":"api/midgard-config-config/#configurationupdate","text":"update(self, section:str, key:str, value:str, *, profile:Union[str, NoneType]=None, source:str='unknown', meta:Union[Dict[str, str], NoneType]=None, allow_new:bool=True, _update_sections:bool=True) -> None Update a configuration section with a configuration entry If allow_new is False, the configuration entry must already exist. If it is True the update is allowed to create a new section and a new entry is necessary. The _update_sections flag can be used to not update the sections of the configuration, only the profiles. This should typically not be done, but is used by some of the other update methods which update the sections themselves. Args: section : Section to update. key : Key of entry. value : Value of entry. profile : Profile to update. source : Source of the update. meta : Metadata like help text and type hints for the entry. allow_new : Whether to allow the creation of a new section and entry.","title":"Configuration.update()"},{"location":"api/midgard-config-config/#configurationupdate_from_config_section","text":"update_from_config_section(self, other_section:'ConfigurationSection', section:Union[str, NoneType]=None, allow_new:bool=True) -> None","title":"Configuration.update_from_config_section()"},{"location":"api/midgard-config-config/#configurationupdate_from_dict","text":"update_from_dict(self, cfg_dict:Dict[str, Any], section:Union[str, NoneType]=None, source:str='dictionary', allow_new:bool=True) -> None","title":"Configuration.update_from_dict()"},{"location":"api/midgard-config-config/#configurationupdate_from_file","text":"update_from_file(self, file_path:Union[str, pathlib.Path], allow_new:bool=True, interpolate:bool=False, case_sensitive:bool=False) -> None Update the configuration from a configuration file The Python ConfigParser is used to read the file. The file format that is supported is described at https://docs.python.org/library/configparser.html Different profiles in a configuration file is denoted by double underscores in the sections names. For instance does the following configuration have a foo profile in the spam section (in addition to the default profile): [spam] ... [spam__foo] ... If interpolate is set to True, ExtendedInterpolation of variables in the configuration file is used. See https://docs.python.org/library/configparser.html#configparser.ExtendedInterpolation for details. Args: file_path : Path to the configuration file. allow_new : Whether to allow the creation of new sections and entries. interpolate : Whether to interpolate variables in the configuration file. case_sensitive : Whether to read keys as case sensitive (or convert to lower case).","title":"Configuration.update_from_file()"},{"location":"api/midgard-config-config/#configurationupdate_from_options","text":"update_from_options(self, options:Union[List[str], NoneType]=None, profile:Union[str, NoneType]=None, source:str='command line', allow_new:bool=False) -> None","title":"Configuration.update_from_options()"},{"location":"api/midgard-config-config/#configurationupdate_on_file","text":"update_on_file(file_path:Union[str, pathlib.Path], **as_str_args:Any) -> Generator Context manager for updating a configuration on file","title":"Configuration.update_on_file()"},{"location":"api/midgard-config-config/#configurationupdate_vars","text":"update_vars(self, new_vars:Dict[str, Any]) -> None Update the configuration variables","title":"Configuration.update_vars()"},{"location":"api/midgard-config-config/#configurationwrite_to_file","text":"write_to_file(self, file_path:Union[str, pathlib.Path], **as_str_args:Any) -> None Write the configuration to a file In addition to the file path, arguments can be specified and will be passed on to the as_str() function. See as_str() for more information. Todo: Use files.open_path","title":"Configuration.write_to_file()"},{"location":"api/midgard-config-config/#configurationentry","text":"ConfigurationEntry(key:str, value:Any, *, source:str='', meta:Union[Dict[str, str], NoneType]=None, vars_dict:Union[Dict[str, Any], NoneType]=None, _used_as:Union[Set[str], NoneType]=None) -> None","title":"ConfigurationEntry"},{"location":"api/midgard-config-config/#configurationentryas_bool","text":"as_bool(self) -> bool Value of ConfigurationEntry converted to a boolean The conversion is done by looking up the string value of the entry in _BOOLEAN_STATES.","title":"ConfigurationEntry.as_bool()"},{"location":"api/midgard-config-config/#configurationentryas_date","text":"as_date(self, format:str='%Y-%m-%d') -> datetime.date Value of ConfigurationEntry converted to a date object Args: format (String): Format string, see strftime for information about the string. Returns: Date : Value of entry.","title":"ConfigurationEntry.as_date()"},{"location":"api/midgard-config-config/#configurationentryas_datetime","text":"as_datetime(self, format:str='%Y-%m-%d %H:%M:%S') -> datetime.datetime Value of ConfigurationEntry converted to a datetime object Args: format (String): Format string, see strftime for information about the string. Returns: Datetime : Value of entry.","title":"ConfigurationEntry.as_datetime()"},{"location":"api/midgard-config-config/#configurationentryas_dict","text":"as_dict(self, item_split_re:str='[\\\\s,]', key_value_split_re:str='[:]', convert:Callable=<class 'str'>, maxsplit:int=0) -> Dict[str, Any] Value of ConfigurationEntry converted to a dictionary By default the dictionary is created by splitting items at commas and whitespace, and key from value at colons. Args: item_split_re : Regular expression used to split entry into items. key_value_split_re : Regular expression used to split items into keys and values. convert : Function used to convert each value in the dictionary. maxsplit : If nonzero, at most maxsplit splits occur when splitting entry into items. Returns: Value of entry as dict.","title":"ConfigurationEntry.as_dict()"},{"location":"api/midgard-config-config/#configurationentryas_enum","text":"as_enum(self, enum:str) -> enum.Enum Value of ConfigurationEntry converted to an enumeration Args: enum (String): Name of Enum. Returns: Enum : Value of entry as Enum.","title":"ConfigurationEntry.as_enum()"},{"location":"api/midgard-config-config/#configurationentryas_float","text":"as_float(self) -> float Value of ConfigurationEntry converted to a float","title":"ConfigurationEntry.as_float()"},{"location":"api/midgard-config-config/#configurationentryas_int","text":"as_int(self) -> int Value of ConfigurationEntry converted to an integer","title":"ConfigurationEntry.as_int()"},{"location":"api/midgard-config-config/#configurationentryas_list","text":"as_list(self, split_re:str='[\\\\s,]', convert:Callable=<class 'str'>, maxsplit:int=0) -> List[Any] Value of ConfigurationEntry converted to a list The entry is converted to a list by using the split_re -regular expression. By default the entry will be split at commas and whitespace. Args: split_re : Regular expression used to split entry into list. convert : Function used to convert each element of the list. maxsplit : If nonzero, at most maxsplit splits occur. Returns: Value of entry as list.","title":"ConfigurationEntry.as_list()"},{"location":"api/midgard-config-config/#configurationentryas_list_of_lists","text":"as_list_of_lists(self, split_res:Tuple[str, ...]=('[\\\\s,]', '[^_\\\\w]'), num_elements:Union[int, NoneType]=None, convert:Callable=<class 'str'>) -> List[List[Any]]","title":"ConfigurationEntry.as_list_of_lists()"},{"location":"api/midgard-config-config/#configurationentryas_path","text":"as_path(self) -> pathlib.Path Value of ConfigurationEntry interpreted as a path string","title":"ConfigurationEntry.as_path()"},{"location":"api/midgard-config-config/#configurationentryas_str","text":"as_str(self) -> str Value of ConfigurationEntry as string","title":"ConfigurationEntry.as_str()"},{"location":"api/midgard-config-config/#configurationentryas_tuple","text":"as_tuple(self, split_re:str='[\\\\s,]', convert:Callable=<class 'str'>, maxsplit:int=0) -> Tuple[Any, ...] Value of ConfigurationEntry converted to a tuple The entry is converted to a tuple by using the split_re -regular expression. By default the entry will be split at commas and whitespace. Args: split_re : Regular expression used to split entry into tuple. convert : Function used to convert each element of the tuple. maxsplit : If nonzero, at most maxsplit splits occur. Returns: Value of entry as tuple.","title":"ConfigurationEntry.as_tuple()"},{"location":"api/midgard-config-config/#configurationentryentry_as_str","text":"entry_as_str(self, width:Union[int, NoneType]=None, key_width:int=30, metadata:bool=True) -> str The configuration entry represented as a string This is simililar to what is shown by str(entry) (and implemented by __str__ ), but has more flexibility. Args: width : Width of text for wrapping. Default is width of console. key_width : Width of the key column. Default is 30 characters. metadata : Include metadata like type and help text. Returns: String representation of the configuration entry.","title":"ConfigurationEntry.entry_as_str()"},{"location":"api/midgard-config-config/#configurationentryreplace","text":"replace(self, default:Union[str, NoneType]=None, **replace_vars:str) -> 'ConfigurationEntry'","title":"ConfigurationEntry.replace()"},{"location":"api/midgard-config-config/#configurationsection","text":"ConfigurationSection(name:str) -> None","title":"ConfigurationSection"},{"location":"api/midgard-config-config/#configurationsectionas_dict","text":"as_dict(self, getters:Dict[str, str]=None, default_getter:str='str') -> Dict[str, Any] The configuration section represented as a dictionary Args: getters : How to get the value of each entry in the section. default_getter : How to get the value of entries not specified in getters. Returns: Representation of the configuration section as a dictionary.","title":"ConfigurationSection.as_dict()"},{"location":"api/midgard-config-config/#configurationsectionas_list","text":"as_list(self) -> List[str] List of keys of entries in configuration section Returns: List of keys of entries in configuration section.","title":"ConfigurationSection.as_list()"},{"location":"api/midgard-config-config/#configurationsectionas_str","text":"as_str(self, width:Union[int, NoneType]=None, key_width:int=30, only_used:bool=False, metadata:bool=True) -> str The configuration section represented as a string This is simililar to what is shown by str(section) (and implemented by __str__ ), but has more flexibility. Args: width : Width of text for wrapping. Default is width of console. key_width : Width of the key column. Default is 30 characters. only_used : Only include configuration entries that has been used so far. metadata : Include metadata like type and help text. Returns: String representation of the configuration section.","title":"ConfigurationSection.as_str()"},{"location":"api/midgard-config-config/#fmt_date-str","text":"FMT_date = '%Y-%m-%d'","title":"FMT_date (str)"},{"location":"api/midgard-config-config/#fmt_datetime-str","text":"FMT_datetime = '%Y-%m-%d %H:%M:%S'","title":"FMT_datetime (str)"},{"location":"api/midgard-config-config/#fmt_dt_file-str","text":"FMT_dt_file = '%Y%m%d-%H%M%S'","title":"FMT_dt_file (str)"},{"location":"api/midgard-config-constant/","text":"midgard.config.constant","title":"midgard.config.constant"},{"location":"api/midgard-config-constant/#midgardconfigconstant","text":"","title":"midgard.config.constant"},{"location":"api/midgard-config/","text":"midgard.config","title":"midgard.config"},{"location":"api/midgard-config/#midgardconfig","text":"","title":"midgard.config"},{"location":"api/midgard-coords-position/","text":"midgard.coords.position","title":"midgard.coords.position"},{"location":"api/midgard-coords-position/#midgardcoordsposition","text":"","title":"midgard.coords.position"},{"location":"api/midgard-coords-time/","text":"midgard.coords.time","title":"midgard.coords.time"},{"location":"api/midgard-coords-time/#midgardcoordstime","text":"","title":"midgard.coords.time"},{"location":"api/midgard-coords/","text":"midgard.coords","title":"midgard.coords"},{"location":"api/midgard-coords/#midgardcoords","text":"","title":"midgard.coords"},{"location":"api/midgard-dev-cache/","text":"midgard.dev.cache","title":"midgard.dev.cache"},{"location":"api/midgard-dev-cache/#midgarddevcache","text":"","title":"midgard.dev.cache"},{"location":"api/midgard-dev-console/","text":"midgard.dev.console Simpler dealing with the console Description: Utilities for using the console. Mainly wrappers around other libraries to make them easier and more intuitive to use. Size of console: The two functions lines() and columns() report the current size of the console. Textwrapping: The function fill() can be used to rewrap a text-string so that it fits inside the console. Color: The sub-module color can be used to set the foreground and background colors. Note that the color functionality depends on the external package colorama . If colorama is not installed, color gracefully falls back to not showing any color. Examples: from midgard.dev import console console.columns() # doctest: +SKIP 86 print(console.fill(a_very_long_string)) # doctest: +SKIP Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras tempus eleifend feugiat. Maecenas vitae posuere metus. Sed sit amet fermentum velit. Aenean vitae turpis at risus sollicitudin fringilla in in nisi. Maecenas vitae ante libero. Aenean ut eros consequat, ornare erat at, tempus arcu. Suspendisse velit leo, eleifend eget mi non, vehicula ultricies erat. Vestibulum id nisi eget nisl venenatis dignissim. Duis cursus quam dui, vel hendrerit nibh lacinia id. print(console.color.Fore.YELLOW + console.color.Back.BLUE + 'I am YELLOW text on BLUE backdrop!') # doctest: +SKIP I am YELLOW text on a BLUE background! columns() columns() -> int The width of the console Returns: The width of the console in characters. dedent() dedent(text:str, num_spaces:Union[int, NoneType]=None) -> str Wrapper around textwrap.dedent Dedents at most num_spaces. If num_spaces is not specified, dedents as much as possible. Args: text : Text that will be dedented. num_spaces : Number of spaces that will be used for dedentation. Returns: Dedented string. fill() fill(text:str, *, width:Union[int, NoneType]=None, hanging:Union[int, NoneType]=None, **tw_args:Any) -> str Wrapper around textwrap.fill The tw_args are passed on to textwrap.fill. See textwrap.TextWrapper for available keyword arguments. The default value for width is console.columns(), while the new argument hanging , if defined, will try to set (although not override) the textwrap-arguments initial_indent and subsequent_indent to create a hanging indent (no indent on the first line) of hanging spaces. Args: text : Text that will be wrapped. width : The maximum width (in characters) of wrapped lines. hanging : Number of characters used for hanging indent. tw_args : Arguments passed on to textwrap.fill . Returns: Wrapped string. indent() indent(text:str, num_spaces:int, **tw_args:Any) -> str Wrapper around textwrap.indent The tw_args are passed on to textwrap.indent. Args: text : Text that will be indented. num_spaces : Number of spaces that will be used for indentation. Returns: Indented string. lines() lines() -> int The height of the console Returns: The heigth of the console in characters. num_leading_spaces() num_leading_spaces(text:str, space_char:str=' ') -> int Count number of leading spaces in a string Args: text : String to count. space_char : Which characters count as spaces. Returns: Number of leading spaces.","title":"midgard.dev.console"},{"location":"api/midgard-dev-console/#midgarddevconsole","text":"Simpler dealing with the console Description: Utilities for using the console. Mainly wrappers around other libraries to make them easier and more intuitive to use. Size of console: The two functions lines() and columns() report the current size of the console. Textwrapping: The function fill() can be used to rewrap a text-string so that it fits inside the console. Color: The sub-module color can be used to set the foreground and background colors. Note that the color functionality depends on the external package colorama . If colorama is not installed, color gracefully falls back to not showing any color. Examples: from midgard.dev import console console.columns() # doctest: +SKIP 86 print(console.fill(a_very_long_string)) # doctest: +SKIP Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras tempus eleifend feugiat. Maecenas vitae posuere metus. Sed sit amet fermentum velit. Aenean vitae turpis at risus sollicitudin fringilla in in nisi. Maecenas vitae ante libero. Aenean ut eros consequat, ornare erat at, tempus arcu. Suspendisse velit leo, eleifend eget mi non, vehicula ultricies erat. Vestibulum id nisi eget nisl venenatis dignissim. Duis cursus quam dui, vel hendrerit nibh lacinia id. print(console.color.Fore.YELLOW + console.color.Back.BLUE + 'I am YELLOW text on BLUE backdrop!') # doctest: +SKIP I am YELLOW text on a BLUE background!","title":"midgard.dev.console"},{"location":"api/midgard-dev-console/#columns","text":"columns() -> int The width of the console Returns: The width of the console in characters.","title":"columns()"},{"location":"api/midgard-dev-console/#dedent","text":"dedent(text:str, num_spaces:Union[int, NoneType]=None) -> str Wrapper around textwrap.dedent Dedents at most num_spaces. If num_spaces is not specified, dedents as much as possible. Args: text : Text that will be dedented. num_spaces : Number of spaces that will be used for dedentation. Returns: Dedented string.","title":"dedent()"},{"location":"api/midgard-dev-console/#fill","text":"fill(text:str, *, width:Union[int, NoneType]=None, hanging:Union[int, NoneType]=None, **tw_args:Any) -> str Wrapper around textwrap.fill The tw_args are passed on to textwrap.fill. See textwrap.TextWrapper for available keyword arguments. The default value for width is console.columns(), while the new argument hanging , if defined, will try to set (although not override) the textwrap-arguments initial_indent and subsequent_indent to create a hanging indent (no indent on the first line) of hanging spaces. Args: text : Text that will be wrapped. width : The maximum width (in characters) of wrapped lines. hanging : Number of characters used for hanging indent. tw_args : Arguments passed on to textwrap.fill . Returns: Wrapped string.","title":"fill()"},{"location":"api/midgard-dev-console/#indent","text":"indent(text:str, num_spaces:int, **tw_args:Any) -> str Wrapper around textwrap.indent The tw_args are passed on to textwrap.indent. Args: text : Text that will be indented. num_spaces : Number of spaces that will be used for indentation. Returns: Indented string.","title":"indent()"},{"location":"api/midgard-dev-console/#lines","text":"lines() -> int The height of the console Returns: The heigth of the console in characters.","title":"lines()"},{"location":"api/midgard-dev-console/#num_leading_spaces","text":"num_leading_spaces(text:str, space_char:str=' ') -> int Count number of leading spaces in a string Args: text : String to count. space_char : Which characters count as spaces. Returns: Number of leading spaces.","title":"num_leading_spaces()"},{"location":"api/midgard-dev-exceptions/","text":"midgard.dev.exceptions Definition of Midgard-specific exceptions Description: Custom exceptions used by Midgard for more specific error messages and handling. FieldDoesNotExistError FieldDoesNotExistError() FieldExistsError FieldExistsError() InitializationError InitializationError() MidgardException MidgardException() MidgardExit MidgardExit() MissingConfigurationError MissingConfigurationError() MissingDataError MissingDataError() MissingEntryError MissingEntryError() MissingSectionError MissingSectionError() ParserError ParserError() TimerNotRunning TimerNotRunning() TimerRunning TimerRunning() UnitError UnitError() UnknownEnumError UnknownEnumError() UnknownPackageError UnknownPackageError() UnknownPluginError UnknownPluginError()","title":"midgard.dev.exceptions"},{"location":"api/midgard-dev-exceptions/#midgarddevexceptions","text":"Definition of Midgard-specific exceptions Description: Custom exceptions used by Midgard for more specific error messages and handling.","title":"midgard.dev.exceptions"},{"location":"api/midgard-dev-exceptions/#fielddoesnotexisterror","text":"FieldDoesNotExistError()","title":"FieldDoesNotExistError"},{"location":"api/midgard-dev-exceptions/#fieldexistserror","text":"FieldExistsError()","title":"FieldExistsError"},{"location":"api/midgard-dev-exceptions/#initializationerror","text":"InitializationError()","title":"InitializationError"},{"location":"api/midgard-dev-exceptions/#midgardexception","text":"MidgardException()","title":"MidgardException"},{"location":"api/midgard-dev-exceptions/#midgardexit","text":"MidgardExit()","title":"MidgardExit"},{"location":"api/midgard-dev-exceptions/#missingconfigurationerror","text":"MissingConfigurationError()","title":"MissingConfigurationError"},{"location":"api/midgard-dev-exceptions/#missingdataerror","text":"MissingDataError()","title":"MissingDataError"},{"location":"api/midgard-dev-exceptions/#missingentryerror","text":"MissingEntryError()","title":"MissingEntryError"},{"location":"api/midgard-dev-exceptions/#missingsectionerror","text":"MissingSectionError()","title":"MissingSectionError"},{"location":"api/midgard-dev-exceptions/#parsererror","text":"ParserError()","title":"ParserError"},{"location":"api/midgard-dev-exceptions/#timernotrunning","text":"TimerNotRunning()","title":"TimerNotRunning"},{"location":"api/midgard-dev-exceptions/#timerrunning","text":"TimerRunning()","title":"TimerRunning"},{"location":"api/midgard-dev-exceptions/#uniterror","text":"UnitError()","title":"UnitError"},{"location":"api/midgard-dev-exceptions/#unknownenumerror","text":"UnknownEnumError()","title":"UnknownEnumError"},{"location":"api/midgard-dev-exceptions/#unknownpackageerror","text":"UnknownPackageError()","title":"UnknownPackageError"},{"location":"api/midgard-dev-exceptions/#unknownpluginerror","text":"UnknownPluginError()","title":"UnknownPluginError"},{"location":"api/midgard-dev-interactive/","text":"midgard.dev.interactive","title":"midgard.dev.interactive"},{"location":"api/midgard-dev-interactive/#midgarddevinteractive","text":"","title":"midgard.dev.interactive"},{"location":"api/midgard-dev-library/","text":"midgard.dev.library Python wrapper around C-libraries Description: Loads a C-library. If a library is missing, a mock library is returned. If this mock is used for anything, a warning will be printed. This is done to avoid dependencies to all the C/C++-libraries for Python programs only using some of them. SimpleMock SimpleMock(name, raise_error=True) Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (typically because a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on). load_name() load_name(library_name, func_specs=None, name_patterns=None) Load the given shared C-library See load_path for an explanation of the func_specs and name_patterns -arguments. Args: library_name (String): The name of the library. func_specs (Dict): Specification of types in lib (see load_path). name_patterns (List): Name mangling patterns (see load_path). Returns: ctypes.CDLL: Representation of the shared library. load_path() load_path(library_path, func_specs=None, name_patterns=None) Load the given shared C-library The optional func_specs-dictionary can be used to specify argument and return types of functions in the library (see the ctypes documentation for information about argtypes and restype). The dictionary should be on the form:: func_spec = {'func_1': dict(func_name='name_of_func_1_in_lib', argtypes=[ ... argtypes of func_1 ... ], restype=... restype of func_1 ...), 'func_2': ... } If the library is not found, a mock library is returned instead. The mock library will print a warning if it is used. For some libraries, name mangling is used and this might be different depending on operating system and how the library is compiled. For instance, in a Fortran library the function Test might be represented as __Test on a Windows system and test_ (with lower-case t ) on a Linux system. This can be handled by providing a list of possible patterns. The above example can be handled by:: name_patterns = ('__{func_name}', '{func_name_lower}_') In this case, each function in func_specs is looked up by testing each pattern in turn until a match is found. Args: library_path (String): The path to the library. func_specs (Dict): Specification of types in library (see above). name_patterns (List): Name mangling patterns (see above). Returns: ctypes.CDLL: Representation of the shared library.","title":"midgard.dev.library"},{"location":"api/midgard-dev-library/#midgarddevlibrary","text":"Python wrapper around C-libraries Description: Loads a C-library. If a library is missing, a mock library is returned. If this mock is used for anything, a warning will be printed. This is done to avoid dependencies to all the C/C++-libraries for Python programs only using some of them.","title":"midgard.dev.library"},{"location":"api/midgard-dev-library/#simplemock","text":"SimpleMock(name, raise_error=True) Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (typically because a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on).","title":"SimpleMock"},{"location":"api/midgard-dev-library/#load_name","text":"load_name(library_name, func_specs=None, name_patterns=None) Load the given shared C-library See load_path for an explanation of the func_specs and name_patterns -arguments. Args: library_name (String): The name of the library. func_specs (Dict): Specification of types in lib (see load_path). name_patterns (List): Name mangling patterns (see load_path). Returns: ctypes.CDLL: Representation of the shared library.","title":"load_name()"},{"location":"api/midgard-dev-library/#load_path","text":"load_path(library_path, func_specs=None, name_patterns=None) Load the given shared C-library The optional func_specs-dictionary can be used to specify argument and return types of functions in the library (see the ctypes documentation for information about argtypes and restype). The dictionary should be on the form:: func_spec = {'func_1': dict(func_name='name_of_func_1_in_lib', argtypes=[ ... argtypes of func_1 ... ], restype=... restype of func_1 ...), 'func_2': ... } If the library is not found, a mock library is returned instead. The mock library will print a warning if it is used. For some libraries, name mangling is used and this might be different depending on operating system and how the library is compiled. For instance, in a Fortran library the function Test might be represented as __Test on a Windows system and test_ (with lower-case t ) on a Linux system. This can be handled by providing a list of possible patterns. The above example can be handled by:: name_patterns = ('__{func_name}', '{func_name_lower}_') In this case, each function in func_specs is looked up by testing each pattern in turn until a match is found. Args: library_path (String): The path to the library. func_specs (Dict): Specification of types in library (see above). name_patterns (List): Name mangling patterns (see above). Returns: ctypes.CDLL: Representation of the shared library.","title":"load_path()"},{"location":"api/midgard-dev-log/","text":"midgard.dev.log","title":"midgard.dev.log"},{"location":"api/midgard-dev-log/#midgarddevlog","text":"","title":"midgard.dev.log"},{"location":"api/midgard-dev-optional/","text":"midgard.dev.optional Midgard library module for handling optional dependencies Description: Import dependencies that are only necessary for specific parts of Midgard. Using this module will delay raising an ImportError until the dependency is actually used. This means that if one for instance only wants to run a GNSS analysis (or only use a Rinex-parser) installing special libraries only used for VLBI is not necessary. Examples: The optional import is typically used as follows:: from midgard.lib import optional netCDF4 = optional.optional_import('netCDF4') EmptyStringMock EmptyStringMock(name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None) -> None A mock object whose properties are all empty strings SimpleMock SimpleMock(name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None) -> None Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (for instance if a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on). The exception is if any attributes ( attrs ) are explicitly defined on the mock. No exception is raised if those attributes are looked up. optional_import() optional_import(module_name:str, raise_error:bool=True, mock_cls:type=<class 'midgard.dev.optional.SimpleMock'>, attrs:Union[Dict[str, Any], NoneType]=None) -> Union[Any, midgard.dev.optional.SimpleMock] Try to import an optional module If the module does not exist, a SimpleMock-object is returned instead. If this SimpleMock-object is later used, an ImportError will be raised then (if raise_error is True, which is default). Args: module_name : Name of module to import. raise_error : Whether an ImportError should be raised if the module does not exist, but is used. attrs : Attributes that should be added to the SimpleMock used if the module does not exist. Returns: Imported module object, or a SimpleMock-object if the module can not be imported.","title":"midgard.dev.optional"},{"location":"api/midgard-dev-optional/#midgarddevoptional","text":"Midgard library module for handling optional dependencies Description: Import dependencies that are only necessary for specific parts of Midgard. Using this module will delay raising an ImportError until the dependency is actually used. This means that if one for instance only wants to run a GNSS analysis (or only use a Rinex-parser) installing special libraries only used for VLBI is not necessary. Examples: The optional import is typically used as follows:: from midgard.lib import optional netCDF4 = optional.optional_import('netCDF4')","title":"midgard.dev.optional"},{"location":"api/midgard-dev-optional/#emptystringmock","text":"EmptyStringMock(name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None) -> None A mock object whose properties are all empty strings","title":"EmptyStringMock"},{"location":"api/midgard-dev-optional/#simplemock","text":"SimpleMock(name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None) -> None Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (for instance if a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on). The exception is if any attributes ( attrs ) are explicitly defined on the mock. No exception is raised if those attributes are looked up.","title":"SimpleMock"},{"location":"api/midgard-dev-optional/#optional_import","text":"optional_import(module_name:str, raise_error:bool=True, mock_cls:type=<class 'midgard.dev.optional.SimpleMock'>, attrs:Union[Dict[str, Any], NoneType]=None) -> Union[Any, midgard.dev.optional.SimpleMock] Try to import an optional module If the module does not exist, a SimpleMock-object is returned instead. If this SimpleMock-object is later used, an ImportError will be raised then (if raise_error is True, which is default). Args: module_name : Name of module to import. raise_error : Whether an ImportError should be raised if the module does not exist, but is used. attrs : Attributes that should be added to the SimpleMock used if the module does not exist. Returns: Imported module object, or a SimpleMock-object if the module can not be imported.","title":"optional_import()"},{"location":"api/midgard-dev-plugins/","text":"midgard.dev.plugins Set up a plug-in architecture for Midgard Description: In order to be able to add models, parsers, data sources etc without needing to hardcode names, but rather pick them from configuration files, we use a simple plug-in architecture. The plug-in mechanism is based on the different plug-ins registering themselves using the register decorator: from midgard.dev import plugins @plugins.register def simple_model(rundate, tech, dset): ... Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. To list all plug-ins in a package use names : > from midgard.dev import plugins > plugins.names('midgard.models') ['model_one', 'model_three', 'model_two'] If the optional parameter config_key is given, then only plug-ins listed in the corresponding section in the current configuration file is listed. For instance, if the configuration file contains a line saying ham_models = model_three, model_one then we can list only the ham_models as follows: > from midgard.dev import plugins > plugins.names('midgard.models', config_key='ham_models') ['model_one', 'model_three'] Note that the plug-ins by default are sorted alphabetically. To run the plug-ins, use either call_all or call_one . The former calls all plug-ins and returns a dictionary containing the result from each plug-in. As with names the optional parameter config_key may be given: > from midgard.dev import plugins > plugins.call_all('midgard.models', config_key='ham_models', arg_to_plugin='hello') {'model_three': <result from model_three>, 'model_one': <result from model_one>} Arguments to the plug-ins should be passed as named arguments to call_all . Similarly, one plug-in may be called explicitly using call_one : > from midgard.dev import plugins > plugins.call_one('midgard.models', plugin_name='model_one', arg_to_plugin='hello') <result from model_one> There may be more than one function in each plug-in that is decorated by register . In this case, the default behaviour is that only the first function will be called. To call the other registered functions one should use the list_parts function to get a list of these functions and call them explicitly using the part optional parameter to call_one : > from midgard.dev import plugins > plugins.list_parts('midgard.techniques', plugin_name='vlbi') ['read', 'edit', 'calculate', 'estimate', 'write_result']) > for part in plugins.list_parts('midgard.techniques', plugin_name='vlbi'): ... plugins.call_one('midgard.techniques', plugin_name='vlbi', part=part, ...) Plugin Plugin(name:str, function:Callable, file_path:pathlib.Path, sort_value:int) Information about a plug-in Args: name : Name of the plug-in. function : The plug-in. file_path : Path to the source code of the plug-in, may be used to add the source as a dependency. sort_value : Value used when sorting plug-ins in order to control the order they are called. add_alias() add_alias(package_name:str, alias:str) -> None Add alias to plug-in package This allows one package of plug-ins to be spread over several directories Args: package_name : Name of package containing plug-ins. directory : Additional plug-in directory. call() call(package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -> Any Call one plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be called. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to the plug-in. Returns: Return value of the plug-in. call_all() call_all(package_name:str, plugins:Union[List[str], NoneType]=None, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -> Dict[str, Any] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list or in the config file does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-in names that should be used (optional). part : Name of function to call within the plug-ins (optional). prefix : Prefix of the plug-in names, used for a plug-in if it is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to all the plug-ins. Returns: Dictionary of all results from the plug-ins. doc() doc(package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False) -> str Document one plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). Returns: Documentation of the plug-in. doc_all() doc_all(package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False) -> Dict[str, str] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name (String): Name of package containing plug-ins. plugins (Tuple): List of plug-ins that should be used (optional). prefix (String): Prefix of the plug-in names, used if any of the plug-ins are unknown (optional). long_doc (Boolean): Whether to return the long doc-string or the short one-line string (optional). include_details (Boolean): Whether to include development details like parameters and return values (optional). Returns: Dict : Dictionary of all results from the plug-ins. exists() exists(package_name:str, plugin_name:str) -> bool Check whether or not a plug-in exists in a package Tries to import the given plug-in. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). Returns: True if plug-in exists, False otherwise. load() load(package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -> str Load one plug-in from a package First tries to load the plugin with the given name. If that fails, it tries to load {prefix}_{plugin_name} instead. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Actual name of plug-in (with or without prefix). names() names(package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None) -> List[str] List plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be listed. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-in names are unknown (optional). Returns: List of strings with names of plug-ins. parts() parts(package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -> List[str] List all parts of one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in. prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: List : Strings with names of parts. register() register(func:Callable, name:Union[str, NoneType]=None, sort_value:int=0) -> Callable Decorator used to register a plug-in Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. The path to the source code file is also stored. This is used to be able to add the source code as a dependency file when the plug-in is called. If name is given, the plug-in is registered based on this name instead of the name of the module. The name of the module is still registered as a part that can be used to distinguish between similar plug-ins in different files (see for instance how session is used in midgard.pipelines ). Args: func : The function that is being registered. name : Alternative name of plug-in. Used by register_named . sort_value : The value used when sorting plug-ins. Used by register_ordered . Returns: The function that is being registered. register_named() register_named(name:str) -> Callable Decorator used to register a named plug-in This allows for overriding the name used to register the plug-in. See register for more details. Args: name : Name used for plug-in instead of module name. Returns: Decorator that registers a named function. register_ordered() register_ordered(sort_value:int) -> Callable Decorator used to register a plug-in with a specific sort order The sort value should be a number. Lower numbers are sorted first, higher numbers last. Plug-ins without an explicit sort_order gets the sort value of 0. Args: sort_value : The value used when sorting plug-ins. Returns: Decorator that registers an ordered function.","title":"midgard.dev.plugins"},{"location":"api/midgard-dev-plugins/#midgarddevplugins","text":"Set up a plug-in architecture for Midgard Description: In order to be able to add models, parsers, data sources etc without needing to hardcode names, but rather pick them from configuration files, we use a simple plug-in architecture. The plug-in mechanism is based on the different plug-ins registering themselves using the register decorator: from midgard.dev import plugins @plugins.register def simple_model(rundate, tech, dset): ... Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. To list all plug-ins in a package use names : > from midgard.dev import plugins > plugins.names('midgard.models') ['model_one', 'model_three', 'model_two'] If the optional parameter config_key is given, then only plug-ins listed in the corresponding section in the current configuration file is listed. For instance, if the configuration file contains a line saying ham_models = model_three, model_one then we can list only the ham_models as follows: > from midgard.dev import plugins > plugins.names('midgard.models', config_key='ham_models') ['model_one', 'model_three'] Note that the plug-ins by default are sorted alphabetically. To run the plug-ins, use either call_all or call_one . The former calls all plug-ins and returns a dictionary containing the result from each plug-in. As with names the optional parameter config_key may be given: > from midgard.dev import plugins > plugins.call_all('midgard.models', config_key='ham_models', arg_to_plugin='hello') {'model_three': <result from model_three>, 'model_one': <result from model_one>} Arguments to the plug-ins should be passed as named arguments to call_all . Similarly, one plug-in may be called explicitly using call_one : > from midgard.dev import plugins > plugins.call_one('midgard.models', plugin_name='model_one', arg_to_plugin='hello') <result from model_one> There may be more than one function in each plug-in that is decorated by register . In this case, the default behaviour is that only the first function will be called. To call the other registered functions one should use the list_parts function to get a list of these functions and call them explicitly using the part optional parameter to call_one : > from midgard.dev import plugins > plugins.list_parts('midgard.techniques', plugin_name='vlbi') ['read', 'edit', 'calculate', 'estimate', 'write_result']) > for part in plugins.list_parts('midgard.techniques', plugin_name='vlbi'): ... plugins.call_one('midgard.techniques', plugin_name='vlbi', part=part, ...)","title":"midgard.dev.plugins"},{"location":"api/midgard-dev-plugins/#plugin","text":"Plugin(name:str, function:Callable, file_path:pathlib.Path, sort_value:int) Information about a plug-in Args: name : Name of the plug-in. function : The plug-in. file_path : Path to the source code of the plug-in, may be used to add the source as a dependency. sort_value : Value used when sorting plug-ins in order to control the order they are called.","title":"Plugin"},{"location":"api/midgard-dev-plugins/#add_alias","text":"add_alias(package_name:str, alias:str) -> None Add alias to plug-in package This allows one package of plug-ins to be spread over several directories Args: package_name : Name of package containing plug-ins. directory : Additional plug-in directory.","title":"add_alias()"},{"location":"api/midgard-dev-plugins/#call","text":"call(package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -> Any Call one plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be called. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to the plug-in. Returns: Return value of the plug-in.","title":"call()"},{"location":"api/midgard-dev-plugins/#call_all","text":"call_all(package_name:str, plugins:Union[List[str], NoneType]=None, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -> Dict[str, Any] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list or in the config file does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-in names that should be used (optional). part : Name of function to call within the plug-ins (optional). prefix : Prefix of the plug-in names, used for a plug-in if it is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to all the plug-ins. Returns: Dictionary of all results from the plug-ins.","title":"call_all()"},{"location":"api/midgard-dev-plugins/#doc","text":"doc(package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False) -> str Document one plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). Returns: Documentation of the plug-in.","title":"doc()"},{"location":"api/midgard-dev-plugins/#doc_all","text":"doc_all(package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False) -> Dict[str, str] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name (String): Name of package containing plug-ins. plugins (Tuple): List of plug-ins that should be used (optional). prefix (String): Prefix of the plug-in names, used if any of the plug-ins are unknown (optional). long_doc (Boolean): Whether to return the long doc-string or the short one-line string (optional). include_details (Boolean): Whether to include development details like parameters and return values (optional). Returns: Dict : Dictionary of all results from the plug-ins.","title":"doc_all()"},{"location":"api/midgard-dev-plugins/#exists","text":"exists(package_name:str, plugin_name:str) -> bool Check whether or not a plug-in exists in a package Tries to import the given plug-in. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). Returns: True if plug-in exists, False otherwise.","title":"exists()"},{"location":"api/midgard-dev-plugins/#load","text":"load(package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -> str Load one plug-in from a package First tries to load the plugin with the given name. If that fails, it tries to load {prefix}_{plugin_name} instead. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Actual name of plug-in (with or without prefix).","title":"load()"},{"location":"api/midgard-dev-plugins/#names","text":"names(package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None) -> List[str] List plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be listed. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-in names are unknown (optional). Returns: List of strings with names of plug-ins.","title":"names()"},{"location":"api/midgard-dev-plugins/#parts","text":"parts(package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -> List[str] List all parts of one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in. prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: List : Strings with names of parts.","title":"parts()"},{"location":"api/midgard-dev-plugins/#register","text":"register(func:Callable, name:Union[str, NoneType]=None, sort_value:int=0) -> Callable Decorator used to register a plug-in Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. The path to the source code file is also stored. This is used to be able to add the source code as a dependency file when the plug-in is called. If name is given, the plug-in is registered based on this name instead of the name of the module. The name of the module is still registered as a part that can be used to distinguish between similar plug-ins in different files (see for instance how session is used in midgard.pipelines ). Args: func : The function that is being registered. name : Alternative name of plug-in. Used by register_named . sort_value : The value used when sorting plug-ins. Used by register_ordered . Returns: The function that is being registered.","title":"register()"},{"location":"api/midgard-dev-plugins/#register_named","text":"register_named(name:str) -> Callable Decorator used to register a named plug-in This allows for overriding the name used to register the plug-in. See register for more details. Args: name : Name used for plug-in instead of module name. Returns: Decorator that registers a named function.","title":"register_named()"},{"location":"api/midgard-dev-plugins/#register_ordered","text":"register_ordered(sort_value:int) -> Callable Decorator used to register a plug-in with a specific sort order The sort value should be a number. Lower numbers are sorted first, higher numbers last. Plug-ins without an explicit sort_order gets the sort value of 0. Args: sort_value : The value used when sorting plug-ins. Returns: Decorator that registers an ordered function.","title":"register_ordered()"},{"location":"api/midgard-dev-profiler/","text":"midgard.dev.profiler Add a profiler when running Supports several profilers including cprofile, line_profiler, memprof and memory_profiler. CProfile CProfile() cprofile is used for profiling the whole program CProfile.end() end(self) Stop profiler CProfile.extension (NotImplementedType) extension = NotImplemented CProfile.option (str) option = '--profiler' CProfile.pip_name (str) pip_name = 'cprofile' CProfile.setup() setup(self, options) Set up profiler CProfile.show() show(self) Show results of profiler session in console CProfile.start() start(self) CProfile.write() write(self) Write results of profiler session to disk LineProfiler LineProfiler() line_profiler is used to profile one or a few functions in detail LineProfiler.end() end(self) Stop profiler LineProfiler.extension (NotImplementedType) extension = NotImplemented LineProfiler.option (str) option = '--line_profiler' LineProfiler.pip_name (str) pip_name = 'line_profiler' LineProfiler.setup() setup(self, options) Set up profiler LineProfiler.show() show(self) Show results of profiler session in console LineProfiler.start() start(self) Start profiler LineProfiler.write() write(self) Write results of profiler session to disk Profiler Profiler() Base class for profilers Profiler.end() end(self) Stop profiler Profiler.extension (NotImplementedType) extension = NotImplemented Profiler.option (NotImplementedType) option = NotImplemented Profiler.pip_name (NotImplementedType) pip_name = NotImplemented Profiler.setup() setup(self, options) Set up profiler Profiler.show() show(self) Show results of profiler session in console Profiler.start() start(self) Start profiler Profiler.write() write(self) Write results of profiler session to disk","title":"midgard.dev.profiler"},{"location":"api/midgard-dev-profiler/#midgarddevprofiler","text":"Add a profiler when running Supports several profilers including cprofile, line_profiler, memprof and memory_profiler.","title":"midgard.dev.profiler"},{"location":"api/midgard-dev-profiler/#cprofile","text":"CProfile() cprofile is used for profiling the whole program","title":"CProfile"},{"location":"api/midgard-dev-profiler/#cprofileend","text":"end(self) Stop profiler","title":"CProfile.end()"},{"location":"api/midgard-dev-profiler/#cprofileextension-notimplementedtype","text":"extension = NotImplemented","title":"CProfile.extension (NotImplementedType)"},{"location":"api/midgard-dev-profiler/#cprofileoption-str","text":"option = '--profiler'","title":"CProfile.option (str)"},{"location":"api/midgard-dev-profiler/#cprofilepip_name-str","text":"pip_name = 'cprofile'","title":"CProfile.pip_name (str)"},{"location":"api/midgard-dev-profiler/#cprofilesetup","text":"setup(self, options) Set up profiler","title":"CProfile.setup()"},{"location":"api/midgard-dev-profiler/#cprofileshow","text":"show(self) Show results of profiler session in console","title":"CProfile.show()"},{"location":"api/midgard-dev-profiler/#cprofilestart","text":"start(self)","title":"CProfile.start()"},{"location":"api/midgard-dev-profiler/#cprofilewrite","text":"write(self) Write results of profiler session to disk","title":"CProfile.write()"},{"location":"api/midgard-dev-profiler/#lineprofiler","text":"LineProfiler() line_profiler is used to profile one or a few functions in detail","title":"LineProfiler"},{"location":"api/midgard-dev-profiler/#lineprofilerend","text":"end(self) Stop profiler","title":"LineProfiler.end()"},{"location":"api/midgard-dev-profiler/#lineprofilerextension-notimplementedtype","text":"extension = NotImplemented","title":"LineProfiler.extension (NotImplementedType)"},{"location":"api/midgard-dev-profiler/#lineprofileroption-str","text":"option = '--line_profiler'","title":"LineProfiler.option (str)"},{"location":"api/midgard-dev-profiler/#lineprofilerpip_name-str","text":"pip_name = 'line_profiler'","title":"LineProfiler.pip_name (str)"},{"location":"api/midgard-dev-profiler/#lineprofilersetup","text":"setup(self, options) Set up profiler","title":"LineProfiler.setup()"},{"location":"api/midgard-dev-profiler/#lineprofilershow","text":"show(self) Show results of profiler session in console","title":"LineProfiler.show()"},{"location":"api/midgard-dev-profiler/#lineprofilerstart","text":"start(self) Start profiler","title":"LineProfiler.start()"},{"location":"api/midgard-dev-profiler/#lineprofilerwrite","text":"write(self) Write results of profiler session to disk","title":"LineProfiler.write()"},{"location":"api/midgard-dev-profiler/#profiler","text":"Profiler() Base class for profilers","title":"Profiler"},{"location":"api/midgard-dev-profiler/#profilerend","text":"end(self) Stop profiler","title":"Profiler.end()"},{"location":"api/midgard-dev-profiler/#profilerextension-notimplementedtype","text":"extension = NotImplemented","title":"Profiler.extension (NotImplementedType)"},{"location":"api/midgard-dev-profiler/#profileroption-notimplementedtype","text":"option = NotImplemented","title":"Profiler.option (NotImplementedType)"},{"location":"api/midgard-dev-profiler/#profilerpip_name-notimplementedtype","text":"pip_name = NotImplemented","title":"Profiler.pip_name (NotImplementedType)"},{"location":"api/midgard-dev-profiler/#profilersetup","text":"setup(self, options) Set up profiler","title":"Profiler.setup()"},{"location":"api/midgard-dev-profiler/#profilershow","text":"show(self) Show results of profiler session in console","title":"Profiler.show()"},{"location":"api/midgard-dev-profiler/#profilerstart","text":"start(self) Start profiler","title":"Profiler.start()"},{"location":"api/midgard-dev-profiler/#profilerwrite","text":"write(self) Write results of profiler session to disk","title":"Profiler.write()"},{"location":"api/midgard-dev-timer/","text":"midgard.dev.timer Class for timing the running time of functions and code blocks Description: The dev.timer can be used to log the running time of functions and general code blocks. Typically, you will import the Timer -class from within the module: from midgard.dev.timer import Timer The Timer can then be used in three different ways: As a decorator to time one function: @Timer('The time to execute some_function was') def some_function(some_argument, some_other_argument=some_value): pass As a context manager together with with to time a code block: with Timer('Finish doing stuff in', logger=logger.debug) as t: do_something() do_something_else() With explicit start - and end -statements: t = Timer() t.start() do_something() do_something_else() t.end() As can be seen in the examples above, Timer() may be called with several optional parameters, including the text to report when the timer ends and which logger is used to report the timing. See Timer.__init__ for more details. AccumulatedTimer AccumulatedTimer(text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None AccumulatedTimer.elapsed() elapsed(self) -> float Log the time elapsed Can be used explicitly to log the time since a timer started without ending the timer. Returns: The time elapsed in seconds. AccumulatedTimer.end() end(self) -> float End the timer and log the time elapsed Returns: The time elapsed in seconds. AccumulatedTimer.pause() pause(self) -> float Pause the timer without logging. Use .start() to restart the timer AccumulatedTimer.reset() reset(self) -> None Reset the timer back to 0 AccumulatedTimer.start() start(self) -> None Start the timer AccumulatedTimer.timer() timer() -> float Get current value of timer Using the built-in time.perf_counter to do the timing. Returns: Current value of timer. Timer Timer(text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None Class for timing running time of functions and code blocks. Timer.elapsed() elapsed(self) -> float Log the time elapsed Can be used explicitly to log the time since a timer started without ending the timer. Returns: The time elapsed in seconds. Timer.end() end(self) -> float End the timer and log the time elapsed Returns: The time elapsed in seconds. Timer.pause() pause(self) -> float Pause the timer without logging. Use .start() to restart the timer Timer.start() start(self) -> None Start the timer Timer.timer() timer() -> float Get current value of timer Using the built-in time.perf_counter to do the timing. Returns: Current value of timer.","title":"midgard.dev.timer"},{"location":"api/midgard-dev-timer/#midgarddevtimer","text":"Class for timing the running time of functions and code blocks Description: The dev.timer can be used to log the running time of functions and general code blocks. Typically, you will import the Timer -class from within the module: from midgard.dev.timer import Timer The Timer can then be used in three different ways: As a decorator to time one function: @Timer('The time to execute some_function was') def some_function(some_argument, some_other_argument=some_value): pass As a context manager together with with to time a code block: with Timer('Finish doing stuff in', logger=logger.debug) as t: do_something() do_something_else() With explicit start - and end -statements: t = Timer() t.start() do_something() do_something_else() t.end() As can be seen in the examples above, Timer() may be called with several optional parameters, including the text to report when the timer ends and which logger is used to report the timing. See Timer.__init__ for more details.","title":"midgard.dev.timer"},{"location":"api/midgard-dev-timer/#accumulatedtimer","text":"AccumulatedTimer(text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None","title":"AccumulatedTimer"},{"location":"api/midgard-dev-timer/#accumulatedtimerelapsed","text":"elapsed(self) -> float Log the time elapsed Can be used explicitly to log the time since a timer started without ending the timer. Returns: The time elapsed in seconds.","title":"AccumulatedTimer.elapsed()"},{"location":"api/midgard-dev-timer/#accumulatedtimerend","text":"end(self) -> float End the timer and log the time elapsed Returns: The time elapsed in seconds.","title":"AccumulatedTimer.end()"},{"location":"api/midgard-dev-timer/#accumulatedtimerpause","text":"pause(self) -> float Pause the timer without logging. Use .start() to restart the timer","title":"AccumulatedTimer.pause()"},{"location":"api/midgard-dev-timer/#accumulatedtimerreset","text":"reset(self) -> None Reset the timer back to 0","title":"AccumulatedTimer.reset()"},{"location":"api/midgard-dev-timer/#accumulatedtimerstart","text":"start(self) -> None Start the timer","title":"AccumulatedTimer.start()"},{"location":"api/midgard-dev-timer/#accumulatedtimertimer","text":"timer() -> float Get current value of timer Using the built-in time.perf_counter to do the timing. Returns: Current value of timer.","title":"AccumulatedTimer.timer()"},{"location":"api/midgard-dev-timer/#timer","text":"Timer(text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None Class for timing running time of functions and code blocks.","title":"Timer"},{"location":"api/midgard-dev-timer/#timerelapsed","text":"elapsed(self) -> float Log the time elapsed Can be used explicitly to log the time since a timer started without ending the timer. Returns: The time elapsed in seconds.","title":"Timer.elapsed()"},{"location":"api/midgard-dev-timer/#timerend","text":"end(self) -> float End the timer and log the time elapsed Returns: The time elapsed in seconds.","title":"Timer.end()"},{"location":"api/midgard-dev-timer/#timerpause","text":"pause(self) -> float Pause the timer without logging. Use .start() to restart the timer","title":"Timer.pause()"},{"location":"api/midgard-dev-timer/#timerstart","text":"start(self) -> None Start the timer","title":"Timer.start()"},{"location":"api/midgard-dev-timer/#timertimer","text":"timer() -> float Get current value of timer Using the built-in time.perf_counter to do the timing. Returns: Current value of timer.","title":"Timer.timer()"},{"location":"api/midgard-dev-util/","text":"midgard.dev.util","title":"midgard.dev.util"},{"location":"api/midgard-dev-util/#midgarddevutil","text":"","title":"midgard.dev.util"},{"location":"api/midgard-dev/","text":"midgard.dev","title":"midgard.dev"},{"location":"api/midgard-dev/#midgarddev","text":"","title":"midgard.dev"},{"location":"api/midgard-files-dates/","text":"midgard.files.dates Convenience functions for working with dates Description: Formats and converters that can be used for convenience and consistency. FMT_date (str) FMT_date = '%Y-%m-%d' FMT_datetime (str) FMT_datetime = '%Y-%m-%d %H:%M:%S' FMT_dt_file (str) FMT_dt_file = '%Y%m%d-%H%M%S' date_vars() date_vars(date:Union[datetime.date, NoneType]) -> Dict[str, str] Construct a dict of date variables From a given date, construct a dict containing all relevant date variables. This dict can be used to for instance replace variables in file names. Examples: >>> from datetime import date >>> date_vars(date(2009, 11, 2)) # doctest: +NORMALIZE_WHITESPACE {'yyyy': '2009', 'ce': '20', 'yy': '09', 'm': '11', 'mm': '11', 'mmm': 'nov', 'MMM': 'NOV', 'd': '2', 'dd': '02', 'doy': '306', 'dow': '1', 'h': '0', 'hh': '00'} >>> date_vars(None) {} Args: date : The given date. Returns: Dictionary with date variables for the given date.","title":"midgard.files.dates"},{"location":"api/midgard-files-dates/#midgardfilesdates","text":"Convenience functions for working with dates Description: Formats and converters that can be used for convenience and consistency.","title":"midgard.files.dates"},{"location":"api/midgard-files-dates/#fmt_date-str","text":"FMT_date = '%Y-%m-%d'","title":"FMT_date (str)"},{"location":"api/midgard-files-dates/#fmt_datetime-str","text":"FMT_datetime = '%Y-%m-%d %H:%M:%S'","title":"FMT_datetime (str)"},{"location":"api/midgard-files-dates/#fmt_dt_file-str","text":"FMT_dt_file = '%Y%m%d-%H%M%S'","title":"FMT_dt_file (str)"},{"location":"api/midgard-files-dates/#date_vars","text":"date_vars(date:Union[datetime.date, NoneType]) -> Dict[str, str] Construct a dict of date variables From a given date, construct a dict containing all relevant date variables. This dict can be used to for instance replace variables in file names. Examples: >>> from datetime import date >>> date_vars(date(2009, 11, 2)) # doctest: +NORMALIZE_WHITESPACE {'yyyy': '2009', 'ce': '20', 'yy': '09', 'm': '11', 'mm': '11', 'mmm': 'nov', 'MMM': 'NOV', 'd': '2', 'dd': '02', 'doy': '306', 'dow': '1', 'h': '0', 'hh': '00'} >>> date_vars(None) {} Args: date : The given date. Returns: Dictionary with date variables for the given date.","title":"date_vars()"},{"location":"api/midgard-files-dependencies/","text":"midgard.files.dependencies","title":"midgard.files.dependencies"},{"location":"api/midgard-files-dependencies/#midgardfilesdependencies","text":"","title":"midgard.files.dependencies"},{"location":"api/midgard-files-files/","text":"midgard.files.files","title":"midgard.files.files"},{"location":"api/midgard-files-files/#midgardfilesfiles","text":"","title":"midgard.files.files"},{"location":"api/midgard-files/","text":"midgard.files","title":"midgard.files"},{"location":"api/midgard-files/#midgardfiles","text":"","title":"midgard.files"},{"location":"api/midgard-ionosphere-klobuchar/","text":"midgard.ionosphere.klobuchar epilog (str) epilog = '\\n**EXAMPLE**\\n klobuchar_model.py(time, ion_coeffs, rec_pos, azel)\\n args:\\n time (I) : GPST\\n ion_coeffs (I) : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector\\n rec_pos (I) : receiver position {lat,lon,h} [rad, rad, m] as vector\\n azel (I) : azimuth/elevation angle {az,el} [rad] as vector \\n freq (I) : string, e.g. L1, L2, L5 (TODO: Not implemented)\\n logger (I) : Function that logs\\n l_result (O) : list containing the following parameters\\n L1_delay : computed path delay on L1 [m]\\n L1_variance: correspong variance [m^2]\\n \\n \\n \\n**COPYRIGHT**\\n | Copyright 2018, by the Geodetic Institute, NMA\\n | All rights reserved\\n\\n**AUTHORS**\\n | Mohammed Ouassou \\n | Geodetic Institute, NMA\\n | Kartverksveien 21, N-3511\\n | H\u00f8nefoss, Norway\\n\\nKeywords: Klobuchar model, Nequick broadcast model\\n' get_my_parser() get_my_parser() klobuchar() klobuchar(t, ion_coeffs, rec_pos, az, el, logger=<built-in function print>) Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model) GPS and Beidu satellite navigation systems use this model. The implementation is based on original paper of Klobuchar, J.A. Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users https://scinapse.io/papers/2058160370 Args: time : GPST ion_coeffs : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector rec_pos : receiver position {lat,lon,h} [rad, rad, m] as vector az : azimuth angle [rad] el : elevation angle [rad] logger : Function that logs Returns: L1_delay : computed path delay on L1 [m] L1_variance : corresponding variance [m^2] main() main() prolog (str) prolog = '\\n**PROGRAM**\\n klobuchar_model.py\\n \\n**PURPOSE**\\n compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model).\\n GPS and Beidu satellite navigation systems use this model.\\n The implementation is based on original paper of Klobuchar, J.A.\\n Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users\\n https://scinapse.io/papers/2058160370\\n\\n**USAGE**\\n'","title":"midgard.ionosphere.klobuchar"},{"location":"api/midgard-ionosphere-klobuchar/#midgardionosphereklobuchar","text":"","title":"midgard.ionosphere.klobuchar"},{"location":"api/midgard-ionosphere-klobuchar/#epilog-str","text":"epilog = '\\n**EXAMPLE**\\n klobuchar_model.py(time, ion_coeffs, rec_pos, azel)\\n args:\\n time (I) : GPST\\n ion_coeffs (I) : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector\\n rec_pos (I) : receiver position {lat,lon,h} [rad, rad, m] as vector\\n azel (I) : azimuth/elevation angle {az,el} [rad] as vector \\n freq (I) : string, e.g. L1, L2, L5 (TODO: Not implemented)\\n logger (I) : Function that logs\\n l_result (O) : list containing the following parameters\\n L1_delay : computed path delay on L1 [m]\\n L1_variance: correspong variance [m^2]\\n \\n \\n \\n**COPYRIGHT**\\n | Copyright 2018, by the Geodetic Institute, NMA\\n | All rights reserved\\n\\n**AUTHORS**\\n | Mohammed Ouassou \\n | Geodetic Institute, NMA\\n | Kartverksveien 21, N-3511\\n | H\u00f8nefoss, Norway\\n\\nKeywords: Klobuchar model, Nequick broadcast model\\n'","title":"epilog (str)"},{"location":"api/midgard-ionosphere-klobuchar/#get_my_parser","text":"get_my_parser()","title":"get_my_parser()"},{"location":"api/midgard-ionosphere-klobuchar/#klobuchar","text":"klobuchar(t, ion_coeffs, rec_pos, az, el, logger=<built-in function print>) Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model) GPS and Beidu satellite navigation systems use this model. The implementation is based on original paper of Klobuchar, J.A. Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users https://scinapse.io/papers/2058160370 Args: time : GPST ion_coeffs : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector rec_pos : receiver position {lat,lon,h} [rad, rad, m] as vector az : azimuth angle [rad] el : elevation angle [rad] logger : Function that logs Returns: L1_delay : computed path delay on L1 [m] L1_variance : corresponding variance [m^2]","title":"klobuchar()"},{"location":"api/midgard-ionosphere-klobuchar/#main","text":"main()","title":"main()"},{"location":"api/midgard-ionosphere-klobuchar/#prolog-str","text":"prolog = '\\n**PROGRAM**\\n klobuchar_model.py\\n \\n**PURPOSE**\\n compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model).\\n GPS and Beidu satellite navigation systems use this model.\\n The implementation is based on original paper of Klobuchar, J.A.\\n Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users\\n https://scinapse.io/papers/2058160370\\n\\n**USAGE**\\n'","title":"prolog (str)"},{"location":"api/midgard-math-interpolation/","text":"midgard.math.interpolation Methods for interpolating in numpy arrays Description: Different interpolation methods are decorated with @register_interpolator and will then become available for use as kind in interpolate and moving_window . Example: >>> import numpy as np >>> np.set_printoptions(precision=3, suppress=True) >>> x = np.linspace(-1, 1, 11) >>> y = x**3 - x >>> y array([ 0. , 0.288, 0.384, 0.336, 0.192, 0. , -0.192, -0.336, -0.384, -0.288, 0. ]) >>> x_new = np.linspace(-0.8, 0.8, 11) >>> interpolate(x, y, x_new, kind='cubic') array([ 0.288, 0.378, 0.369, 0.287, 0.156, -0. , -0.156, -0.287, -0.369, -0.378, -0.288]) Developer info: To add your own interpolators, you can simply decorate your interpolator functions with @register_interpolator . Your interpolator function should have the signature (x: np.ndarray, y: np.ndarray) -> Callable For instance, the following would implement a terrible interpolation function that sets all values to zero: from midgard.math.interpolation import register_interpolator @register_interpolator def zero(x: np.ndarray, y: np.ndarray) -> Callable: def _zero(x_new: np.ndarray) -> np.ndarray: return np.zeros(y.shape) return _zero This function would then be available as an interpolator. For instance, one could do >>> interpolate(x, y, x_new, kind='zero') # doctest: +SKIP array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) barycentric_interpolator() barycentric_interpolator(x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable The interpolating polynomial through the given points Uses the scipy.interpolate.BarycentricInterpolator function behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Barycentric interpolation function cubic() cubic(x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable Cubic spline interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='cubic' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Cubic spline interpolation function get_interpolator() get_interpolator(name:str) -> Callable Return an interpolation function Interpolation functions are registered by the @register_interpolator-decorator. The name-parameter corresponds to the function name of the interpolator. Args: name : Name of interpolator. Returns: Interpolation function with the given name. interpolate() interpolate(x:numpy.ndarray, y:numpy.ndarray, x_new:numpy.ndarray, *, kind:str, **ipargs:Any) -> numpy.ndarray Interpolate values from one x-array to another See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. ipargs : Keyword arguments passed on to the interpolator. Returns: Array of interpolated y-values. interpolate_with_derivative() interpolate_with_derivative(x:numpy.ndarray, y:numpy.ndarray, x_new:numpy.ndarray, *, kind:str, dx:float=0.5, **ipargs:Any) -> numpy.ndarray Interpolate values from one x-array to another as well as find derivatives See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. dx : Values at x \u00b1 dx are used to determine derivative. ipargs : Keyword arguments passed on to the interpolator. Returns: Tuple with array of interpolated y-values and array of derivatives. interpolated_univariate_spline() interpolated_univariate_spline(x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable One-dimensional interpolating spline for the given points Uses the scipy.interpolate.InterpolatedUnivariateSpline function behind the scenes. The original only deals with one-dimensional y arrays, so multiple calls are made for higher dimensional y arrays. The dimensions are handled independently of each other. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Interpolating spline function interpolators() interpolators() -> List[str] Return a list of available interpolators Returns: Names of available interpolators. lagrange() lagrange(x:numpy.ndarray, y:numpy.ndarray, *, window:int=10, bounds_error:bool=True, assume_sorted:bool=False) -> Callable Computes the lagrange polynomial passing through a certain set of points See https://en.wikipedia.org/wiki/Lagrange_polynomial Uses window of the original points to calculate the Lagrange polynomials. The window of points is chosen by finding the closest original point and essentially picking the window // 2 indices on either side. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. window : Number of points used in interpolation. bounds_error : If True, a ValueError is raised if extrapolation is attempted. assume_sorted : If True, x must be an array of monotonically increasing values. Returns: Lagrange interpolation function. linear() linear(x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable Linear interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='linear' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Linear interpolation function register_interpolator() register_interpolator(func:Callable) -> Callable Register an interpolation function This function should be used as a @register_interpolator-decorator Args: func : Function that will be registered as an interpolator. Returns: Same function.","title":"midgard.math.interpolation"},{"location":"api/midgard-math-interpolation/#midgardmathinterpolation","text":"Methods for interpolating in numpy arrays Description: Different interpolation methods are decorated with @register_interpolator and will then become available for use as kind in interpolate and moving_window . Example: >>> import numpy as np >>> np.set_printoptions(precision=3, suppress=True) >>> x = np.linspace(-1, 1, 11) >>> y = x**3 - x >>> y array([ 0. , 0.288, 0.384, 0.336, 0.192, 0. , -0.192, -0.336, -0.384, -0.288, 0. ]) >>> x_new = np.linspace(-0.8, 0.8, 11) >>> interpolate(x, y, x_new, kind='cubic') array([ 0.288, 0.378, 0.369, 0.287, 0.156, -0. , -0.156, -0.287, -0.369, -0.378, -0.288]) Developer info: To add your own interpolators, you can simply decorate your interpolator functions with @register_interpolator . Your interpolator function should have the signature (x: np.ndarray, y: np.ndarray) -> Callable For instance, the following would implement a terrible interpolation function that sets all values to zero: from midgard.math.interpolation import register_interpolator @register_interpolator def zero(x: np.ndarray, y: np.ndarray) -> Callable: def _zero(x_new: np.ndarray) -> np.ndarray: return np.zeros(y.shape) return _zero This function would then be available as an interpolator. For instance, one could do >>> interpolate(x, y, x_new, kind='zero') # doctest: +SKIP array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])","title":"midgard.math.interpolation"},{"location":"api/midgard-math-interpolation/#barycentric_interpolator","text":"barycentric_interpolator(x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable The interpolating polynomial through the given points Uses the scipy.interpolate.BarycentricInterpolator function behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Barycentric interpolation function","title":"barycentric_interpolator()"},{"location":"api/midgard-math-interpolation/#cubic","text":"cubic(x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable Cubic spline interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='cubic' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Cubic spline interpolation function","title":"cubic()"},{"location":"api/midgard-math-interpolation/#get_interpolator","text":"get_interpolator(name:str) -> Callable Return an interpolation function Interpolation functions are registered by the @register_interpolator-decorator. The name-parameter corresponds to the function name of the interpolator. Args: name : Name of interpolator. Returns: Interpolation function with the given name.","title":"get_interpolator()"},{"location":"api/midgard-math-interpolation/#interpolate","text":"interpolate(x:numpy.ndarray, y:numpy.ndarray, x_new:numpy.ndarray, *, kind:str, **ipargs:Any) -> numpy.ndarray Interpolate values from one x-array to another See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. ipargs : Keyword arguments passed on to the interpolator. Returns: Array of interpolated y-values.","title":"interpolate()"},{"location":"api/midgard-math-interpolation/#interpolate_with_derivative","text":"interpolate_with_derivative(x:numpy.ndarray, y:numpy.ndarray, x_new:numpy.ndarray, *, kind:str, dx:float=0.5, **ipargs:Any) -> numpy.ndarray Interpolate values from one x-array to another as well as find derivatives See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. dx : Values at x \u00b1 dx are used to determine derivative. ipargs : Keyword arguments passed on to the interpolator. Returns: Tuple with array of interpolated y-values and array of derivatives.","title":"interpolate_with_derivative()"},{"location":"api/midgard-math-interpolation/#interpolated_univariate_spline","text":"interpolated_univariate_spline(x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable One-dimensional interpolating spline for the given points Uses the scipy.interpolate.InterpolatedUnivariateSpline function behind the scenes. The original only deals with one-dimensional y arrays, so multiple calls are made for higher dimensional y arrays. The dimensions are handled independently of each other. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Interpolating spline function","title":"interpolated_univariate_spline()"},{"location":"api/midgard-math-interpolation/#interpolators","text":"interpolators() -> List[str] Return a list of available interpolators Returns: Names of available interpolators.","title":"interpolators()"},{"location":"api/midgard-math-interpolation/#lagrange","text":"lagrange(x:numpy.ndarray, y:numpy.ndarray, *, window:int=10, bounds_error:bool=True, assume_sorted:bool=False) -> Callable Computes the lagrange polynomial passing through a certain set of points See https://en.wikipedia.org/wiki/Lagrange_polynomial Uses window of the original points to calculate the Lagrange polynomials. The window of points is chosen by finding the closest original point and essentially picking the window // 2 indices on either side. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. window : Number of points used in interpolation. bounds_error : If True, a ValueError is raised if extrapolation is attempted. assume_sorted : If True, x must be an array of monotonically increasing values. Returns: Lagrange interpolation function.","title":"lagrange()"},{"location":"api/midgard-math-interpolation/#linear","text":"linear(x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable Linear interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='linear' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Linear interpolation function","title":"linear()"},{"location":"api/midgard-math-interpolation/#register_interpolator","text":"register_interpolator(func:Callable) -> Callable Register an interpolation function This function should be used as a @register_interpolator-decorator Args: func : Function that will be registered as an interpolator. Returns: Same function.","title":"register_interpolator()"},{"location":"api/midgard-math-rotation/","text":"midgard.math.rotation","title":"midgard.math.rotation"},{"location":"api/midgard-math-rotation/#midgardmathrotation","text":"","title":"midgard.math.rotation"},{"location":"api/midgard-math-unit/","text":"midgard.math.unit Midgard library module for handling of SI-unit conversions Description: This module provides unit conversion constants and functions. The heavy lifting is done by the pint package. The basic usage is as follows: >>> from midgard.math.unit import Unit >>> seconds_in_two_weeks = 2 * Unit.week2secs >>> seconds_in_two_weeks 1209600.0 In general Unit.spam2ham will give the multiplicative conversion scale between the units spam and ham . Through the pint package we support a lot of units. See Unit.list() or https://github.com/hgrecco/pint/blob/master/pint/default_en.txt . Another notation is also available, and might be necessary for some more complicated conversions: >>> seconds_in_two_weeks = 2 * Unit('week', 'seconds') >>> miles_per_hour_in_meters_per_second = Unit('mph', 'meters / sec') Do note that we support most normal aliases as well as singular and plural forms of the units. For instance can second be represented as s , sec , secs and seconds . Prefixes are also handled: >>> nanoseconds_in_an_hour = Unit.hour2nanosecs >>> inches_in_a_kilometer = Unit.km2inches For more complicated conversions (for instance from Celsius to Fahrenheit) one can create custom conversion functions using convert : >>> c2f = Unit.function('celsius', 'fahrenheit') >>> absolute_zero_in_fahrenheit = c2f(-273.15) For convenience, this can also be written using the attribute notation as Unit.spam_to_ham(spam_value) . Then the previous example simply becomes: >>> absolute_zero_in_fahrenheit = Unit.celsius_to_fahrenheit(-273.15) (or even easier Unit.kelvin_to_fahrenheit(0) ). Finally, we can access the unit/quantity system of pint by using the name of a unit by itself, e.g. Unit.spam . For instance: >>> distance = 42 * Unit.km >>> time = 31 * Unit('minutes') >>> speed = distance / time >>> speed.to(Unit.mph) <Quantity(50.511464659292955, 'mph')> >>> speed.to_base_units() <Quantity(22.580645161290324, 'meter / second')> However, using the full unit system adds some overhead so we should be careful in using it in heavy calculations. Unit Unit(from_unit:str, to_unit:Union[str, NoneType]=None) -> Any Unit converter The implementation of the unit conversion is done in the _convert_units -metaclass. Unit.dms_to_rad() dms_to_rad(degrees:~np_float, minutes:~np_float, seconds:~np_float) -> ~np_float Convert degrees, minutes and seconds to radians The sign of degrees will be used. In this case, be careful that the sign of +0 or -0 is correctly passed on. That is, degrees must be specified as a float, not an int. Args: degrees : Degrees as float (including sign) or array of floats minutes : Minutes as int/float or array of ints/floats seconds : Seconds as float or array of floats Returns: Given degrees, minutes and seconds as radians. Examples: >>> Unit.dms_to_rad(59, 54, 52.32) 1.04570587646256 >>> Unit.dms_to_rad(-12.0, 34, 56.789) -0.21960503017531938 >>> Unit.dms_to_rad(-0.0, 19, 59.974870) -0.005817642339636369 Unit.hms_to_rad() hms_to_rad(hours:~np_float, minutes:~np_float, seconds:~np_float) -> ~np_float Convert hours, minutes and seconds to radians Args: hours : Hours as int or array of ints minutes : Minutes as int or or array of ints seconds : Seconds as float or or array of floats Returns: Given hours, minutes and seconds as radians. Examples: >>> Unit.hms_to_rad(17, 7, 17.753427) 4.482423920139868 >>> Unit.hms_to_rad(12, 0, 0.00) 3.1415926535897936 >>> Unit.hms_to_rad(-12, 34, 56.789) Traceback (most recent call last): ValueError: hours must be non-negative Unit.rad_to_dms() rad_to_dms(radians:~np_float) -> Tuple[~np_float, ~np_float, ~np_float] Converts radians to degrees, minutes and seconds Args: radians : Angle(s) in radians Returns: Tuple with degrees, minutes, and seconds. Examples: >>> Unit.rad_to_dms(1.04570587646256) (59.0, 54.0, 52.3200000000179) >>> Unit.rad_to_dms(-0.2196050301753194) (-12.0, 34.0, 56.78900000000468) >>> Unit.rad_to_dms(-0.005817642339636369) (-0.0, 19.0, 59.974869999999925)","title":"midgard.math.unit"},{"location":"api/midgard-math-unit/#midgardmathunit","text":"Midgard library module for handling of SI-unit conversions Description: This module provides unit conversion constants and functions. The heavy lifting is done by the pint package. The basic usage is as follows: >>> from midgard.math.unit import Unit >>> seconds_in_two_weeks = 2 * Unit.week2secs >>> seconds_in_two_weeks 1209600.0 In general Unit.spam2ham will give the multiplicative conversion scale between the units spam and ham . Through the pint package we support a lot of units. See Unit.list() or https://github.com/hgrecco/pint/blob/master/pint/default_en.txt . Another notation is also available, and might be necessary for some more complicated conversions: >>> seconds_in_two_weeks = 2 * Unit('week', 'seconds') >>> miles_per_hour_in_meters_per_second = Unit('mph', 'meters / sec') Do note that we support most normal aliases as well as singular and plural forms of the units. For instance can second be represented as s , sec , secs and seconds . Prefixes are also handled: >>> nanoseconds_in_an_hour = Unit.hour2nanosecs >>> inches_in_a_kilometer = Unit.km2inches For more complicated conversions (for instance from Celsius to Fahrenheit) one can create custom conversion functions using convert : >>> c2f = Unit.function('celsius', 'fahrenheit') >>> absolute_zero_in_fahrenheit = c2f(-273.15) For convenience, this can also be written using the attribute notation as Unit.spam_to_ham(spam_value) . Then the previous example simply becomes: >>> absolute_zero_in_fahrenheit = Unit.celsius_to_fahrenheit(-273.15) (or even easier Unit.kelvin_to_fahrenheit(0) ). Finally, we can access the unit/quantity system of pint by using the name of a unit by itself, e.g. Unit.spam . For instance: >>> distance = 42 * Unit.km >>> time = 31 * Unit('minutes') >>> speed = distance / time >>> speed.to(Unit.mph) <Quantity(50.511464659292955, 'mph')> >>> speed.to_base_units() <Quantity(22.580645161290324, 'meter / second')> However, using the full unit system adds some overhead so we should be careful in using it in heavy calculations.","title":"midgard.math.unit"},{"location":"api/midgard-math-unit/#unit","text":"Unit(from_unit:str, to_unit:Union[str, NoneType]=None) -> Any Unit converter The implementation of the unit conversion is done in the _convert_units -metaclass.","title":"Unit"},{"location":"api/midgard-math-unit/#unitdms_to_rad","text":"dms_to_rad(degrees:~np_float, minutes:~np_float, seconds:~np_float) -> ~np_float Convert degrees, minutes and seconds to radians The sign of degrees will be used. In this case, be careful that the sign of +0 or -0 is correctly passed on. That is, degrees must be specified as a float, not an int. Args: degrees : Degrees as float (including sign) or array of floats minutes : Minutes as int/float or array of ints/floats seconds : Seconds as float or array of floats Returns: Given degrees, minutes and seconds as radians. Examples: >>> Unit.dms_to_rad(59, 54, 52.32) 1.04570587646256 >>> Unit.dms_to_rad(-12.0, 34, 56.789) -0.21960503017531938 >>> Unit.dms_to_rad(-0.0, 19, 59.974870) -0.005817642339636369","title":"Unit.dms_to_rad()"},{"location":"api/midgard-math-unit/#unithms_to_rad","text":"hms_to_rad(hours:~np_float, minutes:~np_float, seconds:~np_float) -> ~np_float Convert hours, minutes and seconds to radians Args: hours : Hours as int or array of ints minutes : Minutes as int or or array of ints seconds : Seconds as float or or array of floats Returns: Given hours, minutes and seconds as radians. Examples: >>> Unit.hms_to_rad(17, 7, 17.753427) 4.482423920139868 >>> Unit.hms_to_rad(12, 0, 0.00) 3.1415926535897936 >>> Unit.hms_to_rad(-12, 34, 56.789) Traceback (most recent call last): ValueError: hours must be non-negative","title":"Unit.hms_to_rad()"},{"location":"api/midgard-math-unit/#unitrad_to_dms","text":"rad_to_dms(radians:~np_float) -> Tuple[~np_float, ~np_float, ~np_float] Converts radians to degrees, minutes and seconds Args: radians : Angle(s) in radians Returns: Tuple with degrees, minutes, and seconds. Examples: >>> Unit.rad_to_dms(1.04570587646256) (59.0, 54.0, 52.3200000000179) >>> Unit.rad_to_dms(-0.2196050301753194) (-12.0, 34.0, 56.78900000000468) >>> Unit.rad_to_dms(-0.005817642339636369) (-0.0, 19.0, 59.974869999999925)","title":"Unit.rad_to_dms()"},{"location":"api/midgard-math/","text":"midgard.math","title":"midgard.math"},{"location":"api/midgard-math/#midgardmath","text":"","title":"midgard.math"},{"location":"api/midgard-parsers-_parser/","text":"midgard.parsers._parser Basic functionality for parsing datafiles, extended by individual parsers Description: This module contains functions and classes for parsing datafiles. It should typically be used by calling parsers.parse_file : Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() Parser Parser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file. You should inherit from one of the specific parsers like for instance ChainParser, LineParser, SinexParser etc Attributes: file_path (Path): Path to the datafile that will be read. file_encoding (String): Encoding of the datafile. parser_name (String): Name of the parser (as needed to call parsers.parse_...). data_available (Boolean): Indicator of whether data are available. data (Dict): The (observation) data read from file. meta (Dict): Metainformation read from file. Parser.as_dataframe() as_dataframe(self, index:Union[str, List[str], NoneType]=None) -> pandas.core.frame.DataFrame Return the parsed data as a Pandas DataFrame This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: index : Optional name of field to use as index. May also be a list of strings. Returns: Pandas DataFrame with the parsed data. Parser.as_dataset() as_dataset(self) -> NoReturn Return the parsed data as a Midgard Dataset This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Returns: Dataset : The parsed data. Parser.as_dict() as_dict(self, include_meta:bool=False) -> Dict[str, Any] Return the parsed data as a dictionary This is a basic implementation, simply returning a copy of self.data. More advanced parsers may need to reimplement this method. Args: include_meta : Whether to include meta-data in the returned dictionary (default: False). Returns: Dictionary with the parsed data. Parser.parse() parse(self) -> 'Parser' Parse data This is a basic implementation that carries out the whole pipeline of reading and parsing datafiles including calculating secondary data. Subclasses should typically implement (at least) the read_data -method. Parser.postprocess_data() postprocess_data(self) -> None Do simple manipulations on the data after they are read Simple manipulations of data may be performed in postprocessors after they are read. They should be kept simple so that a parser returns as true representation of the data file as possible. Advanced calculations may be done inside apriori classes or similar. To add a postprocessor, define it in its own method, and override the setup_postprocessors -method to return a list of all postprocessors. Parser.read_data() read_data(self) -> None Read data from the data file Data should be read from self.file_path and stored in the dictionary self.data . A description of the data may be placed in the dictionary self.meta . If data are not available for some reason, self.data_available should be set to False. Parser.setup_parser() setup_parser(self) -> Any Set up information needed for the parser Parser.setup_postprocessors() setup_postprocessors(self) -> List[Callable[[], NoneType]] List postprocessors that should be called after parsing Parser.update_dataset() update_dataset(self, dset:Any) -> NoReturn Update the given dataset with the parsed data This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: dset (Dataset): The dataset to update with parsed data.","title":"midgard.parsers._parser"},{"location":"api/midgard-parsers-_parser/#midgardparsers_parser","text":"Basic functionality for parsing datafiles, extended by individual parsers Description: This module contains functions and classes for parsing datafiles. It should typically be used by calling parsers.parse_file : Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser"},{"location":"api/midgard-parsers-_parser/#parser","text":"Parser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file. You should inherit from one of the specific parsers like for instance ChainParser, LineParser, SinexParser etc Attributes: file_path (Path): Path to the datafile that will be read. file_encoding (String): Encoding of the datafile. parser_name (String): Name of the parser (as needed to call parsers.parse_...). data_available (Boolean): Indicator of whether data are available. data (Dict): The (observation) data read from file. meta (Dict): Metainformation read from file.","title":"Parser"},{"location":"api/midgard-parsers-_parser/#parseras_dataframe","text":"as_dataframe(self, index:Union[str, List[str], NoneType]=None) -> pandas.core.frame.DataFrame Return the parsed data as a Pandas DataFrame This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: index : Optional name of field to use as index. May also be a list of strings. Returns: Pandas DataFrame with the parsed data.","title":"Parser.as_dataframe()"},{"location":"api/midgard-parsers-_parser/#parseras_dataset","text":"as_dataset(self) -> NoReturn Return the parsed data as a Midgard Dataset This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Returns: Dataset : The parsed data.","title":"Parser.as_dataset()"},{"location":"api/midgard-parsers-_parser/#parseras_dict","text":"as_dict(self, include_meta:bool=False) -> Dict[str, Any] Return the parsed data as a dictionary This is a basic implementation, simply returning a copy of self.data. More advanced parsers may need to reimplement this method. Args: include_meta : Whether to include meta-data in the returned dictionary (default: False). Returns: Dictionary with the parsed data.","title":"Parser.as_dict()"},{"location":"api/midgard-parsers-_parser/#parserparse","text":"parse(self) -> 'Parser' Parse data This is a basic implementation that carries out the whole pipeline of reading and parsing datafiles including calculating secondary data. Subclasses should typically implement (at least) the read_data -method.","title":"Parser.parse()"},{"location":"api/midgard-parsers-_parser/#parserpostprocess_data","text":"postprocess_data(self) -> None Do simple manipulations on the data after they are read Simple manipulations of data may be performed in postprocessors after they are read. They should be kept simple so that a parser returns as true representation of the data file as possible. Advanced calculations may be done inside apriori classes or similar. To add a postprocessor, define it in its own method, and override the setup_postprocessors -method to return a list of all postprocessors.","title":"Parser.postprocess_data()"},{"location":"api/midgard-parsers-_parser/#parserread_data","text":"read_data(self) -> None Read data from the data file Data should be read from self.file_path and stored in the dictionary self.data . A description of the data may be placed in the dictionary self.meta . If data are not available for some reason, self.data_available should be set to False.","title":"Parser.read_data()"},{"location":"api/midgard-parsers-_parser/#parsersetup_parser","text":"setup_parser(self) -> Any Set up information needed for the parser","title":"Parser.setup_parser()"},{"location":"api/midgard-parsers-_parser/#parsersetup_postprocessors","text":"setup_postprocessors(self) -> List[Callable[[], NoneType]] List postprocessors that should be called after parsing","title":"Parser.setup_postprocessors()"},{"location":"api/midgard-parsers-_parser/#parserupdate_dataset","text":"update_dataset(self, dset:Any) -> NoReturn Update the given dataset with the parsed data This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: dset (Dataset): The dataset to update with parsed data.","title":"Parser.update_dataset()"},{"location":"api/midgard-parsers-_parser_chain/","text":"midgard.parsers._parser_chain Basic functionality for parsing datafiles line by line Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() ChainParser ChainParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file with chained groups of information. You should inherit from this one, and at least specify the necessary parameters in setup_parser . ChainParser.parse_line() parse_line(self, line:str, cache:Dict[str, Any], parser:midgard.parsers._parser_chain.ParserDef) -> None Parse line A line is parsed by separating a line in fields. How the separation is done, is defined in the parser_def entry of the ParserDef. Args: line (str): Line to be parsed. cache (dict): Store temporary data. parser (dict): Dictionary with defined parsers with the keys 'parser_def', 'label' and 'end_marker'. ChainParser.read_data() read_data(self) -> None Read data from a data file and parse the contents ChainParser.setup_parser() setup_parser(self) -> Any Set up information needed for the parser Return an iterable of ParserDef's that describe the structure of the file that will be parsed ParserDef ParserDef(end_marker:Callable[[str, int, str], bool], label:Callable[[str, int], str], parser_def:Dict[str, Dict[str, Any]], skip_line:Union[Callable[[str], bool], NoneType]=None, end_callback:Union[Callable[[Dict[str, Any]], NoneType], NoneType]=None) A convenience class for defining the necessary fields of a parser A single parser can read and parse one group of datalines, defined through the ParserDef by specifying how to parse each line (parser_def), how to identify each line (label), how to recognize the end of the group of lines (end_marker) and finally what (if anything) should be done after all lines in a group is read (end_callback). The end_marker, label, skip_line and end_callback parameters should all be functions with the following signatures: end_marker = func(line, line_num, next_line) label = func(line, line_num) skip_line = func(line) end_callback = func(cache) The parser definition parser_def includes the parser , field , strip and delimiter entries. The parser entry points to the parser function and the field entry defines how to separate the line in fields. The separated fields are saved either in a dictionary or in a list. In the last case the line is split on whitespace by default. With the delimiter entry the default definition can be overwritten. Leading and trailing whitespace characters are removed by default before a line is parsed. This default can be overwritten by defining the characters, which should be removed with the 'strip' entry. The parser dictionary is defined like: parser_def = { <label>: {'fields': <dict or list of fields>, 'parser': <parser function>, 'delimiter': <optional delimiter for splitting line>, 'strip': <optional characters to be removed from beginning and end of line> }} Args: end_marker : A function returning True for the last line in a group. label : A function returning a label used in the parser_def. parser_def : A dict with 'parser' and 'fields' defining the parser. skip_line : A function returning True if the line should be skipped. end_callback : A function called after reading all lines in a group.","title":"midgard.parsers._parser_chain"},{"location":"api/midgard-parsers-_parser_chain/#midgardparsers_parser_chain","text":"Basic functionality for parsing datafiles line by line Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser_chain"},{"location":"api/midgard-parsers-_parser_chain/#chainparser","text":"ChainParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file with chained groups of information. You should inherit from this one, and at least specify the necessary parameters in setup_parser .","title":"ChainParser"},{"location":"api/midgard-parsers-_parser_chain/#chainparserparse_line","text":"parse_line(self, line:str, cache:Dict[str, Any], parser:midgard.parsers._parser_chain.ParserDef) -> None Parse line A line is parsed by separating a line in fields. How the separation is done, is defined in the parser_def entry of the ParserDef. Args: line (str): Line to be parsed. cache (dict): Store temporary data. parser (dict): Dictionary with defined parsers with the keys 'parser_def', 'label' and 'end_marker'.","title":"ChainParser.parse_line()"},{"location":"api/midgard-parsers-_parser_chain/#chainparserread_data","text":"read_data(self) -> None Read data from a data file and parse the contents","title":"ChainParser.read_data()"},{"location":"api/midgard-parsers-_parser_chain/#chainparsersetup_parser","text":"setup_parser(self) -> Any Set up information needed for the parser Return an iterable of ParserDef's that describe the structure of the file that will be parsed","title":"ChainParser.setup_parser()"},{"location":"api/midgard-parsers-_parser_chain/#parserdef","text":"ParserDef(end_marker:Callable[[str, int, str], bool], label:Callable[[str, int], str], parser_def:Dict[str, Dict[str, Any]], skip_line:Union[Callable[[str], bool], NoneType]=None, end_callback:Union[Callable[[Dict[str, Any]], NoneType], NoneType]=None) A convenience class for defining the necessary fields of a parser A single parser can read and parse one group of datalines, defined through the ParserDef by specifying how to parse each line (parser_def), how to identify each line (label), how to recognize the end of the group of lines (end_marker) and finally what (if anything) should be done after all lines in a group is read (end_callback). The end_marker, label, skip_line and end_callback parameters should all be functions with the following signatures: end_marker = func(line, line_num, next_line) label = func(line, line_num) skip_line = func(line) end_callback = func(cache) The parser definition parser_def includes the parser , field , strip and delimiter entries. The parser entry points to the parser function and the field entry defines how to separate the line in fields. The separated fields are saved either in a dictionary or in a list. In the last case the line is split on whitespace by default. With the delimiter entry the default definition can be overwritten. Leading and trailing whitespace characters are removed by default before a line is parsed. This default can be overwritten by defining the characters, which should be removed with the 'strip' entry. The parser dictionary is defined like: parser_def = { <label>: {'fields': <dict or list of fields>, 'parser': <parser function>, 'delimiter': <optional delimiter for splitting line>, 'strip': <optional characters to be removed from beginning and end of line> }} Args: end_marker : A function returning True for the last line in a group. label : A function returning a label used in the parser_def. parser_def : A dict with 'parser' and 'fields' defining the parser. skip_line : A function returning True if the line should be skipped. end_callback : A function called after reading all lines in a group.","title":"ParserDef"},{"location":"api/midgard-parsers-_parser_line/","text":"midgard.parsers._parser_line Basic functionality for parsing datafiles line by line using Numpy Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() LineParser LineParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for using numpy to parse a file line by line. You should inherit from this one, and at least specify the necessary parameters in setup_parser . LineParser.read_data() read_data(self) -> None Read data from the data file Uses the np.genfromtxt-function to parse the file. Any necessary parameters should be set by setup_parser . Override self.structure_data if the self.data-dictionary needs to be structured in a particular way. LineParser.setup_parser() setup_parser(self) -> Any Set up information needed for the parser This method should return a dictionary which contains all parameters needed by np.genfromtxt to do the actual parsing. LineParser.structure_data() structure_data(self) -> None Structure raw array data into the self.data dictionary This simple implementation creates a dictionary with one item per column in the array. Override this method for more complex use cases.","title":"midgard.parsers._parser_line"},{"location":"api/midgard-parsers-_parser_line/#midgardparsers_parser_line","text":"Basic functionality for parsing datafiles line by line using Numpy Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser_line"},{"location":"api/midgard-parsers-_parser_line/#lineparser","text":"LineParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for using numpy to parse a file line by line. You should inherit from this one, and at least specify the necessary parameters in setup_parser .","title":"LineParser"},{"location":"api/midgard-parsers-_parser_line/#lineparserread_data","text":"read_data(self) -> None Read data from the data file Uses the np.genfromtxt-function to parse the file. Any necessary parameters should be set by setup_parser . Override self.structure_data if the self.data-dictionary needs to be structured in a particular way.","title":"LineParser.read_data()"},{"location":"api/midgard-parsers-_parser_line/#lineparsersetup_parser","text":"setup_parser(self) -> Any Set up information needed for the parser This method should return a dictionary which contains all parameters needed by np.genfromtxt to do the actual parsing.","title":"LineParser.setup_parser()"},{"location":"api/midgard-parsers-_parser_line/#lineparserstructure_data","text":"structure_data(self) -> None Structure raw array data into the self.data dictionary This simple implementation creates a dictionary with one item per column in the array. Override this method for more complex use cases.","title":"LineParser.structure_data()"},{"location":"api/midgard-parsers-_parser_rinex/","text":"midgard.parsers._parser_rinex Basic functionality for parsing Rinex files Description: This module contains functions and classes for parsing Rinex files. This file defines the general structure shared by most types of Rinex files, including header information. More specific format details are implemented in subclasses. When calling the parser, you should call the apropriate parser for a given Rinex format. RinexHeader RinexHeader(marker:str, fields:Dict[str, Tuple[int, int]], parser:Callable[[Dict[str, str]], Dict[str, Any]]) A convenience class for defining how a Rinex header is parsed Args: marker : Marker of header (as defined in columns 60 and onward). fields : Dictionary with field names as keys, tuple of start- and end-columns as value. parser : Function that will parse the fields. RinexParser RinexParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, strict:bool=False) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for reading Rinex header data. You should inherit from this one, and at least implement parse_epochs . RinexParser.get_rinex_version() get_rinex_version(self) -> str Get version of Rinex file RinexParser.name (str) name = 'Rinex' RinexParser.parse_approx_position() parse_approx_position(self, fields:Dict[str, str]) -> Dict[str, Any] Parse station coordinates defined in RINEX header to instance variable data RinexParser.parse_comment() parse_comment(self, fields:Dict[str, str]) -> Dict[str, Any] Parse comment lines in RINEX header to instance variable header['comment'] RinexParser.parse_data_lines() parse_data_lines(self, lines, epoch_info) RinexParser.parse_epoch_line() parse_epoch_line(self, line) RinexParser.parse_float() parse_float(self, fields:Dict[str, str]) -> Dict[str, Any] Parse float entries of RINEX header to instance variable header RinexParser.parse_glonass_code_phase_bias() parse_glonass_code_phase_bias(self, fields:Dict[str, str]) -> Dict[str, Any] Parse GLONASS phase correction in RINEX header to instance variable header['glonass_bias'] self.header['glonass_bias'] = { : } RinexParser.parse_glonass_slot() parse_glonass_slot(self, fields:Dict[str, str]) -> Dict[str, Any] Parse GLONASS slot and frequency numbers given in RINEX header to instance variable header['glonass_slot'] self.header['glonass_slot'] = { : } RinexParser.parse_integer() parse_integer(self, fields:Dict[str, str]) -> Dict[str, Any] Parse integer entries of RINEX header to instance variable header RinexParser.parse_leap_seconds() parse_leap_seconds(self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header LEAP SECONDS to instance variable header self.header['leap_seconds'] = { 'leap_seconds': , 'future_past_leap_seconds': , 'week': , 'week_day': , 'time_sys': } RinexParser.parse_phase_shift() parse_phase_shift(self, fields:Dict[str, str], cache:List[Dict[str, str]]) -> Dict[str, Any] Parse entries of RINEX header SYS / PHASE SHIFT to instance variable header self.header['phase_shift'] = { <sat_sys>: { <obs_type>: { corr: <correction>, sat: <[satellite list]>}}} Example of phase_shift header entry: self.header['phase_shift'] = {'G': {'L1C': {'corr': '0.00000', 'sat': ['G01', 'G02', 'G03', ...]}, 'L1W': {'corr': '0.00000', 'sat': []}}, 'R': {'L1C': {'corr': '0.00000', 'sat': ['R01', 'R02', 'R07', 'R08']}}} TODO: Maybe better to add information to header['obstypes']? RinexParser.parse_scale_factor() parse_scale_factor(self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header SYS / SCALE FACTOR to instance variable header RinexParser.parse_string() parse_string(self, fields:Dict[str, str]) -> Dict[str, Any] Parse string entries of RINEX header to instance variable 'header' RinexParser.parse_sys_dcbs_applied() parse_sys_dcbs_applied(self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header SYS / DCBS APPLIED to instance variable header self.header['dcbs_applied'] = { : { prg: , url: }} RinexParser.parse_sys_obs_types() parse_sys_obs_types(self, fields:Dict[str, str], cache:List[Dict[str, str]]) -> Dict[str, Any] Parse observation types given in RINEX header to instance variable header['obstypes'] and data The data dictionaries obs , cycle_slip and signal_strength are initialized based on the given observation type in the RINEX header. self.header['obstypes'] = { <sat_sys>: [<ordered list with given observation types>]} RinexParser.parse_sys_pcvs_applied() parse_sys_pcvs_applied(self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header SYS / PCVS APPLIED to instance variable header self.header['pcvs_applied'] = { : { prg: , url: }} RinexParser.parse_time_of_first_obs() parse_time_of_first_obs(self, fields:Dict[str, str]) -> Dict[str, Any] Parse time of first observation given in RINEX header to instance variable header RinexParser.parse_time_of_last_obs() parse_time_of_last_obs(self, fields:Dict[str, str]) -> Dict[str, Any] Parse time of last observation given in RINEX header to instance variable header RinexParser.read_data() read_data(self) -> None Read data from the data file RinexParser.read_epochs() read_epochs(self, fid) -> None Read data from Rinex file Add data to self.data RinexParser.read_header() read_header(self, fid) -> None Read header from the rinex file Add header information to self.header parser_cache() parser_cache(func:Callable[[_ForwardRef('RinexParser'), Dict[str, str], List[Dict[str, str]]], Dict[str, Any]]) -> Callable[[_ForwardRef('RinexParser'), Dict[str, str]], Dict[str, Any]] Decorator for adding a cache to parser functions","title":"midgard.parsers._parser_rinex"},{"location":"api/midgard-parsers-_parser_rinex/#midgardparsers_parser_rinex","text":"Basic functionality for parsing Rinex files Description: This module contains functions and classes for parsing Rinex files. This file defines the general structure shared by most types of Rinex files, including header information. More specific format details are implemented in subclasses. When calling the parser, you should call the apropriate parser for a given Rinex format.","title":"midgard.parsers._parser_rinex"},{"location":"api/midgard-parsers-_parser_rinex/#rinexheader","text":"RinexHeader(marker:str, fields:Dict[str, Tuple[int, int]], parser:Callable[[Dict[str, str]], Dict[str, Any]]) A convenience class for defining how a Rinex header is parsed Args: marker : Marker of header (as defined in columns 60 and onward). fields : Dictionary with field names as keys, tuple of start- and end-columns as value. parser : Function that will parse the fields.","title":"RinexHeader"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparser","text":"RinexParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, strict:bool=False) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for reading Rinex header data. You should inherit from this one, and at least implement parse_epochs .","title":"RinexParser"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserget_rinex_version","text":"get_rinex_version(self) -> str Get version of Rinex file","title":"RinexParser.get_rinex_version()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparsername-str","text":"name = 'Rinex'","title":"RinexParser.name (str)"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_approx_position","text":"parse_approx_position(self, fields:Dict[str, str]) -> Dict[str, Any] Parse station coordinates defined in RINEX header to instance variable data","title":"RinexParser.parse_approx_position()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_comment","text":"parse_comment(self, fields:Dict[str, str]) -> Dict[str, Any] Parse comment lines in RINEX header to instance variable header['comment']","title":"RinexParser.parse_comment()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_data_lines","text":"parse_data_lines(self, lines, epoch_info)","title":"RinexParser.parse_data_lines()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_epoch_line","text":"parse_epoch_line(self, line)","title":"RinexParser.parse_epoch_line()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_float","text":"parse_float(self, fields:Dict[str, str]) -> Dict[str, Any] Parse float entries of RINEX header to instance variable header","title":"RinexParser.parse_float()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_glonass_code_phase_bias","text":"parse_glonass_code_phase_bias(self, fields:Dict[str, str]) -> Dict[str, Any] Parse GLONASS phase correction in RINEX header to instance variable header['glonass_bias'] self.header['glonass_bias'] = { : }","title":"RinexParser.parse_glonass_code_phase_bias()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_glonass_slot","text":"parse_glonass_slot(self, fields:Dict[str, str]) -> Dict[str, Any] Parse GLONASS slot and frequency numbers given in RINEX header to instance variable header['glonass_slot'] self.header['glonass_slot'] = { : }","title":"RinexParser.parse_glonass_slot()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_integer","text":"parse_integer(self, fields:Dict[str, str]) -> Dict[str, Any] Parse integer entries of RINEX header to instance variable header","title":"RinexParser.parse_integer()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_leap_seconds","text":"parse_leap_seconds(self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header LEAP SECONDS to instance variable header self.header['leap_seconds'] = { 'leap_seconds': , 'future_past_leap_seconds': , 'week': , 'week_day': , 'time_sys': }","title":"RinexParser.parse_leap_seconds()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_phase_shift","text":"parse_phase_shift(self, fields:Dict[str, str], cache:List[Dict[str, str]]) -> Dict[str, Any] Parse entries of RINEX header SYS / PHASE SHIFT to instance variable header self.header['phase_shift'] = { <sat_sys>: { <obs_type>: { corr: <correction>, sat: <[satellite list]>}}} Example of phase_shift header entry: self.header['phase_shift'] = {'G': {'L1C': {'corr': '0.00000', 'sat': ['G01', 'G02', 'G03', ...]}, 'L1W': {'corr': '0.00000', 'sat': []}}, 'R': {'L1C': {'corr': '0.00000', 'sat': ['R01', 'R02', 'R07', 'R08']}}} TODO: Maybe better to add information to header['obstypes']?","title":"RinexParser.parse_phase_shift()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_scale_factor","text":"parse_scale_factor(self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header SYS / SCALE FACTOR to instance variable header","title":"RinexParser.parse_scale_factor()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_string","text":"parse_string(self, fields:Dict[str, str]) -> Dict[str, Any] Parse string entries of RINEX header to instance variable 'header'","title":"RinexParser.parse_string()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_sys_dcbs_applied","text":"parse_sys_dcbs_applied(self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header SYS / DCBS APPLIED to instance variable header self.header['dcbs_applied'] = { : { prg: , url: }}","title":"RinexParser.parse_sys_dcbs_applied()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_sys_obs_types","text":"parse_sys_obs_types(self, fields:Dict[str, str], cache:List[Dict[str, str]]) -> Dict[str, Any] Parse observation types given in RINEX header to instance variable header['obstypes'] and data The data dictionaries obs , cycle_slip and signal_strength are initialized based on the given observation type in the RINEX header. self.header['obstypes'] = { <sat_sys>: [<ordered list with given observation types>]}","title":"RinexParser.parse_sys_obs_types()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_sys_pcvs_applied","text":"parse_sys_pcvs_applied(self, fields:Dict[str, str]) -> Dict[str, Any] Parse entries of RINEX header SYS / PCVS APPLIED to instance variable header self.header['pcvs_applied'] = { : { prg: , url: }}","title":"RinexParser.parse_sys_pcvs_applied()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_time_of_first_obs","text":"parse_time_of_first_obs(self, fields:Dict[str, str]) -> Dict[str, Any] Parse time of first observation given in RINEX header to instance variable header","title":"RinexParser.parse_time_of_first_obs()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserparse_time_of_last_obs","text":"parse_time_of_last_obs(self, fields:Dict[str, str]) -> Dict[str, Any] Parse time of last observation given in RINEX header to instance variable header","title":"RinexParser.parse_time_of_last_obs()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserread_data","text":"read_data(self) -> None Read data from the data file","title":"RinexParser.read_data()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserread_epochs","text":"read_epochs(self, fid) -> None Read data from Rinex file Add data to self.data","title":"RinexParser.read_epochs()"},{"location":"api/midgard-parsers-_parser_rinex/#rinexparserread_header","text":"read_header(self, fid) -> None Read header from the rinex file Add header information to self.header","title":"RinexParser.read_header()"},{"location":"api/midgard-parsers-_parser_rinex/#parser_cache","text":"parser_cache(func:Callable[[_ForwardRef('RinexParser'), Dict[str, str], List[Dict[str, str]]], Dict[str, Any]]) -> Callable[[_ForwardRef('RinexParser'), Dict[str, str]], Dict[str, Any]] Decorator for adding a cache to parser functions","title":"parser_cache()"},{"location":"api/midgard-parsers-_parser_sinex/","text":"midgard.parsers._parser_sinex Basic functionality for parsing Sinex datafiles Description: This module contains functions and classes for parsing Sinex datafiles. References: SINEX Format: https://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html SinexBlock SinexBlock(marker:str, fields:Tuple[midgard.parsers._parser_sinex.SinexField, ...], parser:Callable[[<built-in function array>, Tuple[str, ...]], Dict[str, Any]]) A convenience class for defining a Sinex block Args: marker : Sinex marker denoting the block. fields : Fields in Sinex block. parser : Function used to parse the data. SinexField SinexField(name:str, start_col:int, dtype:Union[str, NoneType], converter:Union[str, NoneType]=None) A convenience class for defining the fields in a Sinex block Args: name : Name of field. start_col : Starting column of field (First column is 0) dtype : String, using numpy notation, defining type of field, use None to ignore field. converter : Optional, name of converter to apply to field data. SinexParser SinexParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=None, header:bool=True) -> None An abstract base class that has basic methods for parsing a Sinex file This class provides functionality for parsing a sinex file with chained groups of information. You should inherit from this one, and at least specify which Sinex blocks you are interested in by implementing setup_parser , as well as implement methods that parse each block if needed. SinexParser.as_dataframe() as_dataframe(self, index:Union[str, List[str], NoneType]=None, marker:Union[str, NoneType]=None) -> pandas.core.frame.DataFrame Return the parsed data as a Pandas DataFrame This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: marker : Only return data from this marker in the DataFrame. index : Name of field to use as index. May also be a list of strings. Returns: Pandas DataFrame with the parsed data. SinexParser.parse_bias_epochs() parse_bias_epochs(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_blocks() parse_blocks(self, fid:Iterable[bytes]) -> None Parse contents of Sinex blocks Contents of Sinex blocks are stored as separate numpy-arrays in self._sinex Args: fid : Pointer to file being read. SinexParser.parse_file_comment() parse_file_comment(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_file_reference() parse_file_reference(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_header_line() parse_header_line(self, header_line:bytes) -> None Parse header of Sinex file Header information is stored in self.meta . Args: header_line : First line of Sinex file. SinexParser.parse_input_acknowledgements() parse_input_acknowledgements(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_input_files() parse_input_files(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_input_history() parse_input_history(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_lines() parse_lines(self, lines:List[bytes], fields:Tuple[midgard.parsers._parser_sinex.SinexField, ...]) -> <built-in function array> Parse lines in a Sinex file Args: lines : Lines to parse. fields : Definition of sinex fields in lines. Returns: Data contained in lines. SinexParser.parse_nutation_data() parse_nutation_data(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_precession_data() parse_precession_data(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_satellite_id() parse_satellite_id(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_satellite_phase_center() parse_satellite_phase_center(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_site_antenna() parse_site_antenna(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_site_data() parse_site_data(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_site_eccentricity() parse_site_eccentricity(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_site_gal_phase_center() parse_site_gal_phase_center(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_site_gps_phase_center() parse_site_gps_phase_center(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_site_id() parse_site_id(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_site_receiver() parse_site_receiver(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_solution_apriori() parse_solution_apriori(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_solution_epochs() parse_solution_epochs(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_solution_estimate() parse_solution_estimate(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_solution_matrix_apriori() parse_solution_matrix_apriori(self:'SinexParser', data:<built-in function array>, lower_upper:str, type:str='') -> Dict[str, Any] Parser for SOLUTION/MATRIX_APRIORI data Converts the input data to a symmetric matrix and adds it to self.data['SOLUTION/MATRIX_APRIORI']. The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters Index in the SOLUTION/ESTIMATE block. Missing elements in the matrix are assumed to be zero (0); consequently, zero elements may be omitted to reduce the size of this block. Args: data : Input data, raw data for SOLUTION/MATRIX_APRIORI block. lower_upper : Either 'L' or 'U', indicating whether the matrix is given in lower or upper form. type : Information about the type of matrix, optional. Returns: Dictionary with symmetric matrix as a numpy array. SinexParser.parse_solution_matrix_estimate() parse_solution_matrix_estimate(self:'SinexParser', data:<built-in function array>, lower_upper:str, type:str='') -> Dict[str, Any] Parser for SOLUTION/MATRIX_ESTIMATE data Converts the input data to a symmetric matrix and adds it to self.data['SOLUTION/MATRIX_ESTIMATE']. The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters Index in the SOLUTION/ESTIMATE block. Missing elements in the matrix are assumed to be zero (0); consequently, zero elements may be omitted to reduce the size of this block. Args: data : Input data, raw data for SOLUTION/MATRIX_ESTIMATE block. lower_upper : Either 'L' or 'U', indicating whether the matrix is given in lower or upper form. type : Information about the type of matrix, optional. Returns: Dictionary with symmetric matrix as a numpy array. SinexParser.parse_solution_normal_equation_matrix() parse_solution_normal_equation_matrix(self:'SinexParser', data:<built-in function array>, lower_upper:str, type:str='') -> Dict[str, Any] Parser for SOLUTION/NORMAL_EQUATION_MATRIX data Converts the input data to a symmetric matrix and adds it to self.data['SOLUTION/NORMAL_EQUATION_MATRIX']. The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters Index in the SOLUTION/ESTIMATE block. Missing elements in the matrix are assumed to be zero (0); consequently, zero elements may be omitted to reduce the size of this block. Args: data : Input data, raw data for SOLUTION/NORMAL_EQUATION_MATRIX block. lower_upper : Either 'L' or 'U', indicating whether the matrix is given in lower or upper form. type : Information about the type of matrix, optional. Returns: Dictionary with symmetric matrix as a numpy array. SinexParser.parse_solution_normal_equation_vector() parse_solution_normal_equation_vector(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_solution_statistics() parse_solution_statistics(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.parse_source_id() parse_source_id(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array. SinexParser.read_data() read_data(self) -> None Read data from a Sinex file and parse the contents First the whole Sinex file is read and the requested blocks are stored in self._sinex. After the file has been read, a parser is called on each block so that self.data is properly populated. SinexParser.setup_parser() setup_parser(self) -> Any Set up information needed for the parser Each individual Sinex-parser should at least implement this method. If the order the blocks are parsed is not important, the information should be returned as a set for optimal performance. If the parsing order is important, a tuple of SinexBlock-objects may be returned instead. Returns: Iterable of blocks in the Sinex file that should be parsed. parsing_factory() parsing_factory() -> Callable[..., Dict[str, Any]] Create a default parsing function for a Sinex block The default parsing function returns a dictionary containing all fields of the block as separated arrays. This will be stored in self.data['{marker}'] with the {marker} of the current block. Returns: Simple parsing function for one Sinex block. parsing_matrix_factory() parsing_matrix_factory(marker:str, size_marker:str) -> Callable[..., Dict[str, Any]] Create a parsing function for parsing a matrix within a Sinex block The default parsing function converts data to a symmetric matrix and stores it inside self.data[marker] . The size of the matrix is set to equal the number of parameters in the size_marker -block. If that block is not parsed/found. The size is set to the last given row index. If some zero elements in the matrix are omitted this might be wrong. Args: marker : Marker of Sinex block. size_marker : Marker of a different Sinex block indicating the size of the matrix. Returns: Simple parsing function for one Sinex block.","title":"midgard.parsers._parser_sinex"},{"location":"api/midgard-parsers-_parser_sinex/#midgardparsers_parser_sinex","text":"Basic functionality for parsing Sinex datafiles Description: This module contains functions and classes for parsing Sinex datafiles. References: SINEX Format: https://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html","title":"midgard.parsers._parser_sinex"},{"location":"api/midgard-parsers-_parser_sinex/#sinexblock","text":"SinexBlock(marker:str, fields:Tuple[midgard.parsers._parser_sinex.SinexField, ...], parser:Callable[[<built-in function array>, Tuple[str, ...]], Dict[str, Any]]) A convenience class for defining a Sinex block Args: marker : Sinex marker denoting the block. fields : Fields in Sinex block. parser : Function used to parse the data.","title":"SinexBlock"},{"location":"api/midgard-parsers-_parser_sinex/#sinexfield","text":"SinexField(name:str, start_col:int, dtype:Union[str, NoneType], converter:Union[str, NoneType]=None) A convenience class for defining the fields in a Sinex block Args: name : Name of field. start_col : Starting column of field (First column is 0) dtype : String, using numpy notation, defining type of field, use None to ignore field. converter : Optional, name of converter to apply to field data.","title":"SinexField"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparser","text":"SinexParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=None, header:bool=True) -> None An abstract base class that has basic methods for parsing a Sinex file This class provides functionality for parsing a sinex file with chained groups of information. You should inherit from this one, and at least specify which Sinex blocks you are interested in by implementing setup_parser , as well as implement methods that parse each block if needed.","title":"SinexParser"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparseras_dataframe","text":"as_dataframe(self, index:Union[str, List[str], NoneType]=None, marker:Union[str, NoneType]=None) -> pandas.core.frame.DataFrame Return the parsed data as a Pandas DataFrame This is a basic implementation, assuming the self.data -dictionary has a simple structure. More advanced parsers may need to reimplement this method. Args: marker : Only return data from this marker in the DataFrame. index : Name of field to use as index. May also be a list of strings. Returns: Pandas DataFrame with the parsed data.","title":"SinexParser.as_dataframe()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_bias_epochs","text":"parse_bias_epochs(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_bias_epochs()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_blocks","text":"parse_blocks(self, fid:Iterable[bytes]) -> None Parse contents of Sinex blocks Contents of Sinex blocks are stored as separate numpy-arrays in self._sinex Args: fid : Pointer to file being read.","title":"SinexParser.parse_blocks()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_file_comment","text":"parse_file_comment(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_file_comment()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_file_reference","text":"parse_file_reference(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_file_reference()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_header_line","text":"parse_header_line(self, header_line:bytes) -> None Parse header of Sinex file Header information is stored in self.meta . Args: header_line : First line of Sinex file.","title":"SinexParser.parse_header_line()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_input_acknowledgements","text":"parse_input_acknowledgements(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_input_acknowledgements()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_input_files","text":"parse_input_files(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_input_files()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_input_history","text":"parse_input_history(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_input_history()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_lines","text":"parse_lines(self, lines:List[bytes], fields:Tuple[midgard.parsers._parser_sinex.SinexField, ...]) -> <built-in function array> Parse lines in a Sinex file Args: lines : Lines to parse. fields : Definition of sinex fields in lines. Returns: Data contained in lines.","title":"SinexParser.parse_lines()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_nutation_data","text":"parse_nutation_data(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_nutation_data()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_precession_data","text":"parse_precession_data(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_precession_data()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_satellite_id","text":"parse_satellite_id(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_satellite_id()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_satellite_phase_center","text":"parse_satellite_phase_center(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_satellite_phase_center()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_site_antenna","text":"parse_site_antenna(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_antenna()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_site_data","text":"parse_site_data(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_data()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_site_eccentricity","text":"parse_site_eccentricity(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_eccentricity()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_site_gal_phase_center","text":"parse_site_gal_phase_center(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_gal_phase_center()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_site_gps_phase_center","text":"parse_site_gps_phase_center(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_gps_phase_center()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_site_id","text":"parse_site_id(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_id()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_site_receiver","text":"parse_site_receiver(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_site_receiver()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_solution_apriori","text":"parse_solution_apriori(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_solution_apriori()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_solution_epochs","text":"parse_solution_epochs(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_solution_epochs()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_solution_estimate","text":"parse_solution_estimate(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_solution_estimate()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_solution_matrix_apriori","text":"parse_solution_matrix_apriori(self:'SinexParser', data:<built-in function array>, lower_upper:str, type:str='') -> Dict[str, Any] Parser for SOLUTION/MATRIX_APRIORI data Converts the input data to a symmetric matrix and adds it to self.data['SOLUTION/MATRIX_APRIORI']. The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters Index in the SOLUTION/ESTIMATE block. Missing elements in the matrix are assumed to be zero (0); consequently, zero elements may be omitted to reduce the size of this block. Args: data : Input data, raw data for SOLUTION/MATRIX_APRIORI block. lower_upper : Either 'L' or 'U', indicating whether the matrix is given in lower or upper form. type : Information about the type of matrix, optional. Returns: Dictionary with symmetric matrix as a numpy array.","title":"SinexParser.parse_solution_matrix_apriori()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_solution_matrix_estimate","text":"parse_solution_matrix_estimate(self:'SinexParser', data:<built-in function array>, lower_upper:str, type:str='') -> Dict[str, Any] Parser for SOLUTION/MATRIX_ESTIMATE data Converts the input data to a symmetric matrix and adds it to self.data['SOLUTION/MATRIX_ESTIMATE']. The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters Index in the SOLUTION/ESTIMATE block. Missing elements in the matrix are assumed to be zero (0); consequently, zero elements may be omitted to reduce the size of this block. Args: data : Input data, raw data for SOLUTION/MATRIX_ESTIMATE block. lower_upper : Either 'L' or 'U', indicating whether the matrix is given in lower or upper form. type : Information about the type of matrix, optional. Returns: Dictionary with symmetric matrix as a numpy array.","title":"SinexParser.parse_solution_matrix_estimate()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_solution_normal_equation_matrix","text":"parse_solution_normal_equation_matrix(self:'SinexParser', data:<built-in function array>, lower_upper:str, type:str='') -> Dict[str, Any] Parser for SOLUTION/NORMAL_EQUATION_MATRIX data Converts the input data to a symmetric matrix and adds it to self.data['SOLUTION/NORMAL_EQUATION_MATRIX']. The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters Index in the SOLUTION/ESTIMATE block. Missing elements in the matrix are assumed to be zero (0); consequently, zero elements may be omitted to reduce the size of this block. Args: data : Input data, raw data for SOLUTION/NORMAL_EQUATION_MATRIX block. lower_upper : Either 'L' or 'U', indicating whether the matrix is given in lower or upper form. type : Information about the type of matrix, optional. Returns: Dictionary with symmetric matrix as a numpy array.","title":"SinexParser.parse_solution_normal_equation_matrix()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_solution_normal_equation_vector","text":"parse_solution_normal_equation_vector(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_solution_normal_equation_vector()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_solution_statistics","text":"parse_solution_statistics(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_solution_statistics()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserparse_source_id","text":"parse_source_id(self:'SinexParser', data:<built-in function array>, *params:str) -> Dict[str, Any] Simple parser for Sinex data Converts the input data to a dictionary of numpy arrays and returns it in order to add it to self.data['{marker}']. Ignores any block title parameters. Args: data : Input data, raw data for the block. params : Tuple of strings with parameters given after the marker at the start of the block. Returns: Dictionary with each column in the Sinex file as a numpy array.","title":"SinexParser.parse_source_id()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparserread_data","text":"read_data(self) -> None Read data from a Sinex file and parse the contents First the whole Sinex file is read and the requested blocks are stored in self._sinex. After the file has been read, a parser is called on each block so that self.data is properly populated.","title":"SinexParser.read_data()"},{"location":"api/midgard-parsers-_parser_sinex/#sinexparsersetup_parser","text":"setup_parser(self) -> Any Set up information needed for the parser Each individual Sinex-parser should at least implement this method. If the order the blocks are parsed is not important, the information should be returned as a set for optimal performance. If the parsing order is important, a tuple of SinexBlock-objects may be returned instead. Returns: Iterable of blocks in the Sinex file that should be parsed.","title":"SinexParser.setup_parser()"},{"location":"api/midgard-parsers-_parser_sinex/#parsing_factory","text":"parsing_factory() -> Callable[..., Dict[str, Any]] Create a default parsing function for a Sinex block The default parsing function returns a dictionary containing all fields of the block as separated arrays. This will be stored in self.data['{marker}'] with the {marker} of the current block. Returns: Simple parsing function for one Sinex block.","title":"parsing_factory()"},{"location":"api/midgard-parsers-_parser_sinex/#parsing_matrix_factory","text":"parsing_matrix_factory(marker:str, size_marker:str) -> Callable[..., Dict[str, Any]] Create a parsing function for parsing a matrix within a Sinex block The default parsing function converts data to a symmetric matrix and stores it inside self.data[marker] . The size of the matrix is set to equal the number of parameters in the size_marker -block. If that block is not parsed/found. The size is set to the last given row index. If some zero elements in the matrix are omitted this might be wrong. Args: marker : Marker of Sinex block. size_marker : Marker of a different Sinex block indicating the size of the matrix. Returns: Simple parsing function for one Sinex block.","title":"parsing_matrix_factory()"},{"location":"api/midgard-parsers-galileo_constellation_html/","text":"midgard.parsers.galileo_constellation_html A parser for reading IVS source names translation table GalileoConstellationHTMLParser GalileoConstellationHTMLParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, url:Union[str, NoneType]=None) -> None A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example GalileoConstellationHTMLParser.URL (str) URL = 'https://www.gsc-europa.eu/system-status/Constellation-Information' GalileoConstellationHTMLParser.download_html() download_html(self, url:Union[str, NoneType]=None) -> None Download html file from url TODO: Move this to files/url.py Args: url : URL to download from, if None use self.URL instead. GalileoConstellationHTMLParser.read_data() read_data(self) -> None Read tables from the HTML file The satellite table is placed in self.data, while the NAGU events are placed in self.meta[\"events\"]. GalileoConstellationHTMLParser.satellite_id() satellite_id(self, sat_id:str) -> Dict[str, Any] Get satellite info from satellite vehicle ID Args: sat_id : ID of satellite, for example E01. Returns: Dictionary with satellite info. GalileoConstellationHTMLParser.satellite_name() satellite_name(self, sat_name:str) -> Dict[str, Any] Get satellite info from name Args: sat_name : Name of satellite, for example GSAT0101. Returns: Dictionary with satellite info.","title":"midgard.parsers.galileo_constellation_html"},{"location":"api/midgard-parsers-galileo_constellation_html/#midgardparsersgalileo_constellation_html","text":"A parser for reading IVS source names translation table","title":"midgard.parsers.galileo_constellation_html"},{"location":"api/midgard-parsers-galileo_constellation_html/#galileoconstellationhtmlparser","text":"GalileoConstellationHTMLParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, url:Union[str, NoneType]=None) -> None A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example","title":"GalileoConstellationHTMLParser"},{"location":"api/midgard-parsers-galileo_constellation_html/#galileoconstellationhtmlparserurl-str","text":"URL = 'https://www.gsc-europa.eu/system-status/Constellation-Information'","title":"GalileoConstellationHTMLParser.URL (str)"},{"location":"api/midgard-parsers-galileo_constellation_html/#galileoconstellationhtmlparserdownload_html","text":"download_html(self, url:Union[str, NoneType]=None) -> None Download html file from url TODO: Move this to files/url.py Args: url : URL to download from, if None use self.URL instead.","title":"GalileoConstellationHTMLParser.download_html()"},{"location":"api/midgard-parsers-galileo_constellation_html/#galileoconstellationhtmlparserread_data","text":"read_data(self) -> None Read tables from the HTML file The satellite table is placed in self.data, while the NAGU events are placed in self.meta[\"events\"].","title":"GalileoConstellationHTMLParser.read_data()"},{"location":"api/midgard-parsers-galileo_constellation_html/#galileoconstellationhtmlparsersatellite_id","text":"satellite_id(self, sat_id:str) -> Dict[str, Any] Get satellite info from satellite vehicle ID Args: sat_id : ID of satellite, for example E01. Returns: Dictionary with satellite info.","title":"GalileoConstellationHTMLParser.satellite_id()"},{"location":"api/midgard-parsers-galileo_constellation_html/#galileoconstellationhtmlparsersatellite_name","text":"satellite_name(self, sat_name:str) -> Dict[str, Any] Get satellite info from name Args: sat_name : Name of satellite, for example GSAT0101. Returns: Dictionary with satellite info.","title":"GalileoConstellationHTMLParser.satellite_name()"},{"location":"api/midgard-parsers-gnss_antex/","text":"midgard.parsers.gnss_antex A parser for reading ANTEX format 1.4 data Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_antex', file_path='igs14.atx') data = p.as_dict() Description: Reads data from files in the GNSS Antenna Exchange (ANTEX) file format version 1.4 (see :cite: antex ). AntexParser AntexParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None A parser for reading ANTEX file The parser reads GNSS ANTEX format 1.4 (see :cite: antex ). The 'data' attribute is a dictionary with GNSS satellite PRN or receiver antenna as key. The GNSS satellite antenna corrections are time dependent and saved with \"valid from\" datetime object entry. The dictionary looks like: dout = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}} with following entries: =================== =================== ======================================================================== Value Type Description =================== =================== ======================================================================== azi numpy.ndarray Array with azimuth-elevation dependent antenna correction in [mm] with the shape: number of azimuth values x number of elevation values. azimuth numpy.ndarray List with azimuth values in [rad] corresponding to antenna corrections given in azi . cospar_id str COSPAR ID : yyyy -> year when the satellite was put in orbit, xxx -> sequential satellite number for that year, a -> alpha numeric sequence number within a launch elevation numpy.ndarray List with elevation values in [rad] corresponding to antenna corrections given in azi or noazi . str Frequency identifier (e.g. G01 - GPS L1) neu list North, East and Up eccentricities in [m]. The eccentricities of the mean antenna phase center is given relative to the antenna reference point (ARP) for receiver antennas or to the center of mass of the satellite in X-, Y- and Z-direction. noazi numpy.ndarray List with elevation dependent (non-azimuth-dependent) antenna correction in [mm]. str Satellite code e.g. GPS PRN, GLONASS slot or Galileo SVID number str Receiver antenna name together with radome code sat_code str Satellite code e.g. GPS SVN, GLONASS number or Galileo GSAT number sat_type str Satellite type (e.g. BLOCK IIA) valid_from datetime.datetime Start of validity period of satellite in GPS time valid_until datetime.datetime End of validity period of satellite in GPS time =================== =================== ======================================================================== The 'meta' attribute is a dictionary with following entries: =================== ======= ======================================================================== Value Type Description =================== ======= ======================================================================== comment list Header commments given in list line by line pcv_type str Phase center variation type ref_antenna str Reference antenna type for relative antenna ref_serial_num str Serial number of the reference antenna sat_sys str Satellite system version str Format version =================== ======= ======================================================================== Attributes: data (dict): Contains the (observation) data read from file. data_available (bool): Indicator of whether data are available. file_path (pathlib.PosixPath): File path. parser_name (str): Parser name. meta (dict): Contains metainformation read from file. AntexParser.parse_comment() parse_comment(self, line:Dict[str, str], _:Dict[str, Any]) -> None Parse comment lines in ANTEX header. AntexParser.parse_correction() parse_correction(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse antenna corrections entries of ANTEX antenna section. AntexParser.parse_default_meta() parse_default_meta(self, line:Dict[str, str], _:Dict[str, Any]) -> None Add the contents of line to meta Args: line : Dict containing the fields of a line. AntexParser.parse_num_of_frequencies() parse_num_of_frequencies(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse '# OF FREQUENCIES' entry of ANTEX antenna section. AntexParser.parse_section_float() parse_section_float(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse float entries of ANTEX header. AntexParser.parse_section_string() parse_section_string(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse string entries of ANTEX header. AntexParser.parse_string() parse_string(self, line:Dict[str, str], _:Dict[str, Any]) -> None Parse string entries of ANTEX header. AntexParser.parse_valid_from() parse_valid_from(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse 'VALID FROM' entries of ANTEX antenna section. AntexParser.parse_valid_until() parse_valid_until(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse 'VALID UNTIL' entries of ANTEX antenna section. AntexParser.save_correction() save_correction(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Save antenna correction in data structures. The antenna corrections are saved after reading of corrections for one frequency. Antenna correction data are saved in following data structure, whereby satellite antenna corrections are time dependent: self.data = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }} } AntexParser.setup_parser() setup_parser(self) -> Iterable[midgard.parsers._parser_chain.ParserDef] Parsers defined for reading ANTEX file line by line. First the ANTEX header information are read and afterwards the ANTEX corrections.","title":"midgard.parsers.gnss_antex"},{"location":"api/midgard-parsers-gnss_antex/#midgardparsersgnss_antex","text":"A parser for reading ANTEX format 1.4 data Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_antex', file_path='igs14.atx') data = p.as_dict() Description: Reads data from files in the GNSS Antenna Exchange (ANTEX) file format version 1.4 (see :cite: antex ).","title":"midgard.parsers.gnss_antex"},{"location":"api/midgard-parsers-gnss_antex/#antexparser","text":"AntexParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None A parser for reading ANTEX file The parser reads GNSS ANTEX format 1.4 (see :cite: antex ). The 'data' attribute is a dictionary with GNSS satellite PRN or receiver antenna as key. The GNSS satellite antenna corrections are time dependent and saved with \"valid from\" datetime object entry. The dictionary looks like: dout = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}} with following entries: =================== =================== ======================================================================== Value Type Description =================== =================== ======================================================================== azi numpy.ndarray Array with azimuth-elevation dependent antenna correction in [mm] with the shape: number of azimuth values x number of elevation values. azimuth numpy.ndarray List with azimuth values in [rad] corresponding to antenna corrections given in azi . cospar_id str COSPAR ID : yyyy -> year when the satellite was put in orbit, xxx -> sequential satellite number for that year, a -> alpha numeric sequence number within a launch elevation numpy.ndarray List with elevation values in [rad] corresponding to antenna corrections given in azi or noazi . str Frequency identifier (e.g. G01 - GPS L1) neu list North, East and Up eccentricities in [m]. The eccentricities of the mean antenna phase center is given relative to the antenna reference point (ARP) for receiver antennas or to the center of mass of the satellite in X-, Y- and Z-direction. noazi numpy.ndarray List with elevation dependent (non-azimuth-dependent) antenna correction in [mm]. str Satellite code e.g. GPS PRN, GLONASS slot or Galileo SVID number str Receiver antenna name together with radome code sat_code str Satellite code e.g. GPS SVN, GLONASS number or Galileo GSAT number sat_type str Satellite type (e.g. BLOCK IIA) valid_from datetime.datetime Start of validity period of satellite in GPS time valid_until datetime.datetime End of validity period of satellite in GPS time =================== =================== ======================================================================== The 'meta' attribute is a dictionary with following entries: =================== ======= ======================================================================== Value Type Description =================== ======= ======================================================================== comment list Header commments given in list line by line pcv_type str Phase center variation type ref_antenna str Reference antenna type for relative antenna ref_serial_num str Serial number of the reference antenna sat_sys str Satellite system version str Format version =================== ======= ======================================================================== Attributes: data (dict): Contains the (observation) data read from file. data_available (bool): Indicator of whether data are available. file_path (pathlib.PosixPath): File path. parser_name (str): Parser name. meta (dict): Contains metainformation read from file.","title":"AntexParser"},{"location":"api/midgard-parsers-gnss_antex/#antexparserparse_comment","text":"parse_comment(self, line:Dict[str, str], _:Dict[str, Any]) -> None Parse comment lines in ANTEX header.","title":"AntexParser.parse_comment()"},{"location":"api/midgard-parsers-gnss_antex/#antexparserparse_correction","text":"parse_correction(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse antenna corrections entries of ANTEX antenna section.","title":"AntexParser.parse_correction()"},{"location":"api/midgard-parsers-gnss_antex/#antexparserparse_default_meta","text":"parse_default_meta(self, line:Dict[str, str], _:Dict[str, Any]) -> None Add the contents of line to meta Args: line : Dict containing the fields of a line.","title":"AntexParser.parse_default_meta()"},{"location":"api/midgard-parsers-gnss_antex/#antexparserparse_num_of_frequencies","text":"parse_num_of_frequencies(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse '# OF FREQUENCIES' entry of ANTEX antenna section.","title":"AntexParser.parse_num_of_frequencies()"},{"location":"api/midgard-parsers-gnss_antex/#antexparserparse_section_float","text":"parse_section_float(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse float entries of ANTEX header.","title":"AntexParser.parse_section_float()"},{"location":"api/midgard-parsers-gnss_antex/#antexparserparse_section_string","text":"parse_section_string(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse string entries of ANTEX header.","title":"AntexParser.parse_section_string()"},{"location":"api/midgard-parsers-gnss_antex/#antexparserparse_string","text":"parse_string(self, line:Dict[str, str], _:Dict[str, Any]) -> None Parse string entries of ANTEX header.","title":"AntexParser.parse_string()"},{"location":"api/midgard-parsers-gnss_antex/#antexparserparse_valid_from","text":"parse_valid_from(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse 'VALID FROM' entries of ANTEX antenna section.","title":"AntexParser.parse_valid_from()"},{"location":"api/midgard-parsers-gnss_antex/#antexparserparse_valid_until","text":"parse_valid_until(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Parse 'VALID UNTIL' entries of ANTEX antenna section.","title":"AntexParser.parse_valid_until()"},{"location":"api/midgard-parsers-gnss_antex/#antexparsersave_correction","text":"save_correction(self, line:Dict[str, str], cache:Dict[str, Any]) -> None Save antenna correction in data structures. The antenna corrections are saved after reading of corrections for one frequency. Antenna correction data are saved in following data structure, whereby satellite antenna corrections are time dependent: self.data = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }} }","title":"AntexParser.save_correction()"},{"location":"api/midgard-parsers-gnss_antex/#antexparsersetup_parser","text":"setup_parser(self) -> Iterable[midgard.parsers._parser_chain.ParserDef] Parsers defined for reading ANTEX file line by line. First the ANTEX header information are read and afterwards the ANTEX corrections.","title":"AntexParser.setup_parser()"},{"location":"api/midgard-parsers-rinex3_header/","text":"midgard.parsers.rinex3_header A parser for reading IVS source names translation table Rinex3HeaderMixin Rinex3HeaderMixin() A mixin defining which headers are mandatory and optional in Rinex 3 Rinex3HeaderParser Rinex3HeaderParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, strict:bool=False) -> None A parser for reading just the Rinex3 header The data in the rinex file will not be parsed. Rinex3HeaderParser.name (str) name = 'Rinex' Rinex3HeaderParser.read_epochs() read_epochs(self, fid) -> None Do not read data from Rinex file Skip reading of data.","title":"midgard.parsers.rinex3_header"},{"location":"api/midgard-parsers-rinex3_header/#midgardparsersrinex3_header","text":"A parser for reading IVS source names translation table","title":"midgard.parsers.rinex3_header"},{"location":"api/midgard-parsers-rinex3_header/#rinex3headermixin","text":"Rinex3HeaderMixin() A mixin defining which headers are mandatory and optional in Rinex 3","title":"Rinex3HeaderMixin"},{"location":"api/midgard-parsers-rinex3_header/#rinex3headerparser","text":"Rinex3HeaderParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, strict:bool=False) -> None A parser for reading just the Rinex3 header The data in the rinex file will not be parsed.","title":"Rinex3HeaderParser"},{"location":"api/midgard-parsers-rinex3_header/#rinex3headerparsername-str","text":"name = 'Rinex'","title":"Rinex3HeaderParser.name (str)"},{"location":"api/midgard-parsers-rinex3_header/#rinex3headerparserread_epochs","text":"read_epochs(self, fid) -> None Do not read data from Rinex file Skip reading of data.","title":"Rinex3HeaderParser.read_epochs()"},{"location":"api/midgard-parsers-rinex_obs/","text":"midgard.parsers.rinex_obs A parser for reading Rinex observation files RinexObsParser RinexObsParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, strict:bool=False) -> None A parser for reading Rinex observation files Different versions of the Rinex format are implemented as subclasses RinexObsParser.name (str) name = 'Rinex' RinexObsParser.read_data() read_data(self) -> None Dispatch to correct subclass based on version in Rinex file Need to make sure the dispatch only happens for RinexObsParsers, not for subclasses.","title":"midgard.parsers.rinex_obs"},{"location":"api/midgard-parsers-rinex_obs/#midgardparsersrinex_obs","text":"A parser for reading Rinex observation files","title":"midgard.parsers.rinex_obs"},{"location":"api/midgard-parsers-rinex_obs/#rinexobsparser","text":"RinexObsParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, strict:bool=False) -> None A parser for reading Rinex observation files Different versions of the Rinex format are implemented as subclasses","title":"RinexObsParser"},{"location":"api/midgard-parsers-rinex_obs/#rinexobsparsername-str","text":"name = 'Rinex'","title":"RinexObsParser.name (str)"},{"location":"api/midgard-parsers-rinex_obs/#rinexobsparserread_data","text":"read_data(self) -> None Dispatch to correct subclass based on version in Rinex file Need to make sure the dispatch only happens for RinexObsParsers, not for subclasses.","title":"RinexObsParser.read_data()"},{"location":"api/midgard-parsers-vlbi_source_names/","text":"midgard.parsers.vlbi_source_names A parser for reading IVS source names translation table VlbiSourceNamesParser VlbiSourceNamesParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file VlbiSourceNamesParser.setup_parser() setup_parser(self) -> Dict[str, Any] Set up information needed for the parser This should return a dictionary with all parameters needed by np.genfromtxt to do the actual parsing. Returns: Parameters needed by np.genfromtxt to parse the input file. VlbiSourceNamesParser.structure_data() structure_data(self) -> None Structure raw array data into the self.data dictionary Using the IVS name as key.","title":"midgard.parsers.vlbi_source_names"},{"location":"api/midgard-parsers-vlbi_source_names/#midgardparsersvlbi_source_names","text":"A parser for reading IVS source names translation table","title":"midgard.parsers.vlbi_source_names"},{"location":"api/midgard-parsers-vlbi_source_names/#vlbisourcenamesparser","text":"VlbiSourceNamesParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file","title":"VlbiSourceNamesParser"},{"location":"api/midgard-parsers-vlbi_source_names/#vlbisourcenamesparsersetup_parser","text":"setup_parser(self) -> Dict[str, Any] Set up information needed for the parser This should return a dictionary with all parameters needed by np.genfromtxt to do the actual parsing. Returns: Parameters needed by np.genfromtxt to parse the input file.","title":"VlbiSourceNamesParser.setup_parser()"},{"location":"api/midgard-parsers-vlbi_source_names/#vlbisourcenamesparserstructure_data","text":"structure_data(self) -> None Structure raw array data into the self.data dictionary Using the IVS name as key.","title":"VlbiSourceNamesParser.structure_data()"},{"location":"api/midgard-parsers-wip_rinex2_obs/","text":"midgard.parsers.wip_rinex2_obs A parser for reading IVS source names translation table Rinex2ObsParser Rinex2ObsParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, strict:bool=False) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file Rinex2ObsParser.name (str) name = 'Rinex'","title":"midgard.parsers.wip_rinex2_obs"},{"location":"api/midgard-parsers-wip_rinex2_obs/#midgardparserswip_rinex2_obs","text":"A parser for reading IVS source names translation table","title":"midgard.parsers.wip_rinex2_obs"},{"location":"api/midgard-parsers-wip_rinex2_obs/#rinex2obsparser","text":"Rinex2ObsParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, strict:bool=False) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file","title":"Rinex2ObsParser"},{"location":"api/midgard-parsers-wip_rinex2_obs/#rinex2obsparsername-str","text":"name = 'Rinex'","title":"Rinex2ObsParser.name (str)"},{"location":"api/midgard-parsers-wip_rinex3_obs/","text":"midgard.parsers.wip_rinex3_obs A parser for reading IVS source names translation table Rinex3ObsParser Rinex3ObsParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, strict:bool=False) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file Rinex3ObsParser.EPOCH_FIELDS (dict) EPOCH_FIELDS = {'identifier': (0, 1), 'year': (2, 6), 'month': (7, 9), 'day': (10, 12), 'hour': (13, 15), 'minute': (16, 18), 'second': (19, 21), 'frac_sec': (21, 29), 'epoch_flag': (30, 32), 'num_data_lines': (33, 35)} Rinex3ObsParser.name (str) name = 'Rinex' Rinex3ObsParser.parse_data_lines() parse_data_lines(self, lines, epoch_info) -> Dict[str, Any] Rinex3ObsParser.parse_epoch_line() parse_epoch_line(self, line) -> Dict[str, Any] Read data from Rinex file Add data to self.data","title":"midgard.parsers.wip_rinex3_obs"},{"location":"api/midgard-parsers-wip_rinex3_obs/#midgardparserswip_rinex3_obs","text":"A parser for reading IVS source names translation table","title":"midgard.parsers.wip_rinex3_obs"},{"location":"api/midgard-parsers-wip_rinex3_obs/#rinex3obsparser","text":"Rinex3ObsParser(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, strict:bool=False) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file","title":"Rinex3ObsParser"},{"location":"api/midgard-parsers-wip_rinex3_obs/#rinex3obsparserepoch_fields-dict","text":"EPOCH_FIELDS = {'identifier': (0, 1), 'year': (2, 6), 'month': (7, 9), 'day': (10, 12), 'hour': (13, 15), 'minute': (16, 18), 'second': (19, 21), 'frac_sec': (21, 29), 'epoch_flag': (30, 32), 'num_data_lines': (33, 35)}","title":"Rinex3ObsParser.EPOCH_FIELDS (dict)"},{"location":"api/midgard-parsers-wip_rinex3_obs/#rinex3obsparsername-str","text":"name = 'Rinex'","title":"Rinex3ObsParser.name (str)"},{"location":"api/midgard-parsers-wip_rinex3_obs/#rinex3obsparserparse_data_lines","text":"parse_data_lines(self, lines, epoch_info) -> Dict[str, Any]","title":"Rinex3ObsParser.parse_data_lines()"},{"location":"api/midgard-parsers-wip_rinex3_obs/#rinex3obsparserparse_epoch_line","text":"parse_epoch_line(self, line) -> Dict[str, Any] Read data from Rinex file Add data to self.data","title":"Rinex3ObsParser.parse_epoch_line()"},{"location":"api/midgard-parsers/","text":"midgard.parsers Framework for parsers Description: To add a new parser, simply create a new .py-file which defines a class inheriting from parsers.Parser. The class needs to be decorated with the midgard.dev.plugins.register decorator as follows: from midgard.parsers import parser from midgard.lib import plugins @plugins.register class MyNewParser(parser.Parser): ... To use a parser, you will typically use the parse_file -function defined below from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() The name used in parse_file to call the parser is the name of the module (file) containing the parser. names() names() -> List[str] List the names of the available parsers Returns: Names of the available parsers parse_file() parse_file(parser_name:str, file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, parser_logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, timer_logger:Union[Callable[[str], NoneType], NoneType]=None, use_cache:bool=False, **parser_args:Any) -> midgard.parsers._parser.Parser Use the given parser on a file and return parsed data Specify parser_name and file_path to the file that should be parsed. The following parsers are available: {doc_parser_names} Data can be retrieved either as Dictionaries, Pandas DataFrames or Midgard Datasets by using one of the methods as_dict , as_dataframe or as_dataset . Example: >>> df = parse_file('rinex2_obs', 'ande3160.16o').as_dataframe() # doctest: +SKIP Args: parser_name : Name of parser file_path : Path to file that should be parsed. encoding : Encoding in file that is parsed. parser_logger : Logging function that will be used by parser. timer_logger : Logging function that will be used to log timing information. use_cache : Whether to use a cache to avoid parsing the same file several times. parser_args : Input arguments to the parser Returns: Parser : Parser with the parsed data","title":"midgard.parsers"},{"location":"api/midgard-parsers/#midgardparsers","text":"Framework for parsers Description: To add a new parser, simply create a new .py-file which defines a class inheriting from parsers.Parser. The class needs to be decorated with the midgard.dev.plugins.register decorator as follows: from midgard.parsers import parser from midgard.lib import plugins @plugins.register class MyNewParser(parser.Parser): ... To use a parser, you will typically use the parse_file -function defined below from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() The name used in parse_file to call the parser is the name of the module (file) containing the parser.","title":"midgard.parsers"},{"location":"api/midgard-parsers/#names","text":"names() -> List[str] List the names of the available parsers Returns: Names of the available parsers","title":"names()"},{"location":"api/midgard-parsers/#parse_file","text":"parse_file(parser_name:str, file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, parser_logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, timer_logger:Union[Callable[[str], NoneType], NoneType]=None, use_cache:bool=False, **parser_args:Any) -> midgard.parsers._parser.Parser Use the given parser on a file and return parsed data Specify parser_name and file_path to the file that should be parsed. The following parsers are available: {doc_parser_names} Data can be retrieved either as Dictionaries, Pandas DataFrames or Midgard Datasets by using one of the methods as_dict , as_dataframe or as_dataset . Example: >>> df = parse_file('rinex2_obs', 'ande3160.16o').as_dataframe() # doctest: +SKIP Args: parser_name : Name of parser file_path : Path to file that should be parsed. encoding : Encoding in file that is parsed. parser_logger : Logging function that will be used by parser. timer_logger : Logging function that will be used to log timing information. use_cache : Whether to use a cache to avoid parsing the same file several times. parser_args : Input arguments to the parser Returns: Parser : Parser with the parsed data","title":"parse_file()"},{"location":"api/midgard/","text":"midgard Midgard, the Python Geodesy library Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting. Midgard comes organized into different subpackages: ionosphere parsers math files collections dev config coords Look for help inside each subpackage: >>> from midgard import subpackage # doctest: +SKIP >>> help(subpackage) # doctest: +SKIP Current maintainers: Michael D\u00e4hnn michael.daehnn@kartverket.no Geir Arne Hjelle geir.arne.hjelle@kartverket.no Ann-Silje Kirkvik ann-silje.kirkvik@kartverket.no Mohammed Ouasou mohammed.ouasou@kartverket.no","title":"midgard"},{"location":"api/midgard/#midgard","text":"Midgard, the Python Geodesy library Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting. Midgard comes organized into different subpackages: ionosphere parsers math files collections dev config coords Look for help inside each subpackage: >>> from midgard import subpackage # doctest: +SKIP >>> help(subpackage) # doctest: +SKIP Current maintainers: Michael D\u00e4hnn michael.daehnn@kartverket.no Geir Arne Hjelle geir.arne.hjelle@kartverket.no Ann-Silje Kirkvik ann-silje.kirkvik@kartverket.no Mohammed Ouasou mohammed.ouasou@kartverket.no","title":"midgard"}]}