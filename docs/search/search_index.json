{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Midgard, the Python Geodesy library Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting. Installing Midgard Midgard is available at PyPI . You can install it by simply running python -m pip install midgard Installing Midgard from source Midgard depends on several other brilliant Python packages, like for instance numpy, scipy, astropy etc. We recommend using the Anaconda distribution to ease the installation of these dependencies. Install Anaconda Go to www.anaconda.com/download , and download Anaconda for Python 3. Download the Midgard source code If you have not already done so, download the Midgard source code from Github: github.com/kartverket/midgard . Then enter the main midgard directory before running the install command below. cd midgard Install dependencies You should now install the necessary dependencies using the environment.yml -file. You can do this either in your current conda environment, or choose to create a new midgard -environment. In order to use midgard in other projects you need to install midgard in the same environment as those projects. To install midgard in your current environment, do conda env update -f environment.yml To install midgard in a new environment named midgard and activate it, do conda env create -n midgard -f environment.yml conda activate midgard Install the Midgard package To do the actual installation of Midgard, use the flit packaging tool: python -m flit install --dep production If you want to develop the Midgard package, install it in editable mode using python -m flit install -s On Windows, you can install in editable mode using python -m flit install --pth-file Using Midgard Midgard comes organized into different subpackages. To see info about the different subpackages, use the Python help system: >>> import midgard >>> help(midgard) Information about individual subpackages is also available on the Midgard website .","title":"Home"},{"location":"#midgard-the-python-geodesy-library","text":"Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting.","title":"Midgard, the Python Geodesy library"},{"location":"#installing-midgard","text":"Midgard is available at PyPI . You can install it by simply running python -m pip install midgard","title":"Installing Midgard"},{"location":"#installing-midgard-from-source","text":"Midgard depends on several other brilliant Python packages, like for instance numpy, scipy, astropy etc. We recommend using the Anaconda distribution to ease the installation of these dependencies.","title":"Installing Midgard from source"},{"location":"#install-anaconda","text":"Go to www.anaconda.com/download , and download Anaconda for Python 3.","title":"Install Anaconda"},{"location":"#download-the-midgard-source-code","text":"If you have not already done so, download the Midgard source code from Github: github.com/kartverket/midgard . Then enter the main midgard directory before running the install command below. cd midgard","title":"Download the Midgard source code"},{"location":"#install-dependencies","text":"You should now install the necessary dependencies using the environment.yml -file. You can do this either in your current conda environment, or choose to create a new midgard -environment. In order to use midgard in other projects you need to install midgard in the same environment as those projects. To install midgard in your current environment, do conda env update -f environment.yml To install midgard in a new environment named midgard and activate it, do conda env create -n midgard -f environment.yml conda activate midgard","title":"Install dependencies"},{"location":"#install-the-midgard-package","text":"To do the actual installation of Midgard, use the flit packaging tool: python -m flit install --dep production If you want to develop the Midgard package, install it in editable mode using python -m flit install -s On Windows, you can install in editable mode using python -m flit install --pth-file","title":"Install the Midgard package"},{"location":"#using-midgard","text":"Midgard comes organized into different subpackages. To see info about the different subpackages, use the Python help system: >>> import midgard >>> help(midgard) Information about individual subpackages is also available on the Midgard website .","title":"Using Midgard"},{"location":"api/midgard-collections/","text":"midgard.collections midgard.collections.enums Framework for working with enumerations Description: Custom enumerations used for structured names. You can add your own enumerations in your own application by importing register_enum and using that to register your own enums. Example: Create your own enumeration: from midgard.collections.enums import register_enum @register_enum(\"reference_ellipsoid\") class ReferenceEllipsoid(enum.IntEnum): wgs84 = 1 grs80 = 2 wgs72 = 3 Use enumerations in your code: from midgard.collections import enums enums.get_value(\"gnss_freq_G\", \"L1\") enums.get_value(\"gnss_freq_G\", \"L1\") + 1 enums.get_enum(\"gnss_freq_G\") enums.get_enum(\"gnss_freq_G\").L1 enums.get_enum(\"gnss_freq_G\").L1 + 1 enums.gnss_freq_G.L1 enums.gnss_freq_G.L1 * 2 GPSFrequency Full name: midgard.collections.enums.GPSFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies LogColor Full name: midgard.collections.enums.LogColor Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging LogLevel Full name: midgard.collections.enums.LogLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show NotGiven Full name: midgard.collections.enums.NotGiven Signature: () Dummy class used as a marker for a argument not given, used instead of None because None is valid value WriteLevel Full name: midgard.collections.enums.WriteLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk enums () Full name: midgard.collections.enums.enums Signature: () -> List[str] Return a list of available enums Returns: Names of available enums. get_enum () Full name: midgard.collections.enums.get_enum Signature: (name:str) -> enum.EnumMeta Return a named Enumeration Names are defined by the @register_enum-decorator. If the name-parameter is not a valid enum, the function will raise an UnknownEnumError and list the available enumerations. Args: name : Name used for Enumeration. Returns: Enumeration with the given name. get_value () Full name: midgard.collections.enums.get_value Signature: (name:str, value:str, default:Any=<class 'midgard.collections.enums.NotGiven'>) -> enum.Enum Return the value of a named Enumeration Names are defined by the @register_enum-decorator. Args: name : Name used for Enumeration. value : Value of Enumeration. default : Optional object returned if enumeration does not contain value Returns: Value of enumeration with the given name. gnss_freq_G Full name: midgard.collections.enums.gnss_freq_G Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies has_value () Full name: midgard.collections.enums.has_value Signature: (name:str, value:str) -> bool Check whether a named Enumeration defines a given value Args: name : Name used for Enumeration. value : Value of Enumeration. Returns: True if Enumeration defines value, False otherwise log_color Full name: midgard.collections.enums.log_color Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging log_level Full name: midgard.collections.enums.log_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show register_enum () Full name: midgard.collections.enums.register_enum Signature: (name:str) -> Callable[[enum.EnumMeta], enum.EnumMeta] Register a named Enumeration This allows for getting Enumerations with the get_enum-function. Args: name : Name used for Enumeration. Returns: Decorator that registers an Enumeration. write_level Full name: midgard.collections.enums.write_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk","title":"midgard.collections"},{"location":"api/midgard-collections/#midgardcollections","text":"","title":"midgard.collections"},{"location":"api/midgard-collections/#midgardcollectionsenums","text":"Framework for working with enumerations Description: Custom enumerations used for structured names. You can add your own enumerations in your own application by importing register_enum and using that to register your own enums. Example: Create your own enumeration: from midgard.collections.enums import register_enum @register_enum(\"reference_ellipsoid\") class ReferenceEllipsoid(enum.IntEnum): wgs84 = 1 grs80 = 2 wgs72 = 3 Use enumerations in your code: from midgard.collections import enums enums.get_value(\"gnss_freq_G\", \"L1\") enums.get_value(\"gnss_freq_G\", \"L1\") + 1 enums.get_enum(\"gnss_freq_G\") enums.get_enum(\"gnss_freq_G\").L1 enums.get_enum(\"gnss_freq_G\").L1 + 1 enums.gnss_freq_G.L1 enums.gnss_freq_G.L1 * 2","title":"midgard.collections.enums"},{"location":"api/midgard-collections/#gpsfrequency","text":"Full name: midgard.collections.enums.GPSFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies","title":"GPSFrequency"},{"location":"api/midgard-collections/#logcolor","text":"Full name: midgard.collections.enums.LogColor Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging","title":"LogColor"},{"location":"api/midgard-collections/#loglevel","text":"Full name: midgard.collections.enums.LogLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show","title":"LogLevel"},{"location":"api/midgard-collections/#notgiven","text":"Full name: midgard.collections.enums.NotGiven Signature: () Dummy class used as a marker for a argument not given, used instead of None because None is valid value","title":"NotGiven"},{"location":"api/midgard-collections/#writelevel","text":"Full name: midgard.collections.enums.WriteLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk","title":"WriteLevel"},{"location":"api/midgard-collections/#enums","text":"Full name: midgard.collections.enums.enums Signature: () -> List[str] Return a list of available enums Returns: Names of available enums.","title":"enums()"},{"location":"api/midgard-collections/#get_enum","text":"Full name: midgard.collections.enums.get_enum Signature: (name:str) -> enum.EnumMeta Return a named Enumeration Names are defined by the @register_enum-decorator. If the name-parameter is not a valid enum, the function will raise an UnknownEnumError and list the available enumerations. Args: name : Name used for Enumeration. Returns: Enumeration with the given name.","title":"get_enum()"},{"location":"api/midgard-collections/#get_value","text":"Full name: midgard.collections.enums.get_value Signature: (name:str, value:str, default:Any=<class 'midgard.collections.enums.NotGiven'>) -> enum.Enum Return the value of a named Enumeration Names are defined by the @register_enum-decorator. Args: name : Name used for Enumeration. value : Value of Enumeration. default : Optional object returned if enumeration does not contain value Returns: Value of enumeration with the given name.","title":"get_value()"},{"location":"api/midgard-collections/#gnss_freq_g","text":"Full name: midgard.collections.enums.gnss_freq_G Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies","title":"gnss_freq_G"},{"location":"api/midgard-collections/#has_value","text":"Full name: midgard.collections.enums.has_value Signature: (name:str, value:str) -> bool Check whether a named Enumeration defines a given value Args: name : Name used for Enumeration. value : Value of Enumeration. Returns: True if Enumeration defines value, False otherwise","title":"has_value()"},{"location":"api/midgard-collections/#log_color","text":"Full name: midgard.collections.enums.log_color Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging","title":"log_color"},{"location":"api/midgard-collections/#log_level","text":"Full name: midgard.collections.enums.log_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show","title":"log_level"},{"location":"api/midgard-collections/#register_enum","text":"Full name: midgard.collections.enums.register_enum Signature: (name:str) -> Callable[[enum.EnumMeta], enum.EnumMeta] Register a named Enumeration This allows for getting Enumerations with the get_enum-function. Args: name : Name used for Enumeration. Returns: Decorator that registers an Enumeration.","title":"register_enum()"},{"location":"api/midgard-collections/#write_level","text":"Full name: midgard.collections.enums.write_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk","title":"write_level"},{"location":"api/midgard-config/","text":"midgard.config midgard.config.config Midgard library module for handling of configuration settings Description: A Configuration consists of one or several sections. Each ConfigurationSection consists of one or more entries. Each ConfigurationEntry consists of a key and a value. Examples: For basic use, an entry is looked up by simple attribute access. For instance if cfg is a Configuration with the section midgard which has an entry foo = bar : >>> cfg = Configuration(\"config_name\") >>> cfg.update(\"midgard\", \"foo\", \"bar\") >>> cfg.midgard.foo ConfigurationEntry(key='foo', value='bar') ConfigurationEntry has several access methods that convert the entry to a given data type: >>> cfg.update(\"midgard\", \"foo_pi\", 3.14, source=\"command line\") >>> cfg.midgard.foo_pi ConfigurationEntry(key='foo_pi', value='3.14') >>> cfg.midgard.foo_pi.float 3.14 >>> cfg.midgard.foo_pi.str '3.14' >>> cfg.midgard.foo_pi.tuple ('3.14',) Sources: Each configuration entry records its source. That is, where that entry was defined. Examples include read from file, set as a command line option, or programmatically from a dictionary. The source can be looked up on an individual entry, or for all entries in a configuration. >>> cfg.midgard.foo_pi.source 'command line' >>> cfg.sources # doctest: +SKIP {'/home/midgard/midgard.conf', 'command line'} Profiles: Fallback Configuration: Master Section: Replacement Variables: Help text and Type hints: CasedConfigParser Full name: midgard.config.config.CasedConfigParser Signature: (defaults=None, dict_type=<class 'collections.OrderedDict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x7efd5c7a2200>, converters=<object object at 0x7efd5c7a2200>) ConfigParser with case-sensitive keys Configuration Full name: midgard.config.config.Configuration Signature: (name:str) -> None Represents a Configuration ConfigurationEntry Full name: midgard.config.config.ConfigurationEntry Signature: (key:str, value:Any, *, source:str='', meta:Union[Dict[str, str], NoneType]=None, vars_dict:Union[Dict[str, str], NoneType]=None, _used_as:Union[Set[str], NoneType]=None) -> None ConfigurationSection Full name: midgard.config.config.ConfigurationSection Signature: (name:str) -> None FMT_date (str) FMT_date = '%Y-%m-%d' FMT_datetime (str) FMT_datetime = '%Y-%m-%d %H:%M:%S' FMT_dt_file (str) FMT_dt_file = '%Y%m%d-%H%M%S' midgard.config.files Midgard library module for opening files based on a special configuration Example: from midgard.config import files with files.open('eopc04_iau', mode='rt') as fid: for line in fid: print(line.strip()) Description: This module handles opening of files registered in a special configuration, typically a configuration file. The cfg.files.open and cfg.files.open_path methods are both wrappers around the built-in open function, and behave mainly similar. In particular, they accept all the same keyword arguments (like for instance mode). Furthermore, to make sure files are properly closed they should normally be used with a context manager as in the example above. FileConfiguration Full name: midgard.config.files.FileConfiguration Signature: (name:str) -> None Configuration for handling files","title":"midgard.config"},{"location":"api/midgard-config/#midgardconfig","text":"","title":"midgard.config"},{"location":"api/midgard-config/#midgardconfigconfig","text":"Midgard library module for handling of configuration settings Description: A Configuration consists of one or several sections. Each ConfigurationSection consists of one or more entries. Each ConfigurationEntry consists of a key and a value. Examples: For basic use, an entry is looked up by simple attribute access. For instance if cfg is a Configuration with the section midgard which has an entry foo = bar : >>> cfg = Configuration(\"config_name\") >>> cfg.update(\"midgard\", \"foo\", \"bar\") >>> cfg.midgard.foo ConfigurationEntry(key='foo', value='bar') ConfigurationEntry has several access methods that convert the entry to a given data type: >>> cfg.update(\"midgard\", \"foo_pi\", 3.14, source=\"command line\") >>> cfg.midgard.foo_pi ConfigurationEntry(key='foo_pi', value='3.14') >>> cfg.midgard.foo_pi.float 3.14 >>> cfg.midgard.foo_pi.str '3.14' >>> cfg.midgard.foo_pi.tuple ('3.14',) Sources: Each configuration entry records its source. That is, where that entry was defined. Examples include read from file, set as a command line option, or programmatically from a dictionary. The source can be looked up on an individual entry, or for all entries in a configuration. >>> cfg.midgard.foo_pi.source 'command line' >>> cfg.sources # doctest: +SKIP {'/home/midgard/midgard.conf', 'command line'} Profiles: Fallback Configuration: Master Section: Replacement Variables: Help text and Type hints:","title":"midgard.config.config"},{"location":"api/midgard-config/#casedconfigparser","text":"Full name: midgard.config.config.CasedConfigParser Signature: (defaults=None, dict_type=<class 'collections.OrderedDict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x7efd5c7a2200>, converters=<object object at 0x7efd5c7a2200>) ConfigParser with case-sensitive keys","title":"CasedConfigParser"},{"location":"api/midgard-config/#configuration","text":"Full name: midgard.config.config.Configuration Signature: (name:str) -> None Represents a Configuration","title":"Configuration"},{"location":"api/midgard-config/#configurationentry","text":"Full name: midgard.config.config.ConfigurationEntry Signature: (key:str, value:Any, *, source:str='', meta:Union[Dict[str, str], NoneType]=None, vars_dict:Union[Dict[str, str], NoneType]=None, _used_as:Union[Set[str], NoneType]=None) -> None","title":"ConfigurationEntry"},{"location":"api/midgard-config/#configurationsection","text":"Full name: midgard.config.config.ConfigurationSection Signature: (name:str) -> None","title":"ConfigurationSection"},{"location":"api/midgard-config/#fmt_date-str","text":"FMT_date = '%Y-%m-%d'","title":"FMT_date (str)"},{"location":"api/midgard-config/#fmt_datetime-str","text":"FMT_datetime = '%Y-%m-%d %H:%M:%S'","title":"FMT_datetime (str)"},{"location":"api/midgard-config/#fmt_dt_file-str","text":"FMT_dt_file = '%Y%m%d-%H%M%S'","title":"FMT_dt_file (str)"},{"location":"api/midgard-config/#midgardconfigfiles","text":"Midgard library module for opening files based on a special configuration Example: from midgard.config import files with files.open('eopc04_iau', mode='rt') as fid: for line in fid: print(line.strip()) Description: This module handles opening of files registered in a special configuration, typically a configuration file. The cfg.files.open and cfg.files.open_path methods are both wrappers around the built-in open function, and behave mainly similar. In particular, they accept all the same keyword arguments (like for instance mode). Furthermore, to make sure files are properly closed they should normally be used with a context manager as in the example above.","title":"midgard.config.files"},{"location":"api/midgard-config/#fileconfiguration","text":"Full name: midgard.config.files.FileConfiguration Signature: (name:str) -> None Configuration for handling files","title":"FileConfiguration"},{"location":"api/midgard-data/","text":"midgard.data midgard.data._h5utils Simple utilities used by Dataset when dealing with HDF5 files dict2h5attr () Full name: midgard.data._h5utils.dict2h5attr Signature: (dct:Dict[str, str]) -> str Convert a dictionary to a string that can be stored as an HDF5 attribute h5attr2dict () Full name: midgard.data._h5utils.h5attr2dict Signature: (attr:str) -> List[str] Convert an HDF5 attribute to a dictionary of strings h5attr2list () Full name: midgard.data._h5utils.h5attr2list Signature: (attr:str) -> List[str] Convert an HDF5 attribute to a list of strings h5attr2tuple () Full name: midgard.data._h5utils.h5attr2tuple Signature: (attr:str) -> Tuple[str, ...] Convert an HDF5 attribute to a list of strings sequence2h5attr () Full name: midgard.data._h5utils.sequence2h5attr Signature: (lst:Sequence[str]) -> str Convert a list to a string that can be stored as an HDF5 attribute midgard.data._position Module for dealing with positions, velocities and position corrections in different coordinate systems PosBase Full name: midgard.data._position.PosBase Signature: () Base class for the various position and velocity arrays PosVelArray Full name: midgard.data._position.PosVelArray Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) Base class for Position and Velocity arrays This PosVelArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function. PosVelDeltaArray Full name: midgard.data._position.PosVelDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position and velocity deltas This PosVelDeltaArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function. PositionArray Full name: midgard.data._position.PositionArray Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) Base class for Position arrays This PositionArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function. PositionDeltaArray Full name: midgard.data._position.PositionDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position deltas This PositionDeltaArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function. VelocityArray Full name: midgard.data._position.VelocityArray Signature: (val, ref_pos, **vel_args) Base class for Velocity arrays This VelocityArray should not be instantiated. Instead instantiate one of the system specific subclasses. The intended usage will be through a PosVelArray VelocityDeltaArray Full name: midgard.data._position.VelocityDeltaArray Signature: (val, ref_pos, **vel_args) Base class for Velocity arrays This VelocityArray should not be instantiated. Instead instantiate one of the system specific subclasses. The intended usage will be through a PosVelArray register_attribute () Full name: midgard.data._position.register_attribute Signature: (cls:Callable, name:str, attr_cls:Callable) -> None Function used to register new attributes on position arrays The registered attributes will be available as attributes on PositionArray and its subclasses. In addition, each attribute can be given as a parameter when creating a PositionArray. The reason for using this register-function instead of a regular attribute is to allow additional attributes to be added on all position systems. Args: cls : Name of class to register the attribute for name : Name of attribute attr_cls : Class of attribute register_field () Full name: midgard.data._position.register_field Signature: (units:List[str]) -> Callable Decorator used to register fields and their units register_system () Full name: midgard.data._position.register_system Signature: (convert_to:Dict[str, Callable]=None, convert_from:Dict[str, Callable]=None) -> Callable[[Callable], Callable] Decorator used to register new position systems The system name is read from the .system attribute of the Position class. Args: convert_to : Functions used to convert to other systems. convert_from : Functions used to convert from other systems. Returns: Decorator registering system. midgard.data._time Array with time epochs TimeArray Full name: midgard.data._time.TimeArray Signature: (val, val2=None, format='', _jd1=None, _jd2=None) register_scale () Full name: midgard.data._time.register_scale Signature: (convert_to:Dict[str, Callable]=None, convert_from:Dict[str, Callable]=None) -> Callable[[Callable], Callable] Decorator used to register new time scales The scale name is read from the .scale attribute of the Time class. Args: convert_to : Functions used to convert to other scales. convert_from : Functions used to convert from other scales. Returns: Decorator registering scale. midgard.data._time_formats Array with time epochs TimeDateTime Full name: midgard.data._time_formats.TimeDateTime Signature: (val, val2=None) TimeFormat Full name: midgard.data._time_formats.TimeFormat Signature: (val, val2=None) TimeGPSWeekSec Full name: midgard.data._time_formats.TimeGPSWeekSec Signature: (val, val2=None) GPS weeks and seconds. TimeJD Full name: midgard.data._time_formats.TimeJD Signature: (val, val2=None) TimeMJD Full name: midgard.data._time_formats.TimeMJD Signature: (val, val2=None) Modified Julian Date time format. This represents the number of days since midnight on November 17, 1858. For example, 51544.0 in MJD is midnight on January 1, 2000. TimeYear Full name: midgard.data._time_formats.TimeYear Signature: (val, val2=None) Year. TODO: conversion is not correct!!! register_format () Full name: midgard.data._time_formats.register_format Signature: (cls:Callable) -> Callable Decorator used to register new time formats The format name is read from the .format attribute of the TimeFormat class. midgard.data._time_scales Time scales and conversions between them GpsTime Full name: midgard.data._time_scales.GpsTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None) TaiTime Full name: midgard.data._time_scales.TaiTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None) TtTime Full name: midgard.data._time_scales.TtTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None) UtcTime Full name: midgard.data._time_scales.UtcTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None) midgard.data.dataset A dataset for handling time series data Description: Dataset Full name: midgard.data.dataset.Dataset Signature: (num_obs:int=0) -> None A dataset representing fields of data arrays Meta Full name: midgard.data.dataset.Meta Signature: (*args, **kwargs) field_type (str) field_type = 'time' midgard.data.fieldtypes Field types that can be used by Dataset function () Full name: midgard.data.fieldtypes.function Signature: (plugin_name:str) -> Callable Function creating new field names () Full name: midgard.data.fieldtypes.names Signature: () -> List[str] Names of fieldtype plugins midgard.data.fieldtypes._fieldtype Abstract class used to define different types of tables for a Dataset FieldType Full name: midgard.data.fieldtypes._fieldtype.FieldType Signature: (num_obs, name, val, unit=None, write_level=None, **field_args) Abstract class representing a type of field in the Dataset midgard.data.fieldtypes.collection A Dataset collection field consisting of other fields Collection Full name: midgard.data.fieldtypes.collection.Collection Signature: () CollectionField Full name: midgard.data.fieldtypes.collection.CollectionField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args) midgard.data.fieldtypes.float A Dataset float field FloatField Full name: midgard.data.fieldtypes.float.FloatField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args) midgard.data.fieldtypes.position A Dataset position field PositionField Full name: midgard.data.fieldtypes.position.PositionField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args) midgard.data.fieldtypes.position_delta A Dataset position delta field PositionDeltaField Full name: midgard.data.fieldtypes.position_delta.PositionDeltaField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args) midgard.data.fieldtypes.posvel A Dataset position field PositionField Full name: midgard.data.fieldtypes.posvel.PositionField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args) midgard.data.fieldtypes.posvel_delta A Dataset position delta field PositionDeltaField Full name: midgard.data.fieldtypes.posvel_delta.PositionDeltaField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args) midgard.data.fieldtypes.sigma A Dataset sigma field SigmaField Full name: midgard.data.fieldtypes.sigma.SigmaField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args) midgard.data.fieldtypes.text A Dataset text field TextField Full name: midgard.data.fieldtypes.text.TextField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args) midgard.data.fieldtypes.time A Dataset time field TimeField Full name: midgard.data.fieldtypes.time.TimeField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args) midgard.data.position Array with positions EnuPosVelDelta Full name: midgard.data.position.EnuPosVelDelta Signature: (val, ref_pos, **delta_args) EnuPositionDelta Full name: midgard.data.position.EnuPositionDelta Signature: (val, ref_pos, **delta_args) EnuVelocityDelta Full name: midgard.data.position.EnuVelocityDelta Signature: (val, ref_pos, **vel_args) LlhPosition Full name: midgard.data.position.LlhPosition Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) PosVel () Full name: midgard.data.position.PosVel Signature: (val:numpy.ndarray, system:str, **pos_args:Any) -> 'PosVelArray' Factory for creating PosVelArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PosVelArray. Returns: Array with positions in the given system. PosVelDelta () Full name: midgard.data.position.PosVelDelta Signature: (val:numpy.ndarray, system:str, ref_pos:midgard.data._position.PosVelArray, **delta_args:Any) -> midgard.data._position.PosVelDeltaArray Factory for creating PosVelArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PosVelArray. Returns: Array with positions in the given system. Position () Full name: midgard.data.position.Position Signature: (val:numpy.ndarray, system:str, **pos_args:Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system. PositionDelta () Full name: midgard.data.position.PositionDelta Signature: (val:numpy.ndarray, system:str, ref_pos:midgard.data._position.PositionArray, **delta_args:Any) -> midgard.data._position.PositionDeltaArray Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system. TrsPosVel Full name: midgard.data.position.TrsPosVel Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) TrsPosVelDelta Full name: midgard.data.position.TrsPosVelDelta Signature: (val, ref_pos, **delta_args) TrsPosition Full name: midgard.data.position.TrsPosition Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) TrsPositionDelta Full name: midgard.data.position.TrsPositionDelta Signature: (val, ref_pos, **delta_args) TrsVelocity Full name: midgard.data.position.TrsVelocity Signature: (val, ref_pos, **vel_args) TrsVelocityDelta Full name: midgard.data.position.TrsVelocityDelta Signature: (val, ref_pos, **vel_args) midgard.data.sigma Array with sigma values See https://docs.scipy.org/doc/numpy/user/basics.subclassing.html for information about subclassing Numpy arrays. SigmaArray is a regular Numpy array with an added field, sigma. SigmaArray Full name: midgard.data.sigma.SigmaArray Signature: (values, sigma=None) midgard.data.time Array with time epochs Time () Full name: midgard.data.time.Time Signature: (val:numpy.ndarray, scale:str, format:str, val2:Union[numpy.ndarray, NoneType]=None, _jd1:Union[numpy.ndarray, NoneType]=None, _jd2:Union[numpy.ndarray, NoneType]=None) -> 'TimeArray' Factory for creating TimeArrays for different systems See each time class for exact optional parameters. Args: val : Array of time values. val2 : Optional second array for extra precision. scale : Name of time scale. format : Format of values given in val and val2. Returns: Array with epochs in the given time scale and format","title":"midgard.data"},{"location":"api/midgard-data/#midgarddata","text":"","title":"midgard.data"},{"location":"api/midgard-data/#midgarddata_h5utils","text":"Simple utilities used by Dataset when dealing with HDF5 files","title":"midgard.data._h5utils"},{"location":"api/midgard-data/#dict2h5attr","text":"Full name: midgard.data._h5utils.dict2h5attr Signature: (dct:Dict[str, str]) -> str Convert a dictionary to a string that can be stored as an HDF5 attribute","title":"dict2h5attr()"},{"location":"api/midgard-data/#h5attr2dict","text":"Full name: midgard.data._h5utils.h5attr2dict Signature: (attr:str) -> List[str] Convert an HDF5 attribute to a dictionary of strings","title":"h5attr2dict()"},{"location":"api/midgard-data/#h5attr2list","text":"Full name: midgard.data._h5utils.h5attr2list Signature: (attr:str) -> List[str] Convert an HDF5 attribute to a list of strings","title":"h5attr2list()"},{"location":"api/midgard-data/#h5attr2tuple","text":"Full name: midgard.data._h5utils.h5attr2tuple Signature: (attr:str) -> Tuple[str, ...] Convert an HDF5 attribute to a list of strings","title":"h5attr2tuple()"},{"location":"api/midgard-data/#sequence2h5attr","text":"Full name: midgard.data._h5utils.sequence2h5attr Signature: (lst:Sequence[str]) -> str Convert a list to a string that can be stored as an HDF5 attribute","title":"sequence2h5attr()"},{"location":"api/midgard-data/#midgarddata_position","text":"Module for dealing with positions, velocities and position corrections in different coordinate systems","title":"midgard.data._position"},{"location":"api/midgard-data/#posbase","text":"Full name: midgard.data._position.PosBase Signature: () Base class for the various position and velocity arrays","title":"PosBase"},{"location":"api/midgard-data/#posvelarray","text":"Full name: midgard.data._position.PosVelArray Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) Base class for Position and Velocity arrays This PosVelArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function.","title":"PosVelArray"},{"location":"api/midgard-data/#posveldeltaarray","text":"Full name: midgard.data._position.PosVelDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position and velocity deltas This PosVelDeltaArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function.","title":"PosVelDeltaArray"},{"location":"api/midgard-data/#positionarray","text":"Full name: midgard.data._position.PositionArray Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) Base class for Position arrays This PositionArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function.","title":"PositionArray"},{"location":"api/midgard-data/#positiondeltaarray","text":"Full name: midgard.data._position.PositionDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position deltas This PositionDeltaArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function.","title":"PositionDeltaArray"},{"location":"api/midgard-data/#velocityarray","text":"Full name: midgard.data._position.VelocityArray Signature: (val, ref_pos, **vel_args) Base class for Velocity arrays This VelocityArray should not be instantiated. Instead instantiate one of the system specific subclasses. The intended usage will be through a PosVelArray","title":"VelocityArray"},{"location":"api/midgard-data/#velocitydeltaarray","text":"Full name: midgard.data._position.VelocityDeltaArray Signature: (val, ref_pos, **vel_args) Base class for Velocity arrays This VelocityArray should not be instantiated. Instead instantiate one of the system specific subclasses. The intended usage will be through a PosVelArray","title":"VelocityDeltaArray"},{"location":"api/midgard-data/#register_attribute","text":"Full name: midgard.data._position.register_attribute Signature: (cls:Callable, name:str, attr_cls:Callable) -> None Function used to register new attributes on position arrays The registered attributes will be available as attributes on PositionArray and its subclasses. In addition, each attribute can be given as a parameter when creating a PositionArray. The reason for using this register-function instead of a regular attribute is to allow additional attributes to be added on all position systems. Args: cls : Name of class to register the attribute for name : Name of attribute attr_cls : Class of attribute","title":"register_attribute()"},{"location":"api/midgard-data/#register_field","text":"Full name: midgard.data._position.register_field Signature: (units:List[str]) -> Callable Decorator used to register fields and their units","title":"register_field()"},{"location":"api/midgard-data/#register_system","text":"Full name: midgard.data._position.register_system Signature: (convert_to:Dict[str, Callable]=None, convert_from:Dict[str, Callable]=None) -> Callable[[Callable], Callable] Decorator used to register new position systems The system name is read from the .system attribute of the Position class. Args: convert_to : Functions used to convert to other systems. convert_from : Functions used to convert from other systems. Returns: Decorator registering system.","title":"register_system()"},{"location":"api/midgard-data/#midgarddata_time","text":"Array with time epochs","title":"midgard.data._time"},{"location":"api/midgard-data/#timearray","text":"Full name: midgard.data._time.TimeArray Signature: (val, val2=None, format='', _jd1=None, _jd2=None)","title":"TimeArray"},{"location":"api/midgard-data/#register_scale","text":"Full name: midgard.data._time.register_scale Signature: (convert_to:Dict[str, Callable]=None, convert_from:Dict[str, Callable]=None) -> Callable[[Callable], Callable] Decorator used to register new time scales The scale name is read from the .scale attribute of the Time class. Args: convert_to : Functions used to convert to other scales. convert_from : Functions used to convert from other scales. Returns: Decorator registering scale.","title":"register_scale()"},{"location":"api/midgard-data/#midgarddata_time_formats","text":"Array with time epochs","title":"midgard.data._time_formats"},{"location":"api/midgard-data/#timedatetime","text":"Full name: midgard.data._time_formats.TimeDateTime Signature: (val, val2=None)","title":"TimeDateTime"},{"location":"api/midgard-data/#timeformat","text":"Full name: midgard.data._time_formats.TimeFormat Signature: (val, val2=None)","title":"TimeFormat"},{"location":"api/midgard-data/#timegpsweeksec","text":"Full name: midgard.data._time_formats.TimeGPSWeekSec Signature: (val, val2=None) GPS weeks and seconds.","title":"TimeGPSWeekSec"},{"location":"api/midgard-data/#timejd","text":"Full name: midgard.data._time_formats.TimeJD Signature: (val, val2=None)","title":"TimeJD"},{"location":"api/midgard-data/#timemjd","text":"Full name: midgard.data._time_formats.TimeMJD Signature: (val, val2=None) Modified Julian Date time format. This represents the number of days since midnight on November 17, 1858. For example, 51544.0 in MJD is midnight on January 1, 2000.","title":"TimeMJD"},{"location":"api/midgard-data/#timeyear","text":"Full name: midgard.data._time_formats.TimeYear Signature: (val, val2=None) Year.","title":"TimeYear"},{"location":"api/midgard-data/#todo-conversion-is-not-correct","text":"","title":"TODO: conversion is not correct!!!"},{"location":"api/midgard-data/#register_format","text":"Full name: midgard.data._time_formats.register_format Signature: (cls:Callable) -> Callable Decorator used to register new time formats The format name is read from the .format attribute of the TimeFormat class.","title":"register_format()"},{"location":"api/midgard-data/#midgarddata_time_scales","text":"Time scales and conversions between them","title":"midgard.data._time_scales"},{"location":"api/midgard-data/#gpstime","text":"Full name: midgard.data._time_scales.GpsTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None)","title":"GpsTime"},{"location":"api/midgard-data/#taitime","text":"Full name: midgard.data._time_scales.TaiTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None)","title":"TaiTime"},{"location":"api/midgard-data/#tttime","text":"Full name: midgard.data._time_scales.TtTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None)","title":"TtTime"},{"location":"api/midgard-data/#utctime","text":"Full name: midgard.data._time_scales.UtcTime Signature: (val, val2=None, format='', _jd1=None, _jd2=None)","title":"UtcTime"},{"location":"api/midgard-data/#midgarddatadataset","text":"A dataset for handling time series data Description:","title":"midgard.data.dataset"},{"location":"api/midgard-data/#dataset","text":"Full name: midgard.data.dataset.Dataset Signature: (num_obs:int=0) -> None A dataset representing fields of data arrays","title":"Dataset"},{"location":"api/midgard-data/#meta","text":"Full name: midgard.data.dataset.Meta Signature: (*args, **kwargs)","title":"Meta"},{"location":"api/midgard-data/#field_type-str","text":"field_type = 'time'","title":"field_type (str)"},{"location":"api/midgard-data/#midgarddatafieldtypes","text":"Field types that can be used by Dataset","title":"midgard.data.fieldtypes"},{"location":"api/midgard-data/#function","text":"Full name: midgard.data.fieldtypes.function Signature: (plugin_name:str) -> Callable Function creating new field","title":"function()"},{"location":"api/midgard-data/#names","text":"Full name: midgard.data.fieldtypes.names Signature: () -> List[str] Names of fieldtype plugins","title":"names()"},{"location":"api/midgard-data/#midgarddatafieldtypes_fieldtype","text":"Abstract class used to define different types of tables for a Dataset","title":"midgard.data.fieldtypes._fieldtype"},{"location":"api/midgard-data/#fieldtype","text":"Full name: midgard.data.fieldtypes._fieldtype.FieldType Signature: (num_obs, name, val, unit=None, write_level=None, **field_args) Abstract class representing a type of field in the Dataset","title":"FieldType"},{"location":"api/midgard-data/#midgarddatafieldtypescollection","text":"A Dataset collection field consisting of other fields","title":"midgard.data.fieldtypes.collection"},{"location":"api/midgard-data/#collection","text":"Full name: midgard.data.fieldtypes.collection.Collection Signature: ()","title":"Collection"},{"location":"api/midgard-data/#collectionfield","text":"Full name: midgard.data.fieldtypes.collection.CollectionField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args)","title":"CollectionField"},{"location":"api/midgard-data/#midgarddatafieldtypesfloat","text":"A Dataset float field","title":"midgard.data.fieldtypes.float"},{"location":"api/midgard-data/#floatfield","text":"Full name: midgard.data.fieldtypes.float.FloatField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args)","title":"FloatField"},{"location":"api/midgard-data/#midgarddatafieldtypesposition","text":"A Dataset position field","title":"midgard.data.fieldtypes.position"},{"location":"api/midgard-data/#positionfield","text":"Full name: midgard.data.fieldtypes.position.PositionField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args)","title":"PositionField"},{"location":"api/midgard-data/#midgarddatafieldtypesposition_delta","text":"A Dataset position delta field","title":"midgard.data.fieldtypes.position_delta"},{"location":"api/midgard-data/#positiondeltafield","text":"Full name: midgard.data.fieldtypes.position_delta.PositionDeltaField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args)","title":"PositionDeltaField"},{"location":"api/midgard-data/#midgarddatafieldtypesposvel","text":"A Dataset position field","title":"midgard.data.fieldtypes.posvel"},{"location":"api/midgard-data/#positionfield_1","text":"Full name: midgard.data.fieldtypes.posvel.PositionField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args)","title":"PositionField"},{"location":"api/midgard-data/#midgarddatafieldtypesposvel_delta","text":"A Dataset position delta field","title":"midgard.data.fieldtypes.posvel_delta"},{"location":"api/midgard-data/#positiondeltafield_1","text":"Full name: midgard.data.fieldtypes.posvel_delta.PositionDeltaField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args)","title":"PositionDeltaField"},{"location":"api/midgard-data/#midgarddatafieldtypessigma","text":"A Dataset sigma field","title":"midgard.data.fieldtypes.sigma"},{"location":"api/midgard-data/#sigmafield","text":"Full name: midgard.data.fieldtypes.sigma.SigmaField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args)","title":"SigmaField"},{"location":"api/midgard-data/#midgarddatafieldtypestext","text":"A Dataset text field","title":"midgard.data.fieldtypes.text"},{"location":"api/midgard-data/#textfield","text":"Full name: midgard.data.fieldtypes.text.TextField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args)","title":"TextField"},{"location":"api/midgard-data/#midgarddatafieldtypestime","text":"A Dataset time field","title":"midgard.data.fieldtypes.time"},{"location":"api/midgard-data/#timefield","text":"Full name: midgard.data.fieldtypes.time.TimeField Signature: (num_obs, name, val, unit=None, write_level=None, **field_args)","title":"TimeField"},{"location":"api/midgard-data/#midgarddataposition","text":"Array with positions","title":"midgard.data.position"},{"location":"api/midgard-data/#enuposveldelta","text":"Full name: midgard.data.position.EnuPosVelDelta Signature: (val, ref_pos, **delta_args)","title":"EnuPosVelDelta"},{"location":"api/midgard-data/#enupositiondelta","text":"Full name: midgard.data.position.EnuPositionDelta Signature: (val, ref_pos, **delta_args)","title":"EnuPositionDelta"},{"location":"api/midgard-data/#enuvelocitydelta","text":"Full name: midgard.data.position.EnuVelocityDelta Signature: (val, ref_pos, **vel_args)","title":"EnuVelocityDelta"},{"location":"api/midgard-data/#llhposition","text":"Full name: midgard.data.position.LlhPosition Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args)","title":"LlhPosition"},{"location":"api/midgard-data/#posvel","text":"Full name: midgard.data.position.PosVel Signature: (val:numpy.ndarray, system:str, **pos_args:Any) -> 'PosVelArray' Factory for creating PosVelArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PosVelArray. Returns: Array with positions in the given system.","title":"PosVel()"},{"location":"api/midgard-data/#posveldelta","text":"Full name: midgard.data.position.PosVelDelta Signature: (val:numpy.ndarray, system:str, ref_pos:midgard.data._position.PosVelArray, **delta_args:Any) -> midgard.data._position.PosVelDeltaArray Factory for creating PosVelArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PosVelArray. Returns: Array with positions in the given system.","title":"PosVelDelta()"},{"location":"api/midgard-data/#position","text":"Full name: midgard.data.position.Position Signature: (val:numpy.ndarray, system:str, **pos_args:Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system.","title":"Position()"},{"location":"api/midgard-data/#positiondelta","text":"Full name: midgard.data.position.PositionDelta Signature: (val:numpy.ndarray, system:str, ref_pos:midgard.data._position.PositionArray, **delta_args:Any) -> midgard.data._position.PositionDeltaArray Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system.","title":"PositionDelta()"},{"location":"api/midgard-data/#trsposvel","text":"Full name: midgard.data.position.TrsPosVel Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args)","title":"TrsPosVel"},{"location":"api/midgard-data/#trsposveldelta","text":"Full name: midgard.data.position.TrsPosVelDelta Signature: (val, ref_pos, **delta_args)","title":"TrsPosVelDelta"},{"location":"api/midgard-data/#trsposition","text":"Full name: midgard.data.position.TrsPosition Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args)","title":"TrsPosition"},{"location":"api/midgard-data/#trspositiondelta","text":"Full name: midgard.data.position.TrsPositionDelta Signature: (val, ref_pos, **delta_args)","title":"TrsPositionDelta"},{"location":"api/midgard-data/#trsvelocity","text":"Full name: midgard.data.position.TrsVelocity Signature: (val, ref_pos, **vel_args)","title":"TrsVelocity"},{"location":"api/midgard-data/#trsvelocitydelta","text":"Full name: midgard.data.position.TrsVelocityDelta Signature: (val, ref_pos, **vel_args)","title":"TrsVelocityDelta"},{"location":"api/midgard-data/#midgarddatasigma","text":"Array with sigma values See https://docs.scipy.org/doc/numpy/user/basics.subclassing.html for information about subclassing Numpy arrays. SigmaArray is a regular Numpy array with an added field, sigma.","title":"midgard.data.sigma"},{"location":"api/midgard-data/#sigmaarray","text":"Full name: midgard.data.sigma.SigmaArray Signature: (values, sigma=None)","title":"SigmaArray"},{"location":"api/midgard-data/#midgarddatatime","text":"Array with time epochs","title":"midgard.data.time"},{"location":"api/midgard-data/#time","text":"Full name: midgard.data.time.Time Signature: (val:numpy.ndarray, scale:str, format:str, val2:Union[numpy.ndarray, NoneType]=None, _jd1:Union[numpy.ndarray, NoneType]=None, _jd2:Union[numpy.ndarray, NoneType]=None) -> 'TimeArray' Factory for creating TimeArrays for different systems See each time class for exact optional parameters. Args: val : Array of time values. val2 : Optional second array for extra precision. scale : Name of time scale. format : Format of values given in val and val2. Returns: Array with epochs in the given time scale and format","title":"Time()"},{"location":"api/midgard-dev/","text":"midgard.dev midgard.dev.cache Midgard library module for caching Description: Adds caching to properties on classes, using the recipe explained in Python Cookbook, 3rd ed. Recipe 8.10. Also, adds a cached property that may depend on other data, with the possibility to reset the cache if the dependencies change. dependent_property Full name: midgard.dev.cache.dependent_property Signature: () Decorator for cached properties that can be reset when dependencies change forget_dependent_values () Full name: midgard.dev.cache.forget_dependent_values Signature: (obj:object, *dependencies:str) -> None Reset cache when given dependencies change property Full name: midgard.dev.cache.property Signature: (fget:Callable) -> None Cached property, see Python Cookbook, 3rd ed. Recipe 8.10. register_dependencies Full name: midgard.dev.cache.register_dependencies Signature: () Metaclass for registering dependencies using dot notation midgard.dev.console Simpler dealing with the console Description: Utilities for using the console. Mainly wrappers around other libraries to make them easier and more intuitive to use. Size of console: The two functions lines() and columns() report the current size of the console. Textwrapping: The function fill() can be used to rewrap a text-string so that it fits inside the console. Color: The sub-module color can be used to set the foreground and background colors. Note that the color functionality depends on the external package colorama . If colorama is not installed, color gracefully falls back to not showing any color. Examples: >>> from midgard.dev import console >>> console.columns() # doctest: +SKIP 86 >>> print(console.fill(a_very_long_string)) # doctest: +SKIP Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras tempus eleifend feugiat. Maecenas vitae posuere metus. Sed sit amet fermentum velit. Aenean vitae turpis at risus sollicitudin fringilla in in nisi. Maecenas vitae ante libero. Aenean ut eros consequat, ornare erat at, tempus arcu. Suspendisse velit leo, eleifend eget mi non, vehicula ultricies erat. Vestibulum id nisi eget nisl venenatis dignissim. Duis cursus quam dui, vel hendrerit nibh lacinia id. >>> print(console.color.Fore.YELLOW + console.color.Back.BLUE + 'I am YELLOW text on BLUE backdrop!') # doctest: +SKIP I am YELLOW text on a BLUE background! columns () Full name: midgard.dev.console.columns Signature: () -> int The width of the console Returns: The width of the console in characters. dedent () Full name: midgard.dev.console.dedent Signature: (text:str, num_spaces:Union[int, NoneType]=None) -> str Wrapper around textwrap.dedent Dedents at most num_spaces. If num_spaces is not specified, dedents as much as possible. Args: text : Text that will be dedented. num_spaces : Number of spaces that will be used for dedentation. Returns: Dedented string. fill () Full name: midgard.dev.console.fill Signature: (text:str, *, width:Union[int, NoneType]=None, hanging:Union[int, NoneType]=None, **tw_args:Any) -> str Wrapper around textwrap.fill The tw_args are passed on to textwrap.fill. See textwrap.TextWrapper for available keyword arguments. The default value for width is console.columns(), while the new argument hanging , if defined, will try to set (although not override) the textwrap-arguments initial_indent and subsequent_indent to create a hanging indent (no indent on the first line) of hanging spaces. Args: text : Text that will be wrapped. width : The maximum width (in characters) of wrapped lines. hanging : Number of characters used for hanging indent. tw_args : Arguments passed on to textwrap.fill . Returns: Wrapped string. indent () Full name: midgard.dev.console.indent Signature: (text:str, num_spaces:int, **tw_args:Any) -> str Wrapper around textwrap.indent The tw_args are passed on to textwrap.indent. Args: text : Text that will be indented. num_spaces : Number of spaces that will be used for indentation. Returns: Indented string. lines () Full name: midgard.dev.console.lines Signature: () -> int The height of the console Returns: The heigth of the console in characters. num_leading_spaces () Full name: midgard.dev.console.num_leading_spaces Signature: (text:str, space_char:str=' ') -> int Count number of leading spaces in a string Args: text : String to count. space_char : Which characters count as spaces. Returns: Number of leading spaces. midgard.dev.exceptions Definition of Midgard-specific exceptions Description: Custom exceptions used by Midgard for more specific error messages and handling. FieldDoesNotExistError Full name: midgard.dev.exceptions.FieldDoesNotExistError Signature: () FieldExistsError Full name: midgard.dev.exceptions.FieldExistsError Signature: () InitializationError Full name: midgard.dev.exceptions.InitializationError Signature: () MidgardException Full name: midgard.dev.exceptions.MidgardException Signature: () MidgardExit Full name: midgard.dev.exceptions.MidgardExit Signature: () MissingConfigurationError Full name: midgard.dev.exceptions.MissingConfigurationError Signature: () MissingDataError Full name: midgard.dev.exceptions.MissingDataError Signature: () MissingEntryError Full name: midgard.dev.exceptions.MissingEntryError Signature: () MissingSectionError Full name: midgard.dev.exceptions.MissingSectionError Signature: () ParserError Full name: midgard.dev.exceptions.ParserError Signature: () TimerNotRunning Full name: midgard.dev.exceptions.TimerNotRunning Signature: () TimerRunning Full name: midgard.dev.exceptions.TimerRunning Signature: () UnitError Full name: midgard.dev.exceptions.UnitError Signature: () UnknownConstantError Full name: midgard.dev.exceptions.UnknownConstantError Signature: () UnknownConversionError Full name: midgard.dev.exceptions.UnknownConversionError Signature: () UnknownEnumError Full name: midgard.dev.exceptions.UnknownEnumError Signature: () UnknownPackageError Full name: midgard.dev.exceptions.UnknownPackageError Signature: () UnknownPluginError Full name: midgard.dev.exceptions.UnknownPluginError Signature: () UnknownSystemError Full name: midgard.dev.exceptions.UnknownSystemError Signature: () midgard.dev.library Python wrapper around C-libraries Description: Loads a C-library. If a library is missing, a mock library is returned. If this mock is used for anything, a warning will be printed. This is done to avoid dependencies to all the C/C++-libraries for Python programs only using some of them. SimpleMock Full name: midgard.dev.library.SimpleMock Signature: (name, raise_error=True) Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (typically because a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on). load_name () Full name: midgard.dev.library.load_name Signature: (library_name, func_specs=None, name_patterns=None) Load the given shared C-library See load_path for an explanation of the func_specs and name_patterns -arguments. Args: library_name (String): The name of the library. func_specs (Dict): Specification of types in lib (see load_path). name_patterns (List): Name mangling patterns (see load_path). Returns: ctypes.CDLL: Representation of the shared library. load_path () Full name: midgard.dev.library.load_path Signature: (library_path, func_specs=None, name_patterns=None) Load the given shared C-library The optional func_specs-dictionary can be used to specify argument and return types of functions in the library (see the ctypes documentation for information about argtypes and restype). The dictionary should be on the form:: func_spec = {'func_1': dict(func_name='name_of_func_1_in_lib', argtypes=[ ... argtypes of func_1 ... ], restype=... restype of func_1 ...), 'func_2': ... } If the library is not found, a mock library is returned instead. The mock library will print a warning if it is used. For some libraries, name mangling is used and this might be different depending on operating system and how the library is compiled. For instance, in a Fortran library the function Test might be represented as __Test on a Windows system and test_ (with lower-case t ) on a Linux system. This can be handled by providing a list of possible patterns. The above example can be handled by:: name_patterns = ('__{func_name}', '{func_name_lower}_') In this case, each function in func_specs is looked up by testing each pattern in turn until a match is found. Args: library_path (String): The path to the library. func_specs (Dict): Specification of types in library (see above). name_patterns (List): Name mangling patterns (see above). Returns: ctypes.CDLL: Representation of the shared library. midgard.dev.log Midgard library module for logging Description: This module provides simple logging inside Midgard. To use it, you must first add a an active logger. This is typically done using one of the init-functions: init() or file_init(). To write a log message, simply call one of midgard.log.debug, midgard.log.info, midgard.log.warn, midgard.log.error or midgard.log.fatal with a log message. To add a different logger, you should subclass the Logger abstract class. Example: >>> from midgard.dev import log >>> log.init(\"info\", prefix=\"My prefix\") >>> n, m = 5, 3 >>> log.info(f\"Calculating the inverse of a {n:>2d}x{m:<2d} matrix\") INFO [My prefix] Calculating the inverse of a 5x3 matrix ConsoleLogger Full name: midgard.dev.log.ConsoleLogger Signature: (log_level:Union[str, NoneType]=None, prefix:str='', use_command_line:bool=True) -> None Log to the console, the log level can also be set using command line parameters FileLogger Full name: midgard.dev.log.FileLogger Signature: (file_path:Union[str, pathlib.Path], log_level:Union[str, NoneType]=None, prefix:str='', rotation:Union[int, NoneType]=None) -> None Log to a file, the log files can be rotated so that older files are kept Logger Full name: midgard.dev.log.Logger Signature: (log_level:Union[str, NoneType]=None, prefix:str='') Abstract class that can be specialized to create new loggers all () Full name: midgard.dev.log.all Signature: (log_text:str, *, level:str='all') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. blank () Full name: midgard.dev.log.blank Signature: () -> None Log blank line debug () Full name: midgard.dev.log.debug Signature: (log_text:str, *, level:str='debug') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. error () Full name: midgard.dev.log.error Signature: (log_text:str, *, level:str='error') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. fatal () Full name: midgard.dev.log.fatal Signature: (log_text:str, *, level:str='fatal') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. file_init Full name: midgard.dev.log.file_init Signature: (file_path:Union[str, pathlib.Path], log_level:Union[str, NoneType]=None, prefix:str='', rotation:Union[int, NoneType]=None) -> None Log to a file, the log files can be rotated so that older files are kept info () Full name: midgard.dev.log.info Signature: (log_text:str, *, level:str='info') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. init Full name: midgard.dev.log.init Signature: (log_level:Union[str, NoneType]=None, prefix:str='', use_command_line:bool=True) -> None Log to the console, the log level can also be set using command line parameters log () Full name: midgard.dev.log.log Signature: (log_text:str, level:str) -> None Log text at the given level none () Full name: midgard.dev.log.none Signature: (log_text:str, *, level:str='none') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. print_file () Full name: midgard.dev.log.print_file Signature: (log_path:Union[str, pathlib.Path], log_level:str='info', print_func:Callable[[str], NoneType]=<built-in function print>) -> None Print a log file with colors, stripping away any item below log_level warn () Full name: midgard.dev.log.warn Signature: (log_text:str, *, level:str='warn') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. midgard.dev.optional Midgard library module for handling optional dependencies Description: Import dependencies that are only necessary for specific parts of Midgard. Using this module will delay raising an ImportError until the dependency is actually used. This means that if one for instance only wants to run a GNSS analysis (or only use a Rinex-parser) installing special libraries only used for VLBI is not necessary. Examples: The optional import is typically used as follows:: from midgard.lib import optional netCDF4 = optional.optional_import('netCDF4') EmptyStringMock Full name: midgard.dev.optional.EmptyStringMock Signature: (name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None, error_msg:Union[str, NoneType]=None) -> None A mock object whose properties are all empty strings SimpleMock Full name: midgard.dev.optional.SimpleMock Signature: (name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None, error_msg:Union[str, NoneType]=None) -> None Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (for instance if a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on). The exception is if any attributes ( attrs ) are explicitly defined on the mock. No exception is raised if those attributes are looked up. optional_import () Full name: midgard.dev.optional.optional_import Signature: (module_name:str, raise_error:bool=True, mock_cls:type=<class 'midgard.dev.optional.SimpleMock'>, attrs:Union[Dict[str, Any], NoneType]=None) -> Union[Any, midgard.dev.optional.SimpleMock] Try to import an optional module If the module does not exist, a SimpleMock-object is returned instead. If this SimpleMock-object is later used, an ImportError will be raised then (if raise_error is True, which is default). Args: module_name : Name of module to import. raise_error : Whether an ImportError should be raised if the module does not exist, but is used. attrs : Attributes that should be added to the SimpleMock used if the module does not exist. Returns: Imported module object, or a SimpleMock-object if the module can not be imported. midgard.dev.plugins Set up a plug-in architecture for Midgard Description: In order to be able to add models, parsers, data sources etc without needing to hardcode names, but rather pick them from configuration files, we use a simple plug-in architecture. The plug-in mechanism is based on the different plug-ins registering themselves using the register decorator: from midgard.dev import plugins @plugins.register def simple_model(rundate, tech, dset): ... Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. To list all plug-ins in a package use names : > from midgard.dev import plugins > plugins.names('midgard.models') ['model_one', 'model_three', 'model_two'] If the optional parameter config_key is given, then only plug-ins listed in the corresponding section in the current configuration file is listed. For instance, if the configuration file contains a line saying ham_models = model_three, model_one then we can list only the ham_models as follows: > from midgard.dev import plugins > plugins.names('midgard.models', config_key='ham_models') ['model_one', 'model_three'] Note that the plug-ins by default are sorted alphabetically. To run the plug-ins, use either call_all or call_one . The former calls all plug-ins and returns a dictionary containing the result from each plug-in. As with names the optional parameter config_key may be given: > from midgard.dev import plugins > plugins.call_all('midgard.models', config_key='ham_models', arg_to_plugin='hello') {'model_three': <result from model_three>, 'model_one': <result from model_one>} Arguments to the plug-ins should be passed as named arguments to call_all . Similarly, one plug-in may be called explicitly using call_one : > from midgard.dev import plugins > plugins.call_one('midgard.models', plugin_name='model_one', arg_to_plugin='hello') <result from model_one> There may be more than one function in each plug-in that is decorated by register . In this case, the default behaviour is that only the first function will be called. To call the other registered functions one should use the list_parts function to get a list of these functions and call them explicitly using the part optional parameter to call_one : > from midgard.dev import plugins > plugins.list_parts('midgard.techniques', plugin_name='vlbi') ['read', 'edit', 'calculate', 'estimate', 'write_result']) > for part in plugins.list_parts('midgard.techniques', plugin_name='vlbi'): ... plugins.call_one('midgard.techniques', plugin_name='vlbi', part=part, ...) Plugin Full name: midgard.dev.plugins.Plugin Signature: (name:str, function:Callable, file_path:pathlib.Path, sort_value:int) Information about a plug-in Args: name : Name of the plug-in. function : The plug-in. file_path : Path to the source code of the plug-in, may be used to add the source as a dependency. sort_value : Value used when sorting plug-ins in order to control the order they are called. add_alias () Full name: midgard.dev.plugins.add_alias Signature: (package_name:str, alias:str) -> None Add alias to plug-in package This allows one package of plug-ins to be spread over several directories Args: package_name : Name of package containing plug-ins. directory : Additional plug-in directory. call () Full name: midgard.dev.plugins.call Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -> Any Call one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to the plug-in. Returns: Return value of the plug-in. call_all () Full name: midgard.dev.plugins.call_all Signature: (package_name:str, plugins:Union[List[str], NoneType]=None, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -> Dict[str, Any] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list or in the config file does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-in names that should be used (optional). part : Name of function to call within the plug-ins (optional). prefix : Prefix of the plug-in names, used for a plug-in if it is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to all the plug-ins. Returns: Dictionary of all results from the plug-ins. doc () Full name: midgard.dev.plugins.doc Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False, use_module:bool=False) -> str Document one plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Documentation of the plug-in. doc_all () Full name: midgard.dev.plugins.doc_all Signature: (package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False, use_module:bool=False) -> Dict[str, str] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-ins are unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Dictionary of all doc-strings from the plug-ins. exists () Full name: midgard.dev.plugins.exists Signature: (package_name:str, plugin_name:str) -> bool Check whether or not a plug-in exists in a package Tries to import the given plug-in. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). Returns: True if plug-in exists, False otherwise. get () Full name: midgard.dev.plugins.get Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None) -> midgard.dev.plugins.Plugin Get a specific plugin-object If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be called. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). Returns: Plugin-namedtuple representing the plug-in. load () Full name: midgard.dev.plugins.load Signature: (package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -> str Load one plug-in from a package First tries to load the plugin with the given name. If that fails, it tries to load {prefix}_{plugin_name} instead. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Actual name of plug-in (with or without prefix). names () Full name: midgard.dev.plugins.names Signature: (package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None) -> List[str] List plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be listed. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-in names are unknown (optional). Returns: List of strings with names of plug-ins. parts () Full name: midgard.dev.plugins.parts Signature: (package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -> List[str] List all parts of one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in. prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: List : Strings with names of parts. register () Full name: midgard.dev.plugins.register Signature: (func:Callable, name:Union[str, NoneType]=None, sort_value:int=0) -> Callable Decorator used to register a plug-in Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. The path to the source code file is also stored. This is used to be able to add the source code as a dependency file when the plug-in is called. If name is given, the plug-in is registered based on this name instead of the name of the module. The name of the module is still registered as a part that can be used to distinguish between similar plug-ins in different files (see for instance how session is used in midgard.pipelines ). Args: func : The function that is being registered. name : Alternative name of plug-in. Used by register_named . sort_value : The value used when sorting plug-ins. Used by register_ordered . Returns: The function that is being registered. register_named () Full name: midgard.dev.plugins.register_named Signature: (name:str) -> Callable Decorator used to register a named plug-in This allows for overriding the name used to register the plug-in. See register for more details. Args: name : Name used for plug-in instead of module name. Returns: Decorator that registers a named function. register_ordered () Full name: midgard.dev.plugins.register_ordered Signature: (sort_value:int) -> Callable Decorator used to register a plug-in with a specific sort order The sort value should be a number. Lower numbers are sorted first, higher numbers last. Plug-ins without an explicit sort_order gets the sort value of 0. Args: sort_value : The value used when sorting plug-ins. Returns: Decorator that registers an ordered function. signature () Full name: midgard.dev.plugins.signature Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None) -> inspect.Signature Get signature of a plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Signature of the plugin midgard.dev.profiler Add a profiler when running Supports several profilers including cprofile, line_profiler, memprof and memory_profiler. CProfile Full name: midgard.dev.profiler.CProfile Signature: () cprofile is used for profiling the whole program LineProfiler Full name: midgard.dev.profiler.LineProfiler Signature: () line_profiler is used to profile one or a few functions in detail Profiler Full name: midgard.dev.profiler.Profiler Signature: () Base class for profilers midgard.dev.timer Class for timing the running time of functions and code blocks Description: The dev.timer can be used to log the running time of functions and general code blocks. Typically, you will import the Timer -class from within the module: from midgard.dev.timer import Timer The Timer can then be used in three different ways: As a decorator to time one function: @Timer('The time to execute some_function was') def some_function(some_argument, some_other_argument=some_value): pass As a context manager together with with to time a code block: with Timer('Finish doing stuff in', logger=logger.debug) as t: do_something() do_something_else() With explicit start - and end -statements: t = Timer() t.start() do_something() do_something_else() t.end() As can be seen in the examples above, Timer() may be called with several optional parameters, including the text to report when the timer ends and which logger is used to report the timing. See Timer.__init__ for more details. AccumulatedTimer Full name: midgard.dev.timer.AccumulatedTimer Signature: (text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=functools.partial(<function log at 0x7efd5b0b7378>, level='info')) -> None Timer Full name: midgard.dev.timer.Timer Signature: (text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=functools.partial(<function log at 0x7efd5b0b7378>, level='info')) -> None Class for timing running time of functions and code blocks.","title":"midgard.dev"},{"location":"api/midgard-dev/#midgarddev","text":"","title":"midgard.dev"},{"location":"api/midgard-dev/#midgarddevcache","text":"Midgard library module for caching Description: Adds caching to properties on classes, using the recipe explained in Python Cookbook, 3rd ed. Recipe 8.10. Also, adds a cached property that may depend on other data, with the possibility to reset the cache if the dependencies change.","title":"midgard.dev.cache"},{"location":"api/midgard-dev/#dependent_property","text":"Full name: midgard.dev.cache.dependent_property Signature: () Decorator for cached properties that can be reset when dependencies change","title":"dependent_property"},{"location":"api/midgard-dev/#forget_dependent_values","text":"Full name: midgard.dev.cache.forget_dependent_values Signature: (obj:object, *dependencies:str) -> None Reset cache when given dependencies change","title":"forget_dependent_values()"},{"location":"api/midgard-dev/#property","text":"Full name: midgard.dev.cache.property Signature: (fget:Callable) -> None Cached property, see Python Cookbook, 3rd ed. Recipe 8.10.","title":"property"},{"location":"api/midgard-dev/#register_dependencies","text":"Full name: midgard.dev.cache.register_dependencies Signature: () Metaclass for registering dependencies using dot notation","title":"register_dependencies"},{"location":"api/midgard-dev/#midgarddevconsole","text":"Simpler dealing with the console Description: Utilities for using the console. Mainly wrappers around other libraries to make them easier and more intuitive to use. Size of console: The two functions lines() and columns() report the current size of the console. Textwrapping: The function fill() can be used to rewrap a text-string so that it fits inside the console. Color: The sub-module color can be used to set the foreground and background colors. Note that the color functionality depends on the external package colorama . If colorama is not installed, color gracefully falls back to not showing any color. Examples: >>> from midgard.dev import console >>> console.columns() # doctest: +SKIP 86 >>> print(console.fill(a_very_long_string)) # doctest: +SKIP Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras tempus eleifend feugiat. Maecenas vitae posuere metus. Sed sit amet fermentum velit. Aenean vitae turpis at risus sollicitudin fringilla in in nisi. Maecenas vitae ante libero. Aenean ut eros consequat, ornare erat at, tempus arcu. Suspendisse velit leo, eleifend eget mi non, vehicula ultricies erat. Vestibulum id nisi eget nisl venenatis dignissim. Duis cursus quam dui, vel hendrerit nibh lacinia id. >>> print(console.color.Fore.YELLOW + console.color.Back.BLUE + 'I am YELLOW text on BLUE backdrop!') # doctest: +SKIP I am YELLOW text on a BLUE background!","title":"midgard.dev.console"},{"location":"api/midgard-dev/#columns","text":"Full name: midgard.dev.console.columns Signature: () -> int The width of the console Returns: The width of the console in characters.","title":"columns()"},{"location":"api/midgard-dev/#dedent","text":"Full name: midgard.dev.console.dedent Signature: (text:str, num_spaces:Union[int, NoneType]=None) -> str Wrapper around textwrap.dedent Dedents at most num_spaces. If num_spaces is not specified, dedents as much as possible. Args: text : Text that will be dedented. num_spaces : Number of spaces that will be used for dedentation. Returns: Dedented string.","title":"dedent()"},{"location":"api/midgard-dev/#fill","text":"Full name: midgard.dev.console.fill Signature: (text:str, *, width:Union[int, NoneType]=None, hanging:Union[int, NoneType]=None, **tw_args:Any) -> str Wrapper around textwrap.fill The tw_args are passed on to textwrap.fill. See textwrap.TextWrapper for available keyword arguments. The default value for width is console.columns(), while the new argument hanging , if defined, will try to set (although not override) the textwrap-arguments initial_indent and subsequent_indent to create a hanging indent (no indent on the first line) of hanging spaces. Args: text : Text that will be wrapped. width : The maximum width (in characters) of wrapped lines. hanging : Number of characters used for hanging indent. tw_args : Arguments passed on to textwrap.fill . Returns: Wrapped string.","title":"fill()"},{"location":"api/midgard-dev/#indent","text":"Full name: midgard.dev.console.indent Signature: (text:str, num_spaces:int, **tw_args:Any) -> str Wrapper around textwrap.indent The tw_args are passed on to textwrap.indent. Args: text : Text that will be indented. num_spaces : Number of spaces that will be used for indentation. Returns: Indented string.","title":"indent()"},{"location":"api/midgard-dev/#lines","text":"Full name: midgard.dev.console.lines Signature: () -> int The height of the console Returns: The heigth of the console in characters.","title":"lines()"},{"location":"api/midgard-dev/#num_leading_spaces","text":"Full name: midgard.dev.console.num_leading_spaces Signature: (text:str, space_char:str=' ') -> int Count number of leading spaces in a string Args: text : String to count. space_char : Which characters count as spaces. Returns: Number of leading spaces.","title":"num_leading_spaces()"},{"location":"api/midgard-dev/#midgarddevexceptions","text":"Definition of Midgard-specific exceptions Description: Custom exceptions used by Midgard for more specific error messages and handling.","title":"midgard.dev.exceptions"},{"location":"api/midgard-dev/#fielddoesnotexisterror","text":"Full name: midgard.dev.exceptions.FieldDoesNotExistError Signature: ()","title":"FieldDoesNotExistError"},{"location":"api/midgard-dev/#fieldexistserror","text":"Full name: midgard.dev.exceptions.FieldExistsError Signature: ()","title":"FieldExistsError"},{"location":"api/midgard-dev/#initializationerror","text":"Full name: midgard.dev.exceptions.InitializationError Signature: ()","title":"InitializationError"},{"location":"api/midgard-dev/#midgardexception","text":"Full name: midgard.dev.exceptions.MidgardException Signature: ()","title":"MidgardException"},{"location":"api/midgard-dev/#midgardexit","text":"Full name: midgard.dev.exceptions.MidgardExit Signature: ()","title":"MidgardExit"},{"location":"api/midgard-dev/#missingconfigurationerror","text":"Full name: midgard.dev.exceptions.MissingConfigurationError Signature: ()","title":"MissingConfigurationError"},{"location":"api/midgard-dev/#missingdataerror","text":"Full name: midgard.dev.exceptions.MissingDataError Signature: ()","title":"MissingDataError"},{"location":"api/midgard-dev/#missingentryerror","text":"Full name: midgard.dev.exceptions.MissingEntryError Signature: ()","title":"MissingEntryError"},{"location":"api/midgard-dev/#missingsectionerror","text":"Full name: midgard.dev.exceptions.MissingSectionError Signature: ()","title":"MissingSectionError"},{"location":"api/midgard-dev/#parsererror","text":"Full name: midgard.dev.exceptions.ParserError Signature: ()","title":"ParserError"},{"location":"api/midgard-dev/#timernotrunning","text":"Full name: midgard.dev.exceptions.TimerNotRunning Signature: ()","title":"TimerNotRunning"},{"location":"api/midgard-dev/#timerrunning","text":"Full name: midgard.dev.exceptions.TimerRunning Signature: ()","title":"TimerRunning"},{"location":"api/midgard-dev/#uniterror","text":"Full name: midgard.dev.exceptions.UnitError Signature: ()","title":"UnitError"},{"location":"api/midgard-dev/#unknownconstanterror","text":"Full name: midgard.dev.exceptions.UnknownConstantError Signature: ()","title":"UnknownConstantError"},{"location":"api/midgard-dev/#unknownconversionerror","text":"Full name: midgard.dev.exceptions.UnknownConversionError Signature: ()","title":"UnknownConversionError"},{"location":"api/midgard-dev/#unknownenumerror","text":"Full name: midgard.dev.exceptions.UnknownEnumError Signature: ()","title":"UnknownEnumError"},{"location":"api/midgard-dev/#unknownpackageerror","text":"Full name: midgard.dev.exceptions.UnknownPackageError Signature: ()","title":"UnknownPackageError"},{"location":"api/midgard-dev/#unknownpluginerror","text":"Full name: midgard.dev.exceptions.UnknownPluginError Signature: ()","title":"UnknownPluginError"},{"location":"api/midgard-dev/#unknownsystemerror","text":"Full name: midgard.dev.exceptions.UnknownSystemError Signature: ()","title":"UnknownSystemError"},{"location":"api/midgard-dev/#midgarddevlibrary","text":"Python wrapper around C-libraries Description: Loads a C-library. If a library is missing, a mock library is returned. If this mock is used for anything, a warning will be printed. This is done to avoid dependencies to all the C/C++-libraries for Python programs only using some of them.","title":"midgard.dev.library"},{"location":"api/midgard-dev/#simplemock","text":"Full name: midgard.dev.library.SimpleMock Signature: (name, raise_error=True) Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (typically because a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on).","title":"SimpleMock"},{"location":"api/midgard-dev/#load_name","text":"Full name: midgard.dev.library.load_name Signature: (library_name, func_specs=None, name_patterns=None) Load the given shared C-library See load_path for an explanation of the func_specs and name_patterns -arguments. Args: library_name (String): The name of the library. func_specs (Dict): Specification of types in lib (see load_path). name_patterns (List): Name mangling patterns (see load_path). Returns: ctypes.CDLL: Representation of the shared library.","title":"load_name()"},{"location":"api/midgard-dev/#load_path","text":"Full name: midgard.dev.library.load_path Signature: (library_path, func_specs=None, name_patterns=None) Load the given shared C-library The optional func_specs-dictionary can be used to specify argument and return types of functions in the library (see the ctypes documentation for information about argtypes and restype). The dictionary should be on the form:: func_spec = {'func_1': dict(func_name='name_of_func_1_in_lib', argtypes=[ ... argtypes of func_1 ... ], restype=... restype of func_1 ...), 'func_2': ... } If the library is not found, a mock library is returned instead. The mock library will print a warning if it is used. For some libraries, name mangling is used and this might be different depending on operating system and how the library is compiled. For instance, in a Fortran library the function Test might be represented as __Test on a Windows system and test_ (with lower-case t ) on a Linux system. This can be handled by providing a list of possible patterns. The above example can be handled by:: name_patterns = ('__{func_name}', '{func_name_lower}_') In this case, each function in func_specs is looked up by testing each pattern in turn until a match is found. Args: library_path (String): The path to the library. func_specs (Dict): Specification of types in library (see above). name_patterns (List): Name mangling patterns (see above). Returns: ctypes.CDLL: Representation of the shared library.","title":"load_path()"},{"location":"api/midgard-dev/#midgarddevlog","text":"Midgard library module for logging Description: This module provides simple logging inside Midgard. To use it, you must first add a an active logger. This is typically done using one of the init-functions: init() or file_init(). To write a log message, simply call one of midgard.log.debug, midgard.log.info, midgard.log.warn, midgard.log.error or midgard.log.fatal with a log message. To add a different logger, you should subclass the Logger abstract class. Example: >>> from midgard.dev import log >>> log.init(\"info\", prefix=\"My prefix\") >>> n, m = 5, 3 >>> log.info(f\"Calculating the inverse of a {n:>2d}x{m:<2d} matrix\") INFO [My prefix] Calculating the inverse of a 5x3 matrix","title":"midgard.dev.log"},{"location":"api/midgard-dev/#consolelogger","text":"Full name: midgard.dev.log.ConsoleLogger Signature: (log_level:Union[str, NoneType]=None, prefix:str='', use_command_line:bool=True) -> None Log to the console, the log level can also be set using command line parameters","title":"ConsoleLogger"},{"location":"api/midgard-dev/#filelogger","text":"Full name: midgard.dev.log.FileLogger Signature: (file_path:Union[str, pathlib.Path], log_level:Union[str, NoneType]=None, prefix:str='', rotation:Union[int, NoneType]=None) -> None Log to a file, the log files can be rotated so that older files are kept","title":"FileLogger"},{"location":"api/midgard-dev/#logger","text":"Full name: midgard.dev.log.Logger Signature: (log_level:Union[str, NoneType]=None, prefix:str='') Abstract class that can be specialized to create new loggers","title":"Logger"},{"location":"api/midgard-dev/#all","text":"Full name: midgard.dev.log.all Signature: (log_text:str, *, level:str='all') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"all()"},{"location":"api/midgard-dev/#blank","text":"Full name: midgard.dev.log.blank Signature: () -> None Log blank line","title":"blank()"},{"location":"api/midgard-dev/#debug","text":"Full name: midgard.dev.log.debug Signature: (log_text:str, *, level:str='debug') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"debug()"},{"location":"api/midgard-dev/#error","text":"Full name: midgard.dev.log.error Signature: (log_text:str, *, level:str='error') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"error()"},{"location":"api/midgard-dev/#fatal","text":"Full name: midgard.dev.log.fatal Signature: (log_text:str, *, level:str='fatal') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"fatal()"},{"location":"api/midgard-dev/#file_init","text":"Full name: midgard.dev.log.file_init Signature: (file_path:Union[str, pathlib.Path], log_level:Union[str, NoneType]=None, prefix:str='', rotation:Union[int, NoneType]=None) -> None Log to a file, the log files can be rotated so that older files are kept","title":"file_init"},{"location":"api/midgard-dev/#info","text":"Full name: midgard.dev.log.info Signature: (log_text:str, *, level:str='info') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"info()"},{"location":"api/midgard-dev/#init","text":"Full name: midgard.dev.log.init Signature: (log_level:Union[str, NoneType]=None, prefix:str='', use_command_line:bool=True) -> None Log to the console, the log level can also be set using command line parameters","title":"init"},{"location":"api/midgard-dev/#log","text":"Full name: midgard.dev.log.log Signature: (log_text:str, level:str) -> None Log text at the given level","title":"log()"},{"location":"api/midgard-dev/#none","text":"Full name: midgard.dev.log.none Signature: (log_text:str, *, level:str='none') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"none()"},{"location":"api/midgard-dev/#print_file","text":"Full name: midgard.dev.log.print_file Signature: (log_path:Union[str, pathlib.Path], log_level:str='info', print_func:Callable[[str], NoneType]=<built-in function print>) -> None Print a log file with colors, stripping away any item below log_level","title":"print_file()"},{"location":"api/midgard-dev/#warn","text":"Full name: midgard.dev.log.warn Signature: (log_text:str, *, level:str='warn') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"warn()"},{"location":"api/midgard-dev/#midgarddevoptional","text":"Midgard library module for handling optional dependencies Description: Import dependencies that are only necessary for specific parts of Midgard. Using this module will delay raising an ImportError until the dependency is actually used. This means that if one for instance only wants to run a GNSS analysis (or only use a Rinex-parser) installing special libraries only used for VLBI is not necessary. Examples: The optional import is typically used as follows:: from midgard.lib import optional netCDF4 = optional.optional_import('netCDF4')","title":"midgard.dev.optional"},{"location":"api/midgard-dev/#emptystringmock","text":"Full name: midgard.dev.optional.EmptyStringMock Signature: (name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None, error_msg:Union[str, NoneType]=None) -> None A mock object whose properties are all empty strings","title":"EmptyStringMock"},{"location":"api/midgard-dev/#simplemock_1","text":"Full name: midgard.dev.optional.SimpleMock Signature: (name:str, raise_error:bool=True, attrs:Union[Dict[str, Any], NoneType]=None, error_msg:Union[str, NoneType]=None) -> None Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (for instance if a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on). The exception is if any attributes ( attrs ) are explicitly defined on the mock. No exception is raised if those attributes are looked up.","title":"SimpleMock"},{"location":"api/midgard-dev/#optional_import","text":"Full name: midgard.dev.optional.optional_import Signature: (module_name:str, raise_error:bool=True, mock_cls:type=<class 'midgard.dev.optional.SimpleMock'>, attrs:Union[Dict[str, Any], NoneType]=None) -> Union[Any, midgard.dev.optional.SimpleMock] Try to import an optional module If the module does not exist, a SimpleMock-object is returned instead. If this SimpleMock-object is later used, an ImportError will be raised then (if raise_error is True, which is default). Args: module_name : Name of module to import. raise_error : Whether an ImportError should be raised if the module does not exist, but is used. attrs : Attributes that should be added to the SimpleMock used if the module does not exist. Returns: Imported module object, or a SimpleMock-object if the module can not be imported.","title":"optional_import()"},{"location":"api/midgard-dev/#midgarddevplugins","text":"Set up a plug-in architecture for Midgard Description: In order to be able to add models, parsers, data sources etc without needing to hardcode names, but rather pick them from configuration files, we use a simple plug-in architecture. The plug-in mechanism is based on the different plug-ins registering themselves using the register decorator: from midgard.dev import plugins @plugins.register def simple_model(rundate, tech, dset): ... Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. To list all plug-ins in a package use names : > from midgard.dev import plugins > plugins.names('midgard.models') ['model_one', 'model_three', 'model_two'] If the optional parameter config_key is given, then only plug-ins listed in the corresponding section in the current configuration file is listed. For instance, if the configuration file contains a line saying ham_models = model_three, model_one then we can list only the ham_models as follows: > from midgard.dev import plugins > plugins.names('midgard.models', config_key='ham_models') ['model_one', 'model_three'] Note that the plug-ins by default are sorted alphabetically. To run the plug-ins, use either call_all or call_one . The former calls all plug-ins and returns a dictionary containing the result from each plug-in. As with names the optional parameter config_key may be given: > from midgard.dev import plugins > plugins.call_all('midgard.models', config_key='ham_models', arg_to_plugin='hello') {'model_three': <result from model_three>, 'model_one': <result from model_one>} Arguments to the plug-ins should be passed as named arguments to call_all . Similarly, one plug-in may be called explicitly using call_one : > from midgard.dev import plugins > plugins.call_one('midgard.models', plugin_name='model_one', arg_to_plugin='hello') <result from model_one> There may be more than one function in each plug-in that is decorated by register . In this case, the default behaviour is that only the first function will be called. To call the other registered functions one should use the list_parts function to get a list of these functions and call them explicitly using the part optional parameter to call_one : > from midgard.dev import plugins > plugins.list_parts('midgard.techniques', plugin_name='vlbi') ['read', 'edit', 'calculate', 'estimate', 'write_result']) > for part in plugins.list_parts('midgard.techniques', plugin_name='vlbi'): ... plugins.call_one('midgard.techniques', plugin_name='vlbi', part=part, ...)","title":"midgard.dev.plugins"},{"location":"api/midgard-dev/#plugin","text":"Full name: midgard.dev.plugins.Plugin Signature: (name:str, function:Callable, file_path:pathlib.Path, sort_value:int) Information about a plug-in Args: name : Name of the plug-in. function : The plug-in. file_path : Path to the source code of the plug-in, may be used to add the source as a dependency. sort_value : Value used when sorting plug-ins in order to control the order they are called.","title":"Plugin"},{"location":"api/midgard-dev/#add_alias","text":"Full name: midgard.dev.plugins.add_alias Signature: (package_name:str, alias:str) -> None Add alias to plug-in package This allows one package of plug-ins to be spread over several directories Args: package_name : Name of package containing plug-ins. directory : Additional plug-in directory.","title":"add_alias()"},{"location":"api/midgard-dev/#call","text":"Full name: midgard.dev.plugins.call Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -> Any Call one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to the plug-in. Returns: Return value of the plug-in.","title":"call()"},{"location":"api/midgard-dev/#call_all","text":"Full name: midgard.dev.plugins.call_all Signature: (package_name:str, plugins:Union[List[str], NoneType]=None, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, plugin_logger:Union[Callable[[str], NoneType], NoneType]=None, **plugin_args:Any) -> Dict[str, Any] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list or in the config file does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-in names that should be used (optional). part : Name of function to call within the plug-ins (optional). prefix : Prefix of the plug-in names, used for a plug-in if it is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to all the plug-ins. Returns: Dictionary of all results from the plug-ins.","title":"call_all()"},{"location":"api/midgard-dev/#doc","text":"Full name: midgard.dev.plugins.doc Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False, use_module:bool=False) -> str Document one plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Documentation of the plug-in.","title":"doc()"},{"location":"api/midgard-dev/#doc_all","text":"Full name: midgard.dev.plugins.doc_all Signature: (package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None, long_doc:bool=True, include_details:bool=False, use_module:bool=False) -> Dict[str, str] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-ins are unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Dictionary of all doc-strings from the plug-ins.","title":"doc_all()"},{"location":"api/midgard-dev/#exists","text":"Full name: midgard.dev.plugins.exists Signature: (package_name:str, plugin_name:str) -> bool Check whether or not a plug-in exists in a package Tries to import the given plug-in. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). Returns: True if plug-in exists, False otherwise.","title":"exists()"},{"location":"api/midgard-dev/#get","text":"Full name: midgard.dev.plugins.get Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None) -> midgard.dev.plugins.Plugin Get a specific plugin-object If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be called. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). Returns: Plugin-namedtuple representing the plug-in.","title":"get()"},{"location":"api/midgard-dev/#load","text":"Full name: midgard.dev.plugins.load Signature: (package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -> str Load one plug-in from a package First tries to load the plugin with the given name. If that fails, it tries to load {prefix}_{plugin_name} instead. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Actual name of plug-in (with or without prefix).","title":"load()"},{"location":"api/midgard-dev/#names","text":"Full name: midgard.dev.plugins.names Signature: (package_name:str, plugins:Union[Iterable[str], NoneType]=None, prefix:Union[str, NoneType]=None) -> List[str] List plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be listed. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-in names are unknown (optional). Returns: List of strings with names of plug-ins.","title":"names()"},{"location":"api/midgard-dev/#parts","text":"Full name: midgard.dev.plugins.parts Signature: (package_name:str, plugin_name:str, prefix:Union[str, NoneType]=None) -> List[str] List all parts of one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in. prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: List : Strings with names of parts.","title":"parts()"},{"location":"api/midgard-dev/#register","text":"Full name: midgard.dev.plugins.register Signature: (func:Callable, name:Union[str, NoneType]=None, sort_value:int=0) -> Callable Decorator used to register a plug-in Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. The path to the source code file is also stored. This is used to be able to add the source code as a dependency file when the plug-in is called. If name is given, the plug-in is registered based on this name instead of the name of the module. The name of the module is still registered as a part that can be used to distinguish between similar plug-ins in different files (see for instance how session is used in midgard.pipelines ). Args: func : The function that is being registered. name : Alternative name of plug-in. Used by register_named . sort_value : The value used when sorting plug-ins. Used by register_ordered . Returns: The function that is being registered.","title":"register()"},{"location":"api/midgard-dev/#register_named","text":"Full name: midgard.dev.plugins.register_named Signature: (name:str) -> Callable Decorator used to register a named plug-in This allows for overriding the name used to register the plug-in. See register for more details. Args: name : Name used for plug-in instead of module name. Returns: Decorator that registers a named function.","title":"register_named()"},{"location":"api/midgard-dev/#register_ordered","text":"Full name: midgard.dev.plugins.register_ordered Signature: (sort_value:int) -> Callable Decorator used to register a plug-in with a specific sort order The sort value should be a number. Lower numbers are sorted first, higher numbers last. Plug-ins without an explicit sort_order gets the sort value of 0. Args: sort_value : The value used when sorting plug-ins. Returns: Decorator that registers an ordered function.","title":"register_ordered()"},{"location":"api/midgard-dev/#signature","text":"Full name: midgard.dev.plugins.signature Signature: (package_name:str, plugin_name:str, part:Union[str, NoneType]=None, prefix:Union[str, NoneType]=None) -> inspect.Signature Get signature of a plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Signature of the plugin","title":"signature()"},{"location":"api/midgard-dev/#midgarddevprofiler","text":"Add a profiler when running Supports several profilers including cprofile, line_profiler, memprof and memory_profiler.","title":"midgard.dev.profiler"},{"location":"api/midgard-dev/#cprofile","text":"Full name: midgard.dev.profiler.CProfile Signature: () cprofile is used for profiling the whole program","title":"CProfile"},{"location":"api/midgard-dev/#lineprofiler","text":"Full name: midgard.dev.profiler.LineProfiler Signature: () line_profiler is used to profile one or a few functions in detail","title":"LineProfiler"},{"location":"api/midgard-dev/#profiler","text":"Full name: midgard.dev.profiler.Profiler Signature: () Base class for profilers","title":"Profiler"},{"location":"api/midgard-dev/#midgarddevtimer","text":"Class for timing the running time of functions and code blocks Description: The dev.timer can be used to log the running time of functions and general code blocks. Typically, you will import the Timer -class from within the module: from midgard.dev.timer import Timer The Timer can then be used in three different ways: As a decorator to time one function: @Timer('The time to execute some_function was') def some_function(some_argument, some_other_argument=some_value): pass As a context manager together with with to time a code block: with Timer('Finish doing stuff in', logger=logger.debug) as t: do_something() do_something_else() With explicit start - and end -statements: t = Timer() t.start() do_something() do_something_else() t.end() As can be seen in the examples above, Timer() may be called with several optional parameters, including the text to report when the timer ends and which logger is used to report the timing. See Timer.__init__ for more details.","title":"midgard.dev.timer"},{"location":"api/midgard-dev/#accumulatedtimer","text":"Full name: midgard.dev.timer.AccumulatedTimer Signature: (text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=functools.partial(<function log at 0x7efd5b0b7378>, level='info')) -> None","title":"AccumulatedTimer"},{"location":"api/midgard-dev/#timer","text":"Full name: midgard.dev.timer.Timer Signature: (text:str='Elapsed time:', fmt:str='.4f', logger:Union[Callable[[str], NoneType], NoneType]=functools.partial(<function log at 0x7efd5b0b7378>, level='info')) -> None Class for timing running time of functions and code blocks.","title":"Timer"},{"location":"api/midgard-files/","text":"midgard.files midgard.files.dates Convenience functions for working with dates Description: Formats and converters that can be used for convenience and consistency. FMT_date (str) FMT_date = '%Y-%m-%d' FMT_datetime (str) FMT_datetime = '%Y-%m-%d %H:%M:%S' FMT_dt_file (str) FMT_dt_file = '%Y%m%d-%H%M%S' date_vars () Full name: midgard.files.dates.date_vars Signature: (date:Union[datetime.date, NoneType]) -> Dict[str, str] Construct a dict of date variables From a given date, construct a dict containing all relevant date variables. This dict can be used to for instance replace variables in file names. Examples: >>> from datetime import date >>> date_vars(date(2009, 11, 2)) # doctest: +NORMALIZE_WHITESPACE {'yyyy': '2009', 'ce': '20', 'yy': '09', 'm': '11', 'mm': '11', 'mmm': 'nov', 'MMM': 'NOV', 'd': '2', 'dd': '02', 'doy': '306', 'dow': '1', 'h': '0', 'hh': '00'} >>> date_vars(None) {} Args: date : The given date. Returns: Dictionary with date variables for the given date. midgard.files.dependencies Midgard library module for handling dependencies Description: Stores a list of files with a hash/checksum or a timestamp that can be used to detect if a file changes. Two strategies are available: Timestamps: Fast, but not always reliable as timestamps may update without the file actually changing. md5 hash/checksum: Slower, since it needs to read through the whole file, but will reliably only trigger when a file has changed. add () Full name: midgard.files.dependencies.add Signature: (*file_paths:Union[str, pathlib.Path], label:str='') -> None Add a list of files to the list of dependencies Records the current time stamp or md5 hash of the files specified by file paths, and stores as dependencies on the dependency file. Before adding dependencies, a call to init() has to be done, to set up where to store the dependencies. Args: file_paths : List of file paths to add to the dependency file. label : Optional label for dependencies. changed () Full name: midgard.files.dependencies.changed Signature: (file_path:Union[str, pathlib.Path], fast_check:bool=True) -> bool Check if the dependencies have changed Returns True if any of the files listed in the dependency file have changed, or if the dependency file itself does not exist. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums. Returns: True if any file has changed or if the dependecy file does not exist, False otherwise. get_md5 () Full name: midgard.files.dependencies.get_md5 Signature: (file_path:Union[str, pathlib.Path]) -> str Return a md5 checksum based on a file. Args: file_path : Path to file. Returns: Hex-string representing the contents of the file. get_paths_with_label () Full name: midgard.files.dependencies.get_paths_with_label Signature: (file_path:Union[str, pathlib.Path], label_pattern:str) -> List[pathlib.Path] Find all paths with the given label Args: file_path : Path to dependency file. label_pattern : String with label or regular expression (e.g. 'gnss_rinex_nav_[MGE]' or 'gnss_rinex_nav_.'). Returns: List : List of file paths. get_timestamp () Full name: midgard.files.dependencies.get_timestamp Signature: (file_path:Union[str, pathlib.Path]) -> str Return a textual timestamp from the modification date of a file Args: file_path : Path to file. Returns: String representing the modification date of the file. init () Full name: midgard.files.dependencies.init Signature: (file_path:Union[str, pathlib.Path], fast_check:bool=True) -> None Start a clean list of dependencies The file_path is to the file in which dependencies are stored. This is cached, so after init() is run, the other functions do not need to specify the file_path. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums. write () Full name: midgard.files.dependencies.write Signature: () -> None Write dependencies to file midgard.files.files Utilities for working with files move () Full name: midgard.files.files.move Signature: (from_path:Union[str, pathlib.Path], to_path:Union[str, pathlib.Path], overwrite:bool=True) -> None Move a file to another path With overwrite set to True, to_path may already exist and will be overwritten without warning. Setting overwrite to False will raise a FileExistsError if to_path already exists. Args: from_path : Path of file to be moved. to_path : Path file will be moved to. overwrite : If True, to_path may already exist. If False, to_path will never be overwritten. open () Full name: midgard.files.files.open Signature: (file_path:Union[str, pathlib.Path], create_dirs:bool=False, open_as_gzip:Union[bool, NoneType]=None, **open_args:Any) -> Iterator Open a file. Can automatically create the necessary directories before writing to a file, as well as handle gzipped files. With open_as_gzip set to None (default), it will try to detect whether the path is a .gz file simply by looking at the path suffix. For more control, you can set the parameter to True or False explicitly. Args: file_path : String or pathlib.Path representing the full file path. create_dirs : True or False, if True missing directories are created. open_as_gzip : Use gzip library to open file. open_args : All keyword arguments are passed on to the built-in open. Returns: File object representing the file. midgard.files.url Midgard library module, defining a URL class that mirrors Pathlib.Path Warning: There are many intricacies of URLs that are not handled by this class at the moment. URL Full name: midgard.files.url.URL Signature: () Simple wrapper around String to have URLs work similar to pathlib.Path","title":"midgard.files"},{"location":"api/midgard-files/#midgardfiles","text":"","title":"midgard.files"},{"location":"api/midgard-files/#midgardfilesdates","text":"Convenience functions for working with dates Description: Formats and converters that can be used for convenience and consistency.","title":"midgard.files.dates"},{"location":"api/midgard-files/#fmt_date-str","text":"FMT_date = '%Y-%m-%d'","title":"FMT_date (str)"},{"location":"api/midgard-files/#fmt_datetime-str","text":"FMT_datetime = '%Y-%m-%d %H:%M:%S'","title":"FMT_datetime (str)"},{"location":"api/midgard-files/#fmt_dt_file-str","text":"FMT_dt_file = '%Y%m%d-%H%M%S'","title":"FMT_dt_file (str)"},{"location":"api/midgard-files/#date_vars","text":"Full name: midgard.files.dates.date_vars Signature: (date:Union[datetime.date, NoneType]) -> Dict[str, str] Construct a dict of date variables From a given date, construct a dict containing all relevant date variables. This dict can be used to for instance replace variables in file names. Examples: >>> from datetime import date >>> date_vars(date(2009, 11, 2)) # doctest: +NORMALIZE_WHITESPACE {'yyyy': '2009', 'ce': '20', 'yy': '09', 'm': '11', 'mm': '11', 'mmm': 'nov', 'MMM': 'NOV', 'd': '2', 'dd': '02', 'doy': '306', 'dow': '1', 'h': '0', 'hh': '00'} >>> date_vars(None) {} Args: date : The given date. Returns: Dictionary with date variables for the given date.","title":"date_vars()"},{"location":"api/midgard-files/#midgardfilesdependencies","text":"Midgard library module for handling dependencies Description: Stores a list of files with a hash/checksum or a timestamp that can be used to detect if a file changes. Two strategies are available: Timestamps: Fast, but not always reliable as timestamps may update without the file actually changing. md5 hash/checksum: Slower, since it needs to read through the whole file, but will reliably only trigger when a file has changed.","title":"midgard.files.dependencies"},{"location":"api/midgard-files/#add","text":"Full name: midgard.files.dependencies.add Signature: (*file_paths:Union[str, pathlib.Path], label:str='') -> None Add a list of files to the list of dependencies Records the current time stamp or md5 hash of the files specified by file paths, and stores as dependencies on the dependency file. Before adding dependencies, a call to init() has to be done, to set up where to store the dependencies. Args: file_paths : List of file paths to add to the dependency file. label : Optional label for dependencies.","title":"add()"},{"location":"api/midgard-files/#changed","text":"Full name: midgard.files.dependencies.changed Signature: (file_path:Union[str, pathlib.Path], fast_check:bool=True) -> bool Check if the dependencies have changed Returns True if any of the files listed in the dependency file have changed, or if the dependency file itself does not exist. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums. Returns: True if any file has changed or if the dependecy file does not exist, False otherwise.","title":"changed()"},{"location":"api/midgard-files/#get_md5","text":"Full name: midgard.files.dependencies.get_md5 Signature: (file_path:Union[str, pathlib.Path]) -> str Return a md5 checksum based on a file. Args: file_path : Path to file. Returns: Hex-string representing the contents of the file.","title":"get_md5()"},{"location":"api/midgard-files/#get_paths_with_label","text":"Full name: midgard.files.dependencies.get_paths_with_label Signature: (file_path:Union[str, pathlib.Path], label_pattern:str) -> List[pathlib.Path] Find all paths with the given label Args: file_path : Path to dependency file. label_pattern : String with label or regular expression (e.g. 'gnss_rinex_nav_[MGE]' or 'gnss_rinex_nav_.'). Returns: List : List of file paths.","title":"get_paths_with_label()"},{"location":"api/midgard-files/#get_timestamp","text":"Full name: midgard.files.dependencies.get_timestamp Signature: (file_path:Union[str, pathlib.Path]) -> str Return a textual timestamp from the modification date of a file Args: file_path : Path to file. Returns: String representing the modification date of the file.","title":"get_timestamp()"},{"location":"api/midgard-files/#init","text":"Full name: midgard.files.dependencies.init Signature: (file_path:Union[str, pathlib.Path], fast_check:bool=True) -> None Start a clean list of dependencies The file_path is to the file in which dependencies are stored. This is cached, so after init() is run, the other functions do not need to specify the file_path. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums.","title":"init()"},{"location":"api/midgard-files/#write","text":"Full name: midgard.files.dependencies.write Signature: () -> None Write dependencies to file","title":"write()"},{"location":"api/midgard-files/#midgardfilesfiles","text":"Utilities for working with files","title":"midgard.files.files"},{"location":"api/midgard-files/#move","text":"Full name: midgard.files.files.move Signature: (from_path:Union[str, pathlib.Path], to_path:Union[str, pathlib.Path], overwrite:bool=True) -> None Move a file to another path With overwrite set to True, to_path may already exist and will be overwritten without warning. Setting overwrite to False will raise a FileExistsError if to_path already exists. Args: from_path : Path of file to be moved. to_path : Path file will be moved to. overwrite : If True, to_path may already exist. If False, to_path will never be overwritten.","title":"move()"},{"location":"api/midgard-files/#open","text":"Full name: midgard.files.files.open Signature: (file_path:Union[str, pathlib.Path], create_dirs:bool=False, open_as_gzip:Union[bool, NoneType]=None, **open_args:Any) -> Iterator Open a file. Can automatically create the necessary directories before writing to a file, as well as handle gzipped files. With open_as_gzip set to None (default), it will try to detect whether the path is a .gz file simply by looking at the path suffix. For more control, you can set the parameter to True or False explicitly. Args: file_path : String or pathlib.Path representing the full file path. create_dirs : True or False, if True missing directories are created. open_as_gzip : Use gzip library to open file. open_args : All keyword arguments are passed on to the built-in open. Returns: File object representing the file.","title":"open()"},{"location":"api/midgard-files/#midgardfilesurl","text":"Midgard library module, defining a URL class that mirrors Pathlib.Path Warning: There are many intricacies of URLs that are not handled by this class at the moment.","title":"midgard.files.url"},{"location":"api/midgard-files/#url","text":"Full name: midgard.files.url.URL Signature: () Simple wrapper around String to have URLs work similar to pathlib.Path","title":"URL"},{"location":"api/midgard-gnss/","text":"midgard.gnss midgard.gnss.solution_validation comp_quality_indicators () Full name: midgard.gnss.solution_validation.comp_quality_indicators Signature: (sol_vc_mat:numpy.ndarray) -> tuple Compute quality indicators Following quality indicators are computed 1. compute the standard error ellipse(SEE) 2. compute the distance root mean squared (DRMS) 3. compute the circular error probable (CEP) Args: sol_vc_mat : Variance-covariance matrix of the unknown Returns: Tuple with DRMS, CEP and SEE compute_dops () Full name: midgard.gnss.solution_validation.compute_dops Signature: (az:numpy.ndarray, el:numpy.ndarray, el_mask:float=0, min_num_sats:int=4) -> Tuple[numpy.ndarray, ...] Compute DOP (dilution of precision) Args: az : Satellite azimuth angle (radians) el : Satellite elevation angle (radians) el_mask : Elevation cut-off angle (radians) min_num_sats : Minimum number of satellites for a valid solution Returns: Tuple with GDOP, PDOP, HDOP and VDOP epilog (str) epilog = '\\n**EXAMPLE**\\n sol_validation (residuals, alpha_sign_level n_params)\\n args:\\n residuals (I): postfit residuals \\n alpha_sign_level(I): alpha significance level and defines the rejection area.\\n possible values of alpha = 0.05 (95%), 0.01 (99%) and 0.001 (99.9%)\\n n_params (I): number of estimated parameters (states).\\n \\n\\nKeywords: Chi-square distribution,\\n' get_my_parser () Full name: midgard.gnss.solution_validation.get_my_parser Signature: () main () Full name: midgard.gnss.solution_validation.main Signature: () Main program for testing solution validation implementation TODO: This should be done via midgard/tests/gnss !!! prolog (str) prolog = '\\n**PROGRAM**\\n solution_validation.py\\n \\n**PURPOSE**\\n Perform Chi-square test for residuals. Degrees of freedom (df) refers to the number of values that\\n are free to vary df = number of valid satellites (nv) - number of parameters to be estimated (nx) - 1.\\n GNSS solution validation based on the argument alpha, the level of significance (e.g. 99%), and\\n defines the rejection level of the crossing events. \\n Note that this is different from the false alarm rate, which instead refers to error type I\\n \\n**USAGE**\\n' sol_validation () Full name: midgard.gnss.solution_validation.sol_validation Signature: (residuals:numpy.ndarray, alpha_siglev:float, n_params:int=4) -> bool Validating the GNSS solution is carried out using Chi-square test Use Chi-square test for outlier detection and rejection. Args: residuals : Postfit residuals for all satellites in each epoch alpha_siglev : Alpha significance level n_params : Number of parameters (states), normally 4 parameters for station coordinates and receiver clock Returns: Array containing False for observations to throw away.","title":"midgard.gnss"},{"location":"api/midgard-gnss/#midgardgnss","text":"","title":"midgard.gnss"},{"location":"api/midgard-gnss/#midgardgnsssolution_validation","text":"","title":"midgard.gnss.solution_validation"},{"location":"api/midgard-gnss/#comp_quality_indicators","text":"Full name: midgard.gnss.solution_validation.comp_quality_indicators Signature: (sol_vc_mat:numpy.ndarray) -> tuple Compute quality indicators Following quality indicators are computed 1. compute the standard error ellipse(SEE) 2. compute the distance root mean squared (DRMS) 3. compute the circular error probable (CEP) Args: sol_vc_mat : Variance-covariance matrix of the unknown Returns: Tuple with DRMS, CEP and SEE","title":"comp_quality_indicators()"},{"location":"api/midgard-gnss/#compute_dops","text":"Full name: midgard.gnss.solution_validation.compute_dops Signature: (az:numpy.ndarray, el:numpy.ndarray, el_mask:float=0, min_num_sats:int=4) -> Tuple[numpy.ndarray, ...] Compute DOP (dilution of precision) Args: az : Satellite azimuth angle (radians) el : Satellite elevation angle (radians) el_mask : Elevation cut-off angle (radians) min_num_sats : Minimum number of satellites for a valid solution Returns: Tuple with GDOP, PDOP, HDOP and VDOP","title":"compute_dops()"},{"location":"api/midgard-gnss/#epilog-str","text":"epilog = '\\n**EXAMPLE**\\n sol_validation (residuals, alpha_sign_level n_params)\\n args:\\n residuals (I): postfit residuals \\n alpha_sign_level(I): alpha significance level and defines the rejection area.\\n possible values of alpha = 0.05 (95%), 0.01 (99%) and 0.001 (99.9%)\\n n_params (I): number of estimated parameters (states).\\n \\n\\nKeywords: Chi-square distribution,\\n'","title":"epilog (str)"},{"location":"api/midgard-gnss/#get_my_parser","text":"Full name: midgard.gnss.solution_validation.get_my_parser Signature: ()","title":"get_my_parser()"},{"location":"api/midgard-gnss/#main","text":"Full name: midgard.gnss.solution_validation.main Signature: () Main program for testing solution validation implementation","title":"main()"},{"location":"api/midgard-gnss/#todo-this-should-be-done-via-midgardtestsgnss","text":"","title":"TODO: This should be done via midgard/tests/gnss !!!"},{"location":"api/midgard-gnss/#prolog-str","text":"prolog = '\\n**PROGRAM**\\n solution_validation.py\\n \\n**PURPOSE**\\n Perform Chi-square test for residuals. Degrees of freedom (df) refers to the number of values that\\n are free to vary df = number of valid satellites (nv) - number of parameters to be estimated (nx) - 1.\\n GNSS solution validation based on the argument alpha, the level of significance (e.g. 99%), and\\n defines the rejection level of the crossing events. \\n Note that this is different from the false alarm rate, which instead refers to error type I\\n \\n**USAGE**\\n'","title":"prolog (str)"},{"location":"api/midgard-gnss/#sol_validation","text":"Full name: midgard.gnss.solution_validation.sol_validation Signature: (residuals:numpy.ndarray, alpha_siglev:float, n_params:int=4) -> bool Validating the GNSS solution is carried out using Chi-square test Use Chi-square test for outlier detection and rejection. Args: residuals : Postfit residuals for all satellites in each epoch alpha_siglev : Alpha significance level n_params : Number of parameters (states), normally 4 parameters for station coordinates and receiver clock Returns: Array containing False for observations to throw away.","title":"sol_validation()"},{"location":"api/midgard-ionosphere/","text":"midgard.ionosphere midgard.ionosphere.klobuchar Klobuchar model for computing the ionospheric time-delay correction. Description: Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model). GPS and Beidu satellite navigation systems use this model. The implementation is based on original paper of Klobuchar (1987). The Klobuchar model is also described in Figure 20-4 in IS-GPS-200J. References: IS-GPS-200J (2018): \"Global positioning systems directorate systems engineering & integration interface specification IS-GPS-200, Navstar GPS space Segment/Navigation user segment interfaces, 25. April 2018 Klobuchar, J.A. (1987): \"Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users\", IEEE Transactions on Aerospace and Electronic Systems, Vol. AES-23, No. 3, May 1987, https://scinapse.io/papers/2058160370 Sanz Subirana, J., Juan Zornoza, J.M. and Hernandez-Pajares, M. (2013): \"GNSS data processing - Volume I: Fundamentals and Algorithms\", TM-23/1, European Space Agency, May 2013 klobuchar () Full name: midgard.ionosphere.klobuchar.klobuchar Signature: (time, ion_coeffs, rec_pos, az, el, freq_l1, freq=None, logger=functools.partial(<function log at 0x7efd5b0b7378>, level='info')) Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model) GPS and BeiDou satellite navigation systems use this model. The implementation is based on original paper of Klobuchar, J.A. Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users https://scinapse.io/papers/2058160370 Args: time : GPST ion_coeffs : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector rec_pos : receiver position {lat,lon,h} [rad, rad, m] as vector az : azimuth angle [rad] el : elevation angle [rad] system : GNSS system freq_l1 : L1 frequency of given GNSS in [Hz] freq : Frequency in [Hz] for which ionospheric delay should be determined. logger : Function that logs Returns: iono_delay : computed path delay for given frequency [m] L1_variance : corresponding variance [m^2] TODO: freq_L1 should be determined in klobuchar routine and argument be replaced by system. constants needed in Midgard. main () Full name: midgard.ionosphere.klobuchar.main Signature: ()","title":"midgard.ionosphere"},{"location":"api/midgard-ionosphere/#midgardionosphere","text":"","title":"midgard.ionosphere"},{"location":"api/midgard-ionosphere/#midgardionosphereklobuchar","text":"Klobuchar model for computing the ionospheric time-delay correction. Description: Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model). GPS and Beidu satellite navigation systems use this model. The implementation is based on original paper of Klobuchar (1987). The Klobuchar model is also described in Figure 20-4 in IS-GPS-200J. References: IS-GPS-200J (2018): \"Global positioning systems directorate systems engineering & integration interface specification IS-GPS-200, Navstar GPS space Segment/Navigation user segment interfaces, 25. April 2018 Klobuchar, J.A. (1987): \"Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users\", IEEE Transactions on Aerospace and Electronic Systems, Vol. AES-23, No. 3, May 1987, https://scinapse.io/papers/2058160370 Sanz Subirana, J., Juan Zornoza, J.M. and Hernandez-Pajares, M. (2013): \"GNSS data processing - Volume I: Fundamentals and Algorithms\", TM-23/1, European Space Agency, May 2013","title":"midgard.ionosphere.klobuchar"},{"location":"api/midgard-ionosphere/#klobuchar","text":"Full name: midgard.ionosphere.klobuchar.klobuchar Signature: (time, ion_coeffs, rec_pos, az, el, freq_l1, freq=None, logger=functools.partial(<function log at 0x7efd5b0b7378>, level='info')) Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model) GPS and BeiDou satellite navigation systems use this model. The implementation is based on original paper of Klobuchar, J.A. Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users https://scinapse.io/papers/2058160370 Args: time : GPST ion_coeffs : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector rec_pos : receiver position {lat,lon,h} [rad, rad, m] as vector az : azimuth angle [rad] el : elevation angle [rad] system : GNSS system freq_l1 : L1 frequency of given GNSS in [Hz] freq : Frequency in [Hz] for which ionospheric delay should be determined. logger : Function that logs Returns: iono_delay : computed path delay for given frequency [m] L1_variance : corresponding variance [m^2] TODO: freq_L1 should be determined in klobuchar routine and argument be replaced by system. constants needed in Midgard.","title":"klobuchar()"},{"location":"api/midgard-ionosphere/#main","text":"Full name: midgard.ionosphere.klobuchar.main Signature: ()","title":"main()"},{"location":"api/midgard-math/","text":"midgard.math midgard.math.constant Midgard library module defining an assortment of constants Description: This module provides constants that are used within the Midgard project. The actual constants are defined in the constants.conf file (see the file list for location). See that file for references and for adding or changing constants. The constants are stored as module variables so they can be used simply as constant.c as in the example above. Some models use particular values for constants that are different from the conventional ones. This is handled by the source parameter. For instance, the EGM 2008 gravity field is calculated with a value for GM different from the IERS Conventions value, using:: constant.get('GM', source='egm_2008') instead of simply constant.GM . Example: >>> from midgard.math.constant import Constant >>> print(f\"The speed of light is {constant.c:0.2f}\") The speed of light is 299792458.00 Todo: Rewrite as a class instead of a module, to have somewhat cleaner code (and be more consistent with things like lib.unit). Constant Full name: midgard.math.constant.Constant Signature: () -> None constant (Constant) constant = Constant('/home/kirann/anaconda3/lib/python3.6/site-packages/midgard/math/constant.txt') midgard.math.ellipsoid Midgard library module for handling Earth ellipsoids Description: Ellipsoid Full name: midgard.math.ellipsoid.Ellipsoid Signature: (name:str, a:float, f_inv:float, description:str) -> None Ellipsoid(name:str, a:float, f_inv:float, description:str) GRS80 (Ellipsoid) GRS80 = Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS') IERS2003 (Ellipsoid) IERS2003 = Ellipsoid(name='IERS2003', a=6378136.6, f_inv=298.25642, description='IERS conventions 2003, p. 12') IERS2010 (Ellipsoid) IERS2010 = Ellipsoid(name='IERS2010', a=6378136.6, f_inv=298.25642, description='IERS conventions 2010, p. 18') WGS72 (Ellipsoid) WGS72 = Ellipsoid(name='WGS72', a=6378135, f_inv=298.26, description='WGS72') WGS84 (Ellipsoid) WGS84 = Ellipsoid(name='WGS84', a=6378137, f_inv=298.257223563, description='Used by GPS') get () Full name: midgard.math.ellipsoid.get Signature: (ellipsoid:str) -> 'Ellipsoid' Get an ellipsoid by name sphere (Ellipsoid) sphere = Ellipsoid(name='sphere', a=6371008.8, f_inv=inf, description='Regular sphere, mean radius') midgard.math.interpolation Methods for interpolating in numpy arrays Description: Different interpolation methods are decorated with @register_interpolator and will then become available for use as kind in interpolate and moving_window . Example: >>> import numpy as np >>> np.set_printoptions(precision=3, suppress=True) >>> x = np.linspace(-1, 1, 11) >>> y = x**3 - x >>> y array([ 0. , 0.288, 0.384, 0.336, 0.192, 0. , -0.192, -0.336, -0.384, -0.288, 0. ]) >>> x_new = np.linspace(-0.8, 0.8, 11) >>> interpolate(x, y, x_new, kind='cubic') array([ 0.288, 0.378, 0.369, 0.287, 0.156, -0. , -0.156, -0.287, -0.369, -0.378, -0.288]) Developer info: To add your own interpolators, you can simply decorate your interpolator functions with @register_interpolator . Your interpolator function should have the signature (x: np.ndarray, y: np.ndarray) -> Callable For instance, the following would implement a terrible interpolation function that sets all values to zero: from midgard.math.interpolation import register_interpolator @register_interpolator def zero(x: np.ndarray, y: np.ndarray) -> Callable: def _zero(x_new: np.ndarray) -> np.ndarray: return np.zeros(y.shape) return _zero This function would then be available as an interpolator. For instance, one could do >>> interpolate(x, y, x_new, kind='zero') # doctest: +SKIP array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) barycentric_interpolator () Full name: midgard.math.interpolation.barycentric_interpolator Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable The interpolating polynomial through the given points Uses the scipy.interpolate.BarycentricInterpolator function behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Barycentric interpolation function cubic () Full name: midgard.math.interpolation.cubic Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable Cubic spline interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='cubic' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Cubic spline interpolation function get_interpolator () Full name: midgard.math.interpolation.get_interpolator Signature: (name:str) -> Callable Return an interpolation function Interpolation functions are registered by the @register_interpolator-decorator. The name-parameter corresponds to the function name of the interpolator. Args: name : Name of interpolator. Returns: Interpolation function with the given name. interpolate () Full name: midgard.math.interpolation.interpolate Signature: (x:numpy.ndarray, y:numpy.ndarray, x_new:numpy.ndarray, *, kind:str, **ipargs:Any) -> numpy.ndarray Interpolate values from one x-array to another See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. ipargs : Keyword arguments passed on to the interpolator. Returns: Array of interpolated y-values. interpolate_with_derivative () Full name: midgard.math.interpolation.interpolate_with_derivative Signature: (x:numpy.ndarray, y:numpy.ndarray, x_new:numpy.ndarray, *, kind:str, dx:float=0.5, **ipargs:Any) -> numpy.ndarray Interpolate values from one x-array to another as well as find derivatives See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. dx : Values at x \u00b1 dx are used to determine derivative. ipargs : Keyword arguments passed on to the interpolator. Returns: Tuple with array of interpolated y-values and array of derivatives. interpolated_univariate_spline () Full name: midgard.math.interpolation.interpolated_univariate_spline Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable One-dimensional interpolating spline for the given points Uses the scipy.interpolate.InterpolatedUnivariateSpline function behind the scenes. The original only deals with one-dimensional y arrays, so multiple calls are made for higher dimensional y arrays. The dimensions are handled independently of each other. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Interpolating spline function interpolators () Full name: midgard.math.interpolation.interpolators Signature: () -> List[str] Return a list of available interpolators Returns: Names of available interpolators. lagrange () Full name: midgard.math.interpolation.lagrange Signature: (x:numpy.ndarray, y:numpy.ndarray, *, window:int=10, bounds_error:bool=True, assume_sorted:bool=False) -> Callable Computes the lagrange polynomial passing through a certain set of points See https://en.wikipedia.org/wiki/Lagrange_polynomial Uses window of the original points to calculate the Lagrange polynomials. The window of points is chosen by finding the closest original point and essentially picking the window // 2 indices on either side. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. window : Number of points used in interpolation. bounds_error : If True, a ValueError is raised if extrapolation is attempted. assume_sorted : If True, x must be an array of monotonically increasing values. Returns: Lagrange interpolation function. linear () Full name: midgard.math.interpolation.linear Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable Linear interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='linear' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Linear interpolation function register_interpolator () Full name: midgard.math.interpolation.register_interpolator Signature: (func:Callable) -> Callable Register an interpolation function This function should be used as a @register_interpolator-decorator Args: func : Function that will be registered as an interpolator. Returns: Same function. midgard.math.rotation Library for basic rotation matrices Description: Creates rotation matrices for rotation around the axes of a right handed Cartesian coordinate system and their derivatives. For instance, for an XYZ-system, R1 returns a rotation matrix around the x-axis and for an ENU-system, R1 returns a rotation matrix around the east-axis. dR1 returns the derivative of the R1 matrix with respect to the rotation angle. All functions are vectorized, so that one rotation matrix is returned per input angle. Example: from where.lib import rotation rotation.R1([0, 1]) array([[[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , -0. , 1. ]], [[ 1. , 0. , 0. ], [ 0. , 0.54030231, 0.84147098], [ 0. , -0.84147098, 0.54030231]]]) R1 () Full name: midgard.math.rotation.R1 Signature: (angle:~np_float) -> numpy.ndarray Rotation matrix around the first axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. R2 () Full name: midgard.math.rotation.R2 Signature: (angle:~np_float) -> numpy.ndarray Rotation matrix around the second axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. R3 () Full name: midgard.math.rotation.R3 Signature: (angle:~np_float) -> numpy.ndarray Rotation matrix around the third axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. dR1 () Full name: midgard.math.rotation.dR1 Signature: (angle:~np_float) -> numpy.ndarray Derivative of a rotation matrix around the first axis with respect to the rotation angle. Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. dR2 () Full name: midgard.math.rotation.dR2 Signature: (angle:~np_float) -> numpy.ndarray Derivative of a rotation matrix around the second axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. dR3 () Full name: midgard.math.rotation.dR3 Signature: (angle:~np_float) -> numpy.ndarray Derivative of a rotation matrix around the third axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. enu2trs () Full name: midgard.math.rotation.enu2trs Signature: (lat:~np_float, lon:~np_float) -> numpy.ndarray Rotation matrix for rotating an ENU coordinate system to an earth oriented one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R3(-(np.pi/2 + lon)) @ R1(-(np.pi/2 - lat)) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices. trs2enu () Full name: midgard.math.rotation.trs2enu Signature: (lat:~np_float, lon:~np_float) -> numpy.ndarray Rotation matrix for rotating an earth oriented coordinate system to an ENU one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R1(np.pi/2 - lat) @ R3(np.pi/2 + lon) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices. midgard.math.transformation Midgard library module for handling of geodetic conversions Description: delta_enu2trs () Full name: midgard.math.transformation.delta_enu2trs Signature: (enu:'EnuPositionDelta') -> 'TrsPositionDelta' Convert position deltas from ENU to TRS delta_enu2trs_posvel () Full name: midgard.math.transformation.delta_enu2trs_posvel Signature: (enu:'EnuPosVelDelta') -> 'TrsPosVelDelta' Convert position deltas from ENU to TRS delta_trs2enu () Full name: midgard.math.transformation.delta_trs2enu Signature: (trs:'TrsPositionDelta') -> 'EnuPositionDelta' Convert position deltas from TRS to ENU delta_trs2enu_posvel () Full name: midgard.math.transformation.delta_trs2enu_posvel Signature: (trs:'TrsPosVelDelta') -> 'EnuPosVelDelta' Convert position deltas from TRS to ENU llh2trs () Full name: midgard.math.transformation.llh2trs Signature: (llh:numpy.ndarray, ellipsoid:midgard.math.ellipsoid.Ellipsoid=None) -> numpy.ndarray Convert geodetic latitude-, longitude-, height-coordinates to geocentric xyz-coordinates Reimplementation of GD2GCE.for from the IUA SOFA software collection. trs2llh () Full name: midgard.math.transformation.trs2llh Signature: (trs:numpy.ndarray, ellipsoid:midgard.math.ellipsoid.Ellipsoid=None) -> numpy.ndarray Convert geocentric xyz-coordinates to geodetic latitude-, longitude-, height-coordinates Reimplementation of GC2GDE.for from the IUA SOFA software collection. midgard.math.unit Midgard library module for handling of SI-unit conversions Description: This module provides unit conversion constants and functions. The heavy lifting is done by the pint package. The basic usage is as follows: >>> from midgard.math.unit import Unit >>> seconds_in_two_weeks = 2 * Unit.week2secs >>> seconds_in_two_weeks 1209600.0 In general Unit.spam2ham will give the multiplicative conversion scale between the units spam and ham . Through the pint package we support a lot of units. See Unit.list() or https://github.com/hgrecco/pint/blob/master/pint/default_en.txt . Another notation is also available, and might be necessary for some more complicated conversions: >>> seconds_in_two_weeks = 2 * Unit('week', 'seconds') >>> miles_per_hour_in_meters_per_second = Unit('mph', 'meters / sec') Do note that we support most normal aliases as well as singular and plural forms of the units. For instance can second be represented as s , sec , secs and seconds . Prefixes are also handled: >>> nanoseconds_in_an_hour = Unit.hour2nanosecs >>> inches_in_a_kilometer = Unit.km2inches For more complicated conversions (for instance from Celsius to Fahrenheit) one can create custom conversion functions using convert : >>> c2f = Unit.function('celsius', 'fahrenheit') >>> absolute_zero_in_fahrenheit = c2f(-273.15) For convenience, this can also be written using the attribute notation as Unit.spam_to_ham(spam_value) . Then the previous example simply becomes: >>> absolute_zero_in_fahrenheit = Unit.celsius_to_fahrenheit(-273.15) (or even easier Unit.kelvin_to_fahrenheit(0) ). Finally, we can access the unit/quantity system of pint by using the name of a unit by itself, e.g. Unit.spam . For instance: >>> distance = 42 * Unit.km >>> time = 31 * Unit('minutes') >>> speed = distance / time >>> speed.to(Unit.mph) <Quantity(50.511464659292955, 'mph')> >>> speed.to_base_units() <Quantity(22.580645161290324, 'meter / second')> However, using the full unit system adds some overhead so we should be careful in using it in heavy calculations. Note that pint has a system for defining new units and constants if necessary, http://pint.readthedocs.io/en/latest/defining.html . To use this system, add units to the unit.txt file in the current (midgard/math) directory. Unit Full name: midgard.math.unit.Unit Signature: (from_unit:str, to_unit:Union[str, NoneType]=None) -> Any Unit converter The implementation of the unit conversion is done in the _convert_units -metaclass. fid (TextIOWrapper) fid = <_io.TextIOWrapper name='/home/kirann/anaconda3/lib/python3.6/site-packages/midgard/math/unit.txt' mode='r' encoding='utf-8'>","title":"midgard.math"},{"location":"api/midgard-math/#midgardmath","text":"","title":"midgard.math"},{"location":"api/midgard-math/#midgardmathconstant","text":"Midgard library module defining an assortment of constants Description: This module provides constants that are used within the Midgard project. The actual constants are defined in the constants.conf file (see the file list for location). See that file for references and for adding or changing constants. The constants are stored as module variables so they can be used simply as constant.c as in the example above. Some models use particular values for constants that are different from the conventional ones. This is handled by the source parameter. For instance, the EGM 2008 gravity field is calculated with a value for GM different from the IERS Conventions value, using:: constant.get('GM', source='egm_2008') instead of simply constant.GM . Example: >>> from midgard.math.constant import Constant >>> print(f\"The speed of light is {constant.c:0.2f}\") The speed of light is 299792458.00 Todo: Rewrite as a class instead of a module, to have somewhat cleaner code (and be more consistent with things like lib.unit).","title":"midgard.math.constant"},{"location":"api/midgard-math/#constant","text":"Full name: midgard.math.constant.Constant Signature: () -> None","title":"Constant"},{"location":"api/midgard-math/#constant-constant","text":"constant = Constant('/home/kirann/anaconda3/lib/python3.6/site-packages/midgard/math/constant.txt')","title":"constant (Constant)"},{"location":"api/midgard-math/#midgardmathellipsoid","text":"Midgard library module for handling Earth ellipsoids Description:","title":"midgard.math.ellipsoid"},{"location":"api/midgard-math/#ellipsoid","text":"Full name: midgard.math.ellipsoid.Ellipsoid Signature: (name:str, a:float, f_inv:float, description:str) -> None Ellipsoid(name:str, a:float, f_inv:float, description:str)","title":"Ellipsoid"},{"location":"api/midgard-math/#grs80-ellipsoid","text":"GRS80 = Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS')","title":"GRS80 (Ellipsoid)"},{"location":"api/midgard-math/#iers2003-ellipsoid","text":"IERS2003 = Ellipsoid(name='IERS2003', a=6378136.6, f_inv=298.25642, description='IERS conventions 2003, p. 12')","title":"IERS2003 (Ellipsoid)"},{"location":"api/midgard-math/#iers2010-ellipsoid","text":"IERS2010 = Ellipsoid(name='IERS2010', a=6378136.6, f_inv=298.25642, description='IERS conventions 2010, p. 18')","title":"IERS2010 (Ellipsoid)"},{"location":"api/midgard-math/#wgs72-ellipsoid","text":"WGS72 = Ellipsoid(name='WGS72', a=6378135, f_inv=298.26, description='WGS72')","title":"WGS72 (Ellipsoid)"},{"location":"api/midgard-math/#wgs84-ellipsoid","text":"WGS84 = Ellipsoid(name='WGS84', a=6378137, f_inv=298.257223563, description='Used by GPS')","title":"WGS84 (Ellipsoid)"},{"location":"api/midgard-math/#get","text":"Full name: midgard.math.ellipsoid.get Signature: (ellipsoid:str) -> 'Ellipsoid' Get an ellipsoid by name","title":"get()"},{"location":"api/midgard-math/#sphere-ellipsoid","text":"sphere = Ellipsoid(name='sphere', a=6371008.8, f_inv=inf, description='Regular sphere, mean radius')","title":"sphere (Ellipsoid)"},{"location":"api/midgard-math/#midgardmathinterpolation","text":"Methods for interpolating in numpy arrays Description: Different interpolation methods are decorated with @register_interpolator and will then become available for use as kind in interpolate and moving_window . Example: >>> import numpy as np >>> np.set_printoptions(precision=3, suppress=True) >>> x = np.linspace(-1, 1, 11) >>> y = x**3 - x >>> y array([ 0. , 0.288, 0.384, 0.336, 0.192, 0. , -0.192, -0.336, -0.384, -0.288, 0. ]) >>> x_new = np.linspace(-0.8, 0.8, 11) >>> interpolate(x, y, x_new, kind='cubic') array([ 0.288, 0.378, 0.369, 0.287, 0.156, -0. , -0.156, -0.287, -0.369, -0.378, -0.288]) Developer info: To add your own interpolators, you can simply decorate your interpolator functions with @register_interpolator . Your interpolator function should have the signature (x: np.ndarray, y: np.ndarray) -> Callable For instance, the following would implement a terrible interpolation function that sets all values to zero: from midgard.math.interpolation import register_interpolator @register_interpolator def zero(x: np.ndarray, y: np.ndarray) -> Callable: def _zero(x_new: np.ndarray) -> np.ndarray: return np.zeros(y.shape) return _zero This function would then be available as an interpolator. For instance, one could do >>> interpolate(x, y, x_new, kind='zero') # doctest: +SKIP array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])","title":"midgard.math.interpolation"},{"location":"api/midgard-math/#barycentric_interpolator","text":"Full name: midgard.math.interpolation.barycentric_interpolator Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable The interpolating polynomial through the given points Uses the scipy.interpolate.BarycentricInterpolator function behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Barycentric interpolation function","title":"barycentric_interpolator()"},{"location":"api/midgard-math/#cubic","text":"Full name: midgard.math.interpolation.cubic Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable Cubic spline interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='cubic' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Cubic spline interpolation function","title":"cubic()"},{"location":"api/midgard-math/#get_interpolator","text":"Full name: midgard.math.interpolation.get_interpolator Signature: (name:str) -> Callable Return an interpolation function Interpolation functions are registered by the @register_interpolator-decorator. The name-parameter corresponds to the function name of the interpolator. Args: name : Name of interpolator. Returns: Interpolation function with the given name.","title":"get_interpolator()"},{"location":"api/midgard-math/#interpolate","text":"Full name: midgard.math.interpolation.interpolate Signature: (x:numpy.ndarray, y:numpy.ndarray, x_new:numpy.ndarray, *, kind:str, **ipargs:Any) -> numpy.ndarray Interpolate values from one x-array to another See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. ipargs : Keyword arguments passed on to the interpolator. Returns: Array of interpolated y-values.","title":"interpolate()"},{"location":"api/midgard-math/#interpolate_with_derivative","text":"Full name: midgard.math.interpolation.interpolate_with_derivative Signature: (x:numpy.ndarray, y:numpy.ndarray, x_new:numpy.ndarray, *, kind:str, dx:float=0.5, **ipargs:Any) -> numpy.ndarray Interpolate values from one x-array to another as well as find derivatives See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. dx : Values at x \u00b1 dx are used to determine derivative. ipargs : Keyword arguments passed on to the interpolator. Returns: Tuple with array of interpolated y-values and array of derivatives.","title":"interpolate_with_derivative()"},{"location":"api/midgard-math/#interpolated_univariate_spline","text":"Full name: midgard.math.interpolation.interpolated_univariate_spline Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable One-dimensional interpolating spline for the given points Uses the scipy.interpolate.InterpolatedUnivariateSpline function behind the scenes. The original only deals with one-dimensional y arrays, so multiple calls are made for higher dimensional y arrays. The dimensions are handled independently of each other. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Interpolating spline function","title":"interpolated_univariate_spline()"},{"location":"api/midgard-math/#interpolators","text":"Full name: midgard.math.interpolation.interpolators Signature: () -> List[str] Return a list of available interpolators Returns: Names of available interpolators.","title":"interpolators()"},{"location":"api/midgard-math/#lagrange","text":"Full name: midgard.math.interpolation.lagrange Signature: (x:numpy.ndarray, y:numpy.ndarray, *, window:int=10, bounds_error:bool=True, assume_sorted:bool=False) -> Callable Computes the lagrange polynomial passing through a certain set of points See https://en.wikipedia.org/wiki/Lagrange_polynomial Uses window of the original points to calculate the Lagrange polynomials. The window of points is chosen by finding the closest original point and essentially picking the window // 2 indices on either side. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. window : Number of points used in interpolation. bounds_error : If True, a ValueError is raised if extrapolation is attempted. assume_sorted : If True, x must be an array of monotonically increasing values. Returns: Lagrange interpolation function.","title":"lagrange()"},{"location":"api/midgard-math/#linear","text":"Full name: midgard.math.interpolation.linear Signature: (x:numpy.ndarray, y:numpy.ndarray, **ipargs:Any) -> Callable Linear interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='linear' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Linear interpolation function","title":"linear()"},{"location":"api/midgard-math/#register_interpolator","text":"Full name: midgard.math.interpolation.register_interpolator Signature: (func:Callable) -> Callable Register an interpolation function This function should be used as a @register_interpolator-decorator Args: func : Function that will be registered as an interpolator. Returns: Same function.","title":"register_interpolator()"},{"location":"api/midgard-math/#midgardmathrotation","text":"Library for basic rotation matrices Description: Creates rotation matrices for rotation around the axes of a right handed Cartesian coordinate system and their derivatives. For instance, for an XYZ-system, R1 returns a rotation matrix around the x-axis and for an ENU-system, R1 returns a rotation matrix around the east-axis. dR1 returns the derivative of the R1 matrix with respect to the rotation angle. All functions are vectorized, so that one rotation matrix is returned per input angle. Example: from where.lib import rotation rotation.R1([0, 1]) array([[[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , -0. , 1. ]], [[ 1. , 0. , 0. ], [ 0. , 0.54030231, 0.84147098], [ 0. , -0.84147098, 0.54030231]]])","title":"midgard.math.rotation"},{"location":"api/midgard-math/#r1","text":"Full name: midgard.math.rotation.R1 Signature: (angle:~np_float) -> numpy.ndarray Rotation matrix around the first axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"R1()"},{"location":"api/midgard-math/#r2","text":"Full name: midgard.math.rotation.R2 Signature: (angle:~np_float) -> numpy.ndarray Rotation matrix around the second axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"R2()"},{"location":"api/midgard-math/#r3","text":"Full name: midgard.math.rotation.R3 Signature: (angle:~np_float) -> numpy.ndarray Rotation matrix around the third axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"R3()"},{"location":"api/midgard-math/#dr1","text":"Full name: midgard.math.rotation.dR1 Signature: (angle:~np_float) -> numpy.ndarray Derivative of a rotation matrix around the first axis with respect to the rotation angle. Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"dR1()"},{"location":"api/midgard-math/#dr2","text":"Full name: midgard.math.rotation.dR2 Signature: (angle:~np_float) -> numpy.ndarray Derivative of a rotation matrix around the second axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"dR2()"},{"location":"api/midgard-math/#dr3","text":"Full name: midgard.math.rotation.dR3 Signature: (angle:~np_float) -> numpy.ndarray Derivative of a rotation matrix around the third axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"dR3()"},{"location":"api/midgard-math/#enu2trs","text":"Full name: midgard.math.rotation.enu2trs Signature: (lat:~np_float, lon:~np_float) -> numpy.ndarray Rotation matrix for rotating an ENU coordinate system to an earth oriented one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R3(-(np.pi/2 + lon)) @ R1(-(np.pi/2 - lat)) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"enu2trs()"},{"location":"api/midgard-math/#trs2enu","text":"Full name: midgard.math.rotation.trs2enu Signature: (lat:~np_float, lon:~np_float) -> numpy.ndarray Rotation matrix for rotating an earth oriented coordinate system to an ENU one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R1(np.pi/2 - lat) @ R3(np.pi/2 + lon) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"trs2enu()"},{"location":"api/midgard-math/#midgardmathtransformation","text":"Midgard library module for handling of geodetic conversions Description:","title":"midgard.math.transformation"},{"location":"api/midgard-math/#delta_enu2trs","text":"Full name: midgard.math.transformation.delta_enu2trs Signature: (enu:'EnuPositionDelta') -> 'TrsPositionDelta' Convert position deltas from ENU to TRS","title":"delta_enu2trs()"},{"location":"api/midgard-math/#delta_enu2trs_posvel","text":"Full name: midgard.math.transformation.delta_enu2trs_posvel Signature: (enu:'EnuPosVelDelta') -> 'TrsPosVelDelta' Convert position deltas from ENU to TRS","title":"delta_enu2trs_posvel()"},{"location":"api/midgard-math/#delta_trs2enu","text":"Full name: midgard.math.transformation.delta_trs2enu Signature: (trs:'TrsPositionDelta') -> 'EnuPositionDelta' Convert position deltas from TRS to ENU","title":"delta_trs2enu()"},{"location":"api/midgard-math/#delta_trs2enu_posvel","text":"Full name: midgard.math.transformation.delta_trs2enu_posvel Signature: (trs:'TrsPosVelDelta') -> 'EnuPosVelDelta' Convert position deltas from TRS to ENU","title":"delta_trs2enu_posvel()"},{"location":"api/midgard-math/#llh2trs","text":"Full name: midgard.math.transformation.llh2trs Signature: (llh:numpy.ndarray, ellipsoid:midgard.math.ellipsoid.Ellipsoid=None) -> numpy.ndarray Convert geodetic latitude-, longitude-, height-coordinates to geocentric xyz-coordinates Reimplementation of GD2GCE.for from the IUA SOFA software collection.","title":"llh2trs()"},{"location":"api/midgard-math/#trs2llh","text":"Full name: midgard.math.transformation.trs2llh Signature: (trs:numpy.ndarray, ellipsoid:midgard.math.ellipsoid.Ellipsoid=None) -> numpy.ndarray Convert geocentric xyz-coordinates to geodetic latitude-, longitude-, height-coordinates Reimplementation of GC2GDE.for from the IUA SOFA software collection.","title":"trs2llh()"},{"location":"api/midgard-math/#midgardmathunit","text":"Midgard library module for handling of SI-unit conversions Description: This module provides unit conversion constants and functions. The heavy lifting is done by the pint package. The basic usage is as follows: >>> from midgard.math.unit import Unit >>> seconds_in_two_weeks = 2 * Unit.week2secs >>> seconds_in_two_weeks 1209600.0 In general Unit.spam2ham will give the multiplicative conversion scale between the units spam and ham . Through the pint package we support a lot of units. See Unit.list() or https://github.com/hgrecco/pint/blob/master/pint/default_en.txt . Another notation is also available, and might be necessary for some more complicated conversions: >>> seconds_in_two_weeks = 2 * Unit('week', 'seconds') >>> miles_per_hour_in_meters_per_second = Unit('mph', 'meters / sec') Do note that we support most normal aliases as well as singular and plural forms of the units. For instance can second be represented as s , sec , secs and seconds . Prefixes are also handled: >>> nanoseconds_in_an_hour = Unit.hour2nanosecs >>> inches_in_a_kilometer = Unit.km2inches For more complicated conversions (for instance from Celsius to Fahrenheit) one can create custom conversion functions using convert : >>> c2f = Unit.function('celsius', 'fahrenheit') >>> absolute_zero_in_fahrenheit = c2f(-273.15) For convenience, this can also be written using the attribute notation as Unit.spam_to_ham(spam_value) . Then the previous example simply becomes: >>> absolute_zero_in_fahrenheit = Unit.celsius_to_fahrenheit(-273.15) (or even easier Unit.kelvin_to_fahrenheit(0) ). Finally, we can access the unit/quantity system of pint by using the name of a unit by itself, e.g. Unit.spam . For instance: >>> distance = 42 * Unit.km >>> time = 31 * Unit('minutes') >>> speed = distance / time >>> speed.to(Unit.mph) <Quantity(50.511464659292955, 'mph')> >>> speed.to_base_units() <Quantity(22.580645161290324, 'meter / second')> However, using the full unit system adds some overhead so we should be careful in using it in heavy calculations. Note that pint has a system for defining new units and constants if necessary, http://pint.readthedocs.io/en/latest/defining.html . To use this system, add units to the unit.txt file in the current (midgard/math) directory.","title":"midgard.math.unit"},{"location":"api/midgard-math/#unit","text":"Full name: midgard.math.unit.Unit Signature: (from_unit:str, to_unit:Union[str, NoneType]=None) -> Any Unit converter The implementation of the unit conversion is done in the _convert_units -metaclass.","title":"Unit"},{"location":"api/midgard-math/#fid-textiowrapper","text":"fid = <_io.TextIOWrapper name='/home/kirann/anaconda3/lib/python3.6/site-packages/midgard/math/unit.txt' mode='r' encoding='utf-8'>","title":"fid (TextIOWrapper)"},{"location":"api/midgard-parsers/","text":"midgard.parsers Framework for parsers Description: To add a new parser, simply create a new .py-file which defines a class inheriting from parsers.Parser. The class needs to be decorated with the midgard.dev.plugins.register decorator as follows: from midgard.parsers import parser from midgard.lib import plugins @plugins.register class MyNewParser(parser.Parser): ... To use a parser, you will typically use the parse_file -function defined below from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() The name used in parse_file to call the parser is the name of the module (file) containing the parser. names () Full name: midgard.parsers.names Signature: () -> List[str] List the names of the available parsers Returns: Names of the available parsers parse_file () Full name: midgard.parsers.parse_file Signature: (parser_name:str, file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, timer_logger:Union[Callable[[str], NoneType], NoneType]=None, use_cache:bool=False, **parser_args:Any) -> midgard.parsers._parser.Parser Use the given parser on a file and return parsed data Specify parser_name and file_path to the file that should be parsed. The following parsers are available: {doc_parser_names} Data can be retrieved either as Dictionaries, Pandas DataFrames or Midgard Datasets by using one of the methods as_dict , as_dataframe or as_dataset . Example: >>> df = parse_file('rinex2_obs', 'ande3160.16o').as_dataframe() # doctest: +SKIP Args: parser_name : Name of parser file_path : Path to file that should be parsed. encoding : Encoding in file that is parsed. timer_logger : Logging function that will be used to log timing information. use_cache : Whether to use a cache to avoid parsing the same file several times. parser_args : Input arguments to the parser Returns: Parser : Parser with the parsed data midgard.parsers._parser Basic functionality for parsing datafiles, extended by individual parsers Description: This module contains functions and classes for parsing datafiles. It should typically be used by calling parsers.parse_file : Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() Parser Full name: midgard.parsers._parser.Parser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file. You should inherit from one of the specific parsers like for instance ChainParser, LineParser, SinexParser etc Attributes: file_path (Path): Path to the datafile that will be read. file_encoding (String): Encoding of the datafile. parser_name (String): Name of the parser (as needed to call parsers.parse_...). data_available (Boolean): Indicator of whether data are available. data (Dict): The (observation) data read from file. meta (Dict): Metainformation read from file. midgard.parsers._parser_chain Basic functionality for parsing datafiles line by line Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() ChainParser Full name: midgard.parsers._parser_chain.ChainParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file with chained groups of information. You should inherit from this one, and at least specify the necessary parameters in setup_parser . ParserDef Full name: midgard.parsers._parser_chain.ParserDef Signature: (end_marker:Callable[[str, int, str], bool], label:Callable[[str, int], Any], parser_def:Dict[Any, Dict[str, Any]], skip_line:Union[Callable[[str], bool], NoneType]=None, end_callback:Union[Callable[[Dict[str, Any]], NoneType], NoneType]=None) A convenience class for defining the necessary fields of a parser A single parser can read and parse one group of datalines, defined through the ParserDef by specifying how to parse each line (parser_def), how to identify each line (label), how to recognize the end of the group of lines (end_marker) and finally what (if anything) should be done after all lines in a group is read (end_callback). The end_marker, label, skip_line and end_callback parameters should all be functions with the following signatures: end_marker = func(line, line_num, next_line) label = func(line, line_num) skip_line = func(line) end_callback = func(cache) The parser definition parser_def includes the parser , field , strip and delimiter entries. The parser entry points to the parser function and the field entry defines how to separate the line in fields. The separated fields are saved either in a dictionary or in a list. In the last case the line is split on whitespace by default. With the delimiter entry the default definition can be overwritten. Leading and trailing whitespace characters are removed by default before a line is parsed. This default can be overwritten by defining the characters, which should be removed with the 'strip' entry. The parser dictionary is defined like: parser_def = { <label>: {'fields': <dict or list of fields>, 'parser': <parser function>, 'delimiter': <optional delimiter for splitting line>, 'strip': <optional characters to be removed from beginning and end of line> }} Args: end_marker : A function returning True for the last line in a group. label : A function returning a label used in the parser_def. parser_def : A dict with 'parser' and 'fields' defining the parser. skip_line : A function returning True if the line should be skipped. end_callback : A function called after reading all lines in a group. midgard.parsers._parser_line Basic functionality for parsing datafiles line by line using Numpy Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() LineParser Full name: midgard.parsers._parser_line.LineParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for using numpy to parse a file line by line. You should inherit from this one, and at least specify the necessary parameters in setup_parser . midgard.parsers._parser_rinex Basic functionality for parsing Rinex files Description: This module contains functions and classes for parsing Rinex files. This file defines the general structure shared by most types of Rinex files, including header information. More specific format details are implemented in subclasses. When calling the parser, you should call the apropriate parser for a given Rinex format. RinexHeader Full name: midgard.parsers._parser_rinex.RinexHeader Signature: (marker:str, fields:Dict[str, Tuple[int, int]], parser:Callable[[Dict[str, str]], Dict[str, Any]]) A convenience class for defining how a Rinex header is parsed Args: marker : Marker of header (as defined in columns 60 and onward). fields : Dictionary with field names as keys, tuple of start- and end-columns as value. parser : Function that will parse the fields. RinexParser Full name: midgard.parsers._parser_rinex.RinexParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for reading Rinex header data. You should inherit from this one, and at least implement parse_epochs . parser_cache () Full name: midgard.parsers._parser_rinex.parser_cache Signature: (func:Callable[[_ForwardRef('RinexParser'), Dict[str, str], List[Dict[str, str]]], Dict[str, Any]]) -> Callable[[_ForwardRef('RinexParser'), Dict[str, str]], Dict[str, Any]] Decorator for adding a cache to parser functions midgard.parsers._parser_sinex Basic functionality for parsing Sinex datafiles Description: This module contains functions and classes for parsing Sinex datafiles. References: SINEX Format: https://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html SinexBlock Full name: midgard.parsers._parser_sinex.SinexBlock Signature: (marker:str, fields:Tuple[midgard.parsers._parser_sinex.SinexField, ...], parser:Callable[[<built-in function array>, Tuple[str, ...]], Dict[str, Any]]) A convenience class for defining a Sinex block Args: marker : Sinex marker denoting the block. fields : Fields in Sinex block. parser : Function used to parse the data. SinexField Full name: midgard.parsers._parser_sinex.SinexField Signature: (name:str, start_col:int, dtype:Union[str, NoneType], converter:Union[str, NoneType]=None) A convenience class for defining the fields in a Sinex block Args: name : Name of field. start_col : Starting column of field (First column is 0) dtype : String, using numpy notation, defining type of field, use None to ignore field. converter : Optional, name of converter to apply to field data. SinexParser Full name: midgard.parsers._parser_sinex.SinexParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, header:bool=True) -> None An abstract base class that has basic methods for parsing a Sinex file This class provides functionality for parsing a sinex file with chained groups of information. You should inherit from this one, and at least specify which Sinex blocks you are interested in by implementing setup_parser , as well as implement methods that parse each block if needed. parsing_factory () Full name: midgard.parsers._parser_sinex.parsing_factory Signature: () -> Callable[..., Dict[str, Any]] Create a default parsing function for a Sinex block The default parsing function returns a dictionary containing all fields of the block as separated arrays. This will be stored in self.data['{marker}'] with the {marker} of the current block. Returns: Simple parsing function for one Sinex block. parsing_matrix_factory () Full name: midgard.parsers._parser_sinex.parsing_matrix_factory Signature: (marker:str, size_marker:str) -> Callable[..., Dict[str, Any]] Create a parsing function for parsing a matrix within a Sinex block The default parsing function converts data to a symmetric matrix and stores it inside self.data[marker] . The size of the matrix is set to equal the number of parameters in the size_marker -block. If that block is not parsed/found. The size is set to the last given row index. If some zero elements in the matrix are omitted this might be wrong. Args: marker : Marker of Sinex block. size_marker : Marker of a different Sinex block indicating the size of the matrix. Returns: Simple parsing function for one Sinex block. midgard.parsers.anubis A parser for reading Anubis xtr-files AnubisXtrParser Full name: midgard.parsers.anubis.AnubisXtrParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Anubis XTR files midgard.parsers.bcecmp_sisre A parser for reading DLR BCEcmp Software SISRE output files Example: from midgard import parsers p = parsers.parse_file(parser_name='bcecmp_sisre', file_path='BCEcmp_GAL_FNAV_E1E5A_com_2018_032.OUT') data = p.as_dict() Description: Reads data from files in the BCEcmp Software output file format. The BCEcmp Software is developed and used by DLR. BcecmpParser Full name: midgard.parsers.bcecmp_sisre.BcecmpParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading DLR BCEcmp Software output files. The following data are available after reading BCEcmp Software output file: Key Description age_min age of ephemeris in [min] clk_diff_sys Satellite clock correction difference in [m] dalong_track Along-track orbit difference in [m] dcross_track Cross-track orbit difference in [m] dradial Radial orbit difference in [m] dradial_wul Worst-user-location (wul) SISRE? satellite Satellite PRN number together with GNSS identifier (e.g. G07) sisre Signal-in-space range error [m] time Observation time used_iodc GPS: IODC (Clock issue of data indicates changes (set equal to IODE)) QZSS: IODC used_iode Ephemeris issue of data indicates changes to the broadcast ephemeris: - GPS: Ephemeris issue of data (IODE), which is set equal to IODC - Galileo: Issue of Data of the NAV batch (IODnav) - QZSS: Ephemeris issue of data (IODE) - BeiDou: Age of Data Ephemeris (AODE) - IRNSS: Issue of Data, Ephemeris and Clock (IODEC) and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.discontinuities_snx A parser for reading data from discontinuities.snx in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='discontinuities_snx', file_path='discontinuties.snx') data = p.as_dict() Description: Reads discontinuities of GNSS station timeseries in SINEX format . DiscontinuitiesSnxParser Full name: midgard.parsers.discontinuities_snx.DiscontinuitiesSnxParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, header:bool=True) -> None A parser for reading data from discontinuties.snx file in SINEX format The solution discontinuity dictionary has as keys the site identifiers and as value the 'solution_discontinuity' entry. The dictionary has following strucuture: self.data[site] = { 'solution_discontinuity': [] } # SOLUTION/DISCONTINUITY SINEX block information with the 'solution_discontinuity' dictionary entries solution_discontinuity[ii] = [ 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'event_code': event_code, 'description': description ] The counter 'ii' ranges from 0 to n and depends on how many discontinuities exists for a site. Note also, that time entries (e.g. start_time, end_time) are given as 'datetime'. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class. midgard.parsers.galileo_constellation_html A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example GalileoConstellationHTMLParser Full name: midgard.parsers.galileo_constellation_html.GalileoConstellationHTMLParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, url:Union[str, NoneType]=None) -> None A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example midgard.parsers.gipsy_tdp A parser for reading NASA JPL Gipsy time dependent parameter (TDP) file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsy_tdp', file_path='final.tdp') data = p.as_dict() Description: Reads data from files in Gipsy time dependent parameter (TDP) format. GipsyTdpParser Full name: midgard.parsers.gipsy_tdp.GipsyTdpParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Gipsy time dependent parameter (TDP) file Following data are available after reading Gipsy TDP output file: Key Description apriori_value Nominal value. This field contains the last value used by the model. name Parameter name. sigma The sigma associated with the value of the parameter. A negative value indicates it should be used for interpolation by the file reader read_time_variation in $GOA/libsrc/time_variation. If no sigmas are computed by the smapper, a 1.0 will be placed here. time_past_j2000 Time given in GPS seconds past J2000. value Accumulated value of the parameter at time and includes any nominal, or iterative correction. This is the only entry used by the model. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gnss_antex A parser for reading ANTEX format 1.4 data Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_antex', file_path='igs14.atx') data = p.as_dict() Description: Reads data from files in the GNSS Antenna Exchange (ANTEX) file format version 1.4 (see :cite: antex ). AntexParser Full name: midgard.parsers.gnss_antex.AntexParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading ANTEX file The parser reads GNSS ANTEX format 1.4 (see :cite: antex ). The 'data' attribute is a dictionary with GNSS satellite PRN or receiver antenna as key. The GNSS satellite antenna corrections are time dependent and saved with \"valid from\" datetime object entry. The dictionary looks like: dout = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}} with following entries: Value Type Description azi numpy.ndarray Array with azimuth-elevation dependent antenna correction in [mm] with the shape: number of azimuth values x number of elevation values. azimuth numpy.ndarray List with azimuth values in [rad] corresponding to antenna corrections given in azi . cospar_id str COSPAR ID : yyyy -> year when the satellite was put in orbit, xxx -> sequential satellite number for that year, a -> alpha numeric sequence number within a launch elevation numpy.ndarray List with elevation values in [rad] corresponding to antenna corrections given in azi or noazi . str Frequency identifier (e.g. G01 - GPS L1) neu list North, East and Up eccentricities in [m]. The eccentricities of the mean antenna phase center is given relative to the antenna reference point (ARP) for receiver antennas or to the center of mass of the satellite in X-, Y- and Z-direction. noazi numpy.ndarray List with elevation dependent (non-azimuth-dependent) antenna correction in [mm]. str Satellite code e.g. GPS PRN, GLONASS slot or Galileo SVID number str Receiver antenna name together with radome code sat_code str Satellite code e.g. GPS SVN, GLONASS number or Galileo GSAT number sat_type str Satellite type (e.g. BLOCK IIA) valid_from datetime.datetime Start of validity period of satellite in GPS time valid_until datetime.datetime End of validity period of satellite in GPS time The 'meta' attribute is a dictionary with following entries: Value Type Description comment list Header commments given in list line by line pcv_type str Phase center variation type ref_antenna str Reference antenna type for relative antenna ref_serial_num str Serial number of the reference antenna sat_sys str Satellite system version str Format version Attributes: data : (dict), Contains the (observation) data read from file. data_available : (bool), Indicator of whether data are available. file_path : (pathlib.Path), File path. parser_name : (str), Parser name. meta : (dict), Contains metainformation read from file. midgard.parsers.gnss_sinex_igs A parser for reading data from igs.snx file based on IGS sitelog files in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_sinex_igs', file_path='igs.snx') data = p.as_dict() Description: Reads station information (e.g. approximated station coordinates, receiver and antenna type, station eccentricities, ...) igs.snx file in SINEX format. IgsSnxParser Full name: midgard.parsers.gnss_sinex_igs.IgsSnxParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, header:bool=True) -> None A parser for reading data from igs.snx file based on IGS sitelog files in SINEX format site - Site dictionary, whereby keys are the site identifiers and values are a site entry dictionary with the keys 'site_antenna', 'site_eccentricity', 'site_id' and 'site_receiver'. The site dictionary has following strucuture: self.site[site] = { 'site_antenna': [], # SITE/ANTENNA SINEX block information 'site_eccentricity': [], # SITE/ECCENTRICITY block information 'site_id': {}, # SITE/ID block information 'site_receiver': [], # SITE/RECEIVER block information } with the site entry dictionary entries site_antenna[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'antenna_type': antenna_type, 'radome_type': radome_type, 'serial_number': serial_number } site_eccentricity[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'reference_system': reference_system, 'vector_1': vector_1, 'vector_2': vector_2, 'vector_3': vector_3, 'vector_type': UNE } site_id = { 'point_code': point_code, 'domes': domes, 'marker': marker, 'obs_code': obs_code, 'description': description, 'approx_lon': approx_lon, 'approx_lat': approx_lat, 'approx_height': approx_height } site_receiver[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'receiver_type': receiver_type, 'serial_number': serial_number, 'firmware': firmware } The counter 'ii' ranges from 0 to n and depends on how many antenna type, receiver type and antenna monument changes were done at each site. Note also, that time entries (e.g. start_time, end_time) are given in Modified Julian Date. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class. midgard.parsers.rinex2_nav_header RINEX navigation header classes for file format version 2.xx Rinex2NavHeaderMixin Full name: midgard.parsers.rinex2_nav_header.Rinex2NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 2.xx Rinex2NavHeaderParser Full name: midgard.parsers.rinex2_nav_header.Rinex2NavHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 2.xx navigation header The data in the rinex file will not be parsed. midgard.parsers.rinex2_obs_header RINEX observation header classes for file format version 3.xx Rinex2ObsHeaderMixin Full name: midgard.parsers.rinex2_obs_header.Rinex2ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 2.xx Rinex2ObsHeaderParser Full name: midgard.parsers.rinex2_obs_header.Rinex2ObsHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 2.xx observation header The data in the rinex file will not be parsed. midgard.parsers.rinex3_clk A parser for reading RINEX clock files with version 3.xx Rinex3ClkParser Full name: midgard.parsers.rinex3_clk.Rinex3ClkParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX clock files with version 3.xx midgard.parsers.rinex3_clk_header RINEX clock header classes for file format version 3.xx Rinex3ClkHeaderMixin Full name: midgard.parsers.rinex3_clk_header.Rinex3ClkHeaderMixin Signature: () A mixin defining which RINEX clock headers are mandatory and optional in RINEX version 3.xx Rinex3ClkHeaderParser Full name: midgard.parsers.rinex3_clk_header.Rinex3ClkHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 3.xx clock header The data in the rinex file will not be parsed. midgard.parsers.rinex3_nav_header RINEX navigation header classes for file format version 3.xx Rinex3NavHeaderMixin Full name: midgard.parsers.rinex3_nav_header.Rinex3NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 3.xx Rinex3NavHeaderParser Full name: midgard.parsers.rinex3_nav_header.Rinex3NavHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 3.xx navigation header The data in the rinex file will not be parsed. midgard.parsers.rinex3_obs_header RINEX observation header classes for file format version 3.xx Rinex3ObsHeaderMixin Full name: midgard.parsers.rinex3_obs_header.Rinex3ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 3.xx Rinex3ObsHeaderParser Full name: midgard.parsers.rinex3_obs_header.Rinex3ObsHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 3.xx observation header The data in the rinex file will not be parsed. midgard.parsers.terrapos_position A parser for reading Terrapos position output file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_position', file_path='Gal_C1X_brdc_land_30sec_24hrs_FNAV-file.txt') data = p.as_dict() Description: Reads data from files in Terrapos position output format. TerraposPositionParser Full name: midgard.parsers.terrapos_position.TerraposPositionParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Terrapos position output file Following data are available after reading Terrapos position file: Key Description gpsweek GPS week gpssec Seconds of GPS week head Head in [deg] height Ellipsoidal height in [m] lat Latitude in [deg] lon Longitude in [deg] num_sat Number of satellites pdop Position Dilution of Precision (PDOP) pitch Pitch in [deg] reliability_east East position external reliability in [m] #TODO: Is that correct? reliability_height Height position external reliability in [m] #TODO: Is that correct? reliability_north North position external reliability in [m] #TODO: Is that correct? roll Roll in [deg] sigma_east Standard deviation of East position in [m] #TODO: Is that correct? sigma_height Standard deviation of Height position in [m] #TODO: Is that correct? sigma_north Standard deviation of North position in [m] #TODO: Is that correct? and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.terrapos_residual A parser for reading Terrapos residual file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_residual', file_path='PPP-residuals.txt') data = p.as_dict() Description: Reads data from files in Terrapos residual format. TerraposResidualParser Full name: midgard.parsers.terrapos_residual.TerraposResidualParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Terrapos residual file Following data are available after reading Terrapos residual file: Parameter Description azimuth Azimuth of satellites in [deg] elevation Elevation of satellites in [deg] gpsweek GPS week gpssec Seconds of GPS week residual_code Code (pseudorange) residuals in [m] residual_doppler Doppler residuals in [m] residual_phase Carrier-phase residuals in [m] satellite Satellite PRN number together with GNSS identifier (e.g. G07) system GNSS identifier and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.timeseries_env A parser for reading timeseries files in ENV format Example: from midgard import parsers p = parsers.parse_file(parser_name='timeseries_env', file_path='stas.env') data = p.as_dict() Description: Reads data from files timeseries files in ENV (east, north, vertical) format TimeseriesEnvParser Full name: midgard.parsers.timeseries_env.TimeseriesEnvParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading timeseries files in ENV format Following data are available after reading timeseries ENV file: Key Description date Date in format yyMMMdd (e.g. 18MAY10). year Date in unit year. east East coordinate in [mm]. east_sigma Standard devication of east coordinate in [mm]. north North coordinate in [mm]. north_sigma Standard devication of north coordinate in [mm]. vertical Vertical coordinate in [mm]. vertical_sigma Standard devication of vertical coordinate in [mm]. and meta -data: Key Description __data_path__ File path __params__ np.genfromtxt parameters __parser_name__ Parser name midgard.parsers.vlbi_source_names A parser for reading IVS source names translation table VlbiSourceNamesParser Full name: midgard.parsers.vlbi_source_names.VlbiSourceNamesParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file midgard.parsers.wip_rinex A parser for reading Rinex files rinex () Full name: midgard.parsers.wip_rinex.rinex Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on Rinex file type midgard.parsers.wip_rinex2_nav A parser for reading RINEX navigation files with version 2.xx Rinex2NavParser Full name: midgard.parsers.wip_rinex2_nav.Rinex2NavParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX navigation files with version 2.xx midgard.parsers.wip_rinex2_obs A parser for reading RINEX observation files with version 2.xx Rinex2ObsParser Full name: midgard.parsers.wip_rinex2_obs.Rinex2ObsParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX observation files with version 2.xx midgard.parsers.wip_rinex3_nav A parser for reading RINEX navigation files with version 3.xx Rinex3NavParser Full name: midgard.parsers.wip_rinex3_nav.Rinex3NavParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX navigation files with version 3.xx midgard.parsers.wip_rinex3_obs A parser for reading RINEX observation files with version 3.xx Rinex3ObsParser Full name: midgard.parsers.wip_rinex3_obs.Rinex3ObsParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX observation files with version 3.xx midgard.parsers.wip_rinex_clk A parser for reading Rinex navigation files RinexClkParser Full name: midgard.parsers.wip_rinex_clk.RinexClkParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None Class for defining common methods for RINEX clock parsers. rinex_clk () Full name: midgard.parsers.wip_rinex_clk.rinex_clk Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file midgard.parsers.wip_rinex_nav A parser for reading Rinex navigation files RinexNavParser Full name: midgard.parsers.wip_rinex_nav.RinexNavParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None Class for defining common methods for RINEX navigation parsers. rinex_nav () Full name: midgard.parsers.wip_rinex_nav.rinex_nav Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file midgard.parsers.wip_rinex_obs A parser for reading Rinex observation files RinexObsParser Full name: midgard.parsers.wip_rinex_obs.RinexObsParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None Class for defining common methods for RINEX observation parsers. rinex_obs () Full name: midgard.parsers.wip_rinex_obs.rinex_obs Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"midgard.parsers"},{"location":"api/midgard-parsers/#midgardparsers","text":"Framework for parsers Description: To add a new parser, simply create a new .py-file which defines a class inheriting from parsers.Parser. The class needs to be decorated with the midgard.dev.plugins.register decorator as follows: from midgard.parsers import parser from midgard.lib import plugins @plugins.register class MyNewParser(parser.Parser): ... To use a parser, you will typically use the parse_file -function defined below from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() The name used in parse_file to call the parser is the name of the module (file) containing the parser.","title":"midgard.parsers"},{"location":"api/midgard-parsers/#names","text":"Full name: midgard.parsers.names Signature: () -> List[str] List the names of the available parsers Returns: Names of the available parsers","title":"names()"},{"location":"api/midgard-parsers/#parse_file","text":"Full name: midgard.parsers.parse_file Signature: (parser_name:str, file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, timer_logger:Union[Callable[[str], NoneType], NoneType]=None, use_cache:bool=False, **parser_args:Any) -> midgard.parsers._parser.Parser Use the given parser on a file and return parsed data Specify parser_name and file_path to the file that should be parsed. The following parsers are available: {doc_parser_names} Data can be retrieved either as Dictionaries, Pandas DataFrames or Midgard Datasets by using one of the methods as_dict , as_dataframe or as_dataset . Example: >>> df = parse_file('rinex2_obs', 'ande3160.16o').as_dataframe() # doctest: +SKIP Args: parser_name : Name of parser file_path : Path to file that should be parsed. encoding : Encoding in file that is parsed. timer_logger : Logging function that will be used to log timing information. use_cache : Whether to use a cache to avoid parsing the same file several times. parser_args : Input arguments to the parser Returns: Parser : Parser with the parsed data","title":"parse_file()"},{"location":"api/midgard-parsers/#midgardparsers_parser","text":"Basic functionality for parsing datafiles, extended by individual parsers Description: This module contains functions and classes for parsing datafiles. It should typically be used by calling parsers.parse_file : Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser"},{"location":"api/midgard-parsers/#parser","text":"Full name: midgard.parsers._parser.Parser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file. You should inherit from one of the specific parsers like for instance ChainParser, LineParser, SinexParser etc Attributes: file_path (Path): Path to the datafile that will be read. file_encoding (String): Encoding of the datafile. parser_name (String): Name of the parser (as needed to call parsers.parse_...). data_available (Boolean): Indicator of whether data are available. data (Dict): The (observation) data read from file. meta (Dict): Metainformation read from file.","title":"Parser"},{"location":"api/midgard-parsers/#midgardparsers_parser_chain","text":"Basic functionality for parsing datafiles line by line Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser_chain"},{"location":"api/midgard-parsers/#chainparser","text":"Full name: midgard.parsers._parser_chain.ChainParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file with chained groups of information. You should inherit from this one, and at least specify the necessary parameters in setup_parser .","title":"ChainParser"},{"location":"api/midgard-parsers/#parserdef","text":"Full name: midgard.parsers._parser_chain.ParserDef Signature: (end_marker:Callable[[str, int, str], bool], label:Callable[[str, int], Any], parser_def:Dict[Any, Dict[str, Any]], skip_line:Union[Callable[[str], bool], NoneType]=None, end_callback:Union[Callable[[Dict[str, Any]], NoneType], NoneType]=None) A convenience class for defining the necessary fields of a parser A single parser can read and parse one group of datalines, defined through the ParserDef by specifying how to parse each line (parser_def), how to identify each line (label), how to recognize the end of the group of lines (end_marker) and finally what (if anything) should be done after all lines in a group is read (end_callback). The end_marker, label, skip_line and end_callback parameters should all be functions with the following signatures: end_marker = func(line, line_num, next_line) label = func(line, line_num) skip_line = func(line) end_callback = func(cache) The parser definition parser_def includes the parser , field , strip and delimiter entries. The parser entry points to the parser function and the field entry defines how to separate the line in fields. The separated fields are saved either in a dictionary or in a list. In the last case the line is split on whitespace by default. With the delimiter entry the default definition can be overwritten. Leading and trailing whitespace characters are removed by default before a line is parsed. This default can be overwritten by defining the characters, which should be removed with the 'strip' entry. The parser dictionary is defined like: parser_def = { <label>: {'fields': <dict or list of fields>, 'parser': <parser function>, 'delimiter': <optional delimiter for splitting line>, 'strip': <optional characters to be removed from beginning and end of line> }} Args: end_marker : A function returning True for the last line in a group. label : A function returning a label used in the parser_def. parser_def : A dict with 'parser' and 'fields' defining the parser. skip_line : A function returning True if the line should be skipped. end_callback : A function called after reading all lines in a group.","title":"ParserDef"},{"location":"api/midgard-parsers/#midgardparsers_parser_line","text":"Basic functionality for parsing datafiles line by line using Numpy Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser_line"},{"location":"api/midgard-parsers/#lineparser","text":"Full name: midgard.parsers._parser_line.LineParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for using numpy to parse a file line by line. You should inherit from this one, and at least specify the necessary parameters in setup_parser .","title":"LineParser"},{"location":"api/midgard-parsers/#midgardparsers_parser_rinex","text":"Basic functionality for parsing Rinex files Description: This module contains functions and classes for parsing Rinex files. This file defines the general structure shared by most types of Rinex files, including header information. More specific format details are implemented in subclasses. When calling the parser, you should call the apropriate parser for a given Rinex format.","title":"midgard.parsers._parser_rinex"},{"location":"api/midgard-parsers/#rinexheader","text":"Full name: midgard.parsers._parser_rinex.RinexHeader Signature: (marker:str, fields:Dict[str, Tuple[int, int]], parser:Callable[[Dict[str, str]], Dict[str, Any]]) A convenience class for defining how a Rinex header is parsed Args: marker : Marker of header (as defined in columns 60 and onward). fields : Dictionary with field names as keys, tuple of start- and end-columns as value. parser : Function that will parse the fields.","title":"RinexHeader"},{"location":"api/midgard-parsers/#rinexparser","text":"Full name: midgard.parsers._parser_rinex.RinexParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for reading Rinex header data. You should inherit from this one, and at least implement parse_epochs .","title":"RinexParser"},{"location":"api/midgard-parsers/#parser_cache","text":"Full name: midgard.parsers._parser_rinex.parser_cache Signature: (func:Callable[[_ForwardRef('RinexParser'), Dict[str, str], List[Dict[str, str]]], Dict[str, Any]]) -> Callable[[_ForwardRef('RinexParser'), Dict[str, str]], Dict[str, Any]] Decorator for adding a cache to parser functions","title":"parser_cache()"},{"location":"api/midgard-parsers/#midgardparsers_parser_sinex","text":"Basic functionality for parsing Sinex datafiles Description: This module contains functions and classes for parsing Sinex datafiles. References: SINEX Format: https://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html","title":"midgard.parsers._parser_sinex"},{"location":"api/midgard-parsers/#sinexblock","text":"Full name: midgard.parsers._parser_sinex.SinexBlock Signature: (marker:str, fields:Tuple[midgard.parsers._parser_sinex.SinexField, ...], parser:Callable[[<built-in function array>, Tuple[str, ...]], Dict[str, Any]]) A convenience class for defining a Sinex block Args: marker : Sinex marker denoting the block. fields : Fields in Sinex block. parser : Function used to parse the data.","title":"SinexBlock"},{"location":"api/midgard-parsers/#sinexfield","text":"Full name: midgard.parsers._parser_sinex.SinexField Signature: (name:str, start_col:int, dtype:Union[str, NoneType], converter:Union[str, NoneType]=None) A convenience class for defining the fields in a Sinex block Args: name : Name of field. start_col : Starting column of field (First column is 0) dtype : String, using numpy notation, defining type of field, use None to ignore field. converter : Optional, name of converter to apply to field data.","title":"SinexField"},{"location":"api/midgard-parsers/#sinexparser","text":"Full name: midgard.parsers._parser_sinex.SinexParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, header:bool=True) -> None An abstract base class that has basic methods for parsing a Sinex file This class provides functionality for parsing a sinex file with chained groups of information. You should inherit from this one, and at least specify which Sinex blocks you are interested in by implementing setup_parser , as well as implement methods that parse each block if needed.","title":"SinexParser"},{"location":"api/midgard-parsers/#parsing_factory","text":"Full name: midgard.parsers._parser_sinex.parsing_factory Signature: () -> Callable[..., Dict[str, Any]] Create a default parsing function for a Sinex block The default parsing function returns a dictionary containing all fields of the block as separated arrays. This will be stored in self.data['{marker}'] with the {marker} of the current block. Returns: Simple parsing function for one Sinex block.","title":"parsing_factory()"},{"location":"api/midgard-parsers/#parsing_matrix_factory","text":"Full name: midgard.parsers._parser_sinex.parsing_matrix_factory Signature: (marker:str, size_marker:str) -> Callable[..., Dict[str, Any]] Create a parsing function for parsing a matrix within a Sinex block The default parsing function converts data to a symmetric matrix and stores it inside self.data[marker] . The size of the matrix is set to equal the number of parameters in the size_marker -block. If that block is not parsed/found. The size is set to the last given row index. If some zero elements in the matrix are omitted this might be wrong. Args: marker : Marker of Sinex block. size_marker : Marker of a different Sinex block indicating the size of the matrix. Returns: Simple parsing function for one Sinex block.","title":"parsing_matrix_factory()"},{"location":"api/midgard-parsers/#midgardparsersanubis","text":"A parser for reading Anubis xtr-files","title":"midgard.parsers.anubis"},{"location":"api/midgard-parsers/#anubisxtrparser","text":"Full name: midgard.parsers.anubis.AnubisXtrParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Anubis XTR files","title":"AnubisXtrParser"},{"location":"api/midgard-parsers/#midgardparsersbcecmp_sisre","text":"A parser for reading DLR BCEcmp Software SISRE output files Example: from midgard import parsers p = parsers.parse_file(parser_name='bcecmp_sisre', file_path='BCEcmp_GAL_FNAV_E1E5A_com_2018_032.OUT') data = p.as_dict() Description: Reads data from files in the BCEcmp Software output file format. The BCEcmp Software is developed and used by DLR.","title":"midgard.parsers.bcecmp_sisre"},{"location":"api/midgard-parsers/#bcecmpparser","text":"Full name: midgard.parsers.bcecmp_sisre.BcecmpParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading DLR BCEcmp Software output files. The following data are available after reading BCEcmp Software output file: Key Description age_min age of ephemeris in [min] clk_diff_sys Satellite clock correction difference in [m] dalong_track Along-track orbit difference in [m] dcross_track Cross-track orbit difference in [m] dradial Radial orbit difference in [m] dradial_wul Worst-user-location (wul) SISRE? satellite Satellite PRN number together with GNSS identifier (e.g. G07) sisre Signal-in-space range error [m] time Observation time used_iodc GPS: IODC (Clock issue of data indicates changes (set equal to IODE)) QZSS: IODC used_iode Ephemeris issue of data indicates changes to the broadcast ephemeris: - GPS: Ephemeris issue of data (IODE), which is set equal to IODC - Galileo: Issue of Data of the NAV batch (IODnav) - QZSS: Ephemeris issue of data (IODE) - BeiDou: Age of Data Ephemeris (AODE) - IRNSS: Issue of Data, Ephemeris and Clock (IODEC) and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"BcecmpParser"},{"location":"api/midgard-parsers/#midgardparsersdiscontinuities_snx","text":"A parser for reading data from discontinuities.snx in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='discontinuities_snx', file_path='discontinuties.snx') data = p.as_dict() Description: Reads discontinuities of GNSS station timeseries in SINEX format .","title":"midgard.parsers.discontinuities_snx"},{"location":"api/midgard-parsers/#discontinuitiessnxparser","text":"Full name: midgard.parsers.discontinuities_snx.DiscontinuitiesSnxParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, header:bool=True) -> None A parser for reading data from discontinuties.snx file in SINEX format The solution discontinuity dictionary has as keys the site identifiers and as value the 'solution_discontinuity' entry. The dictionary has following strucuture: self.data[site] = { 'solution_discontinuity': [] } # SOLUTION/DISCONTINUITY SINEX block information with the 'solution_discontinuity' dictionary entries solution_discontinuity[ii] = [ 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'event_code': event_code, 'description': description ] The counter 'ii' ranges from 0 to n and depends on how many discontinuities exists for a site. Note also, that time entries (e.g. start_time, end_time) are given as 'datetime'. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class.","title":"DiscontinuitiesSnxParser"},{"location":"api/midgard-parsers/#midgardparsersgalileo_constellation_html","text":"A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example","title":"midgard.parsers.galileo_constellation_html"},{"location":"api/midgard-parsers/#galileoconstellationhtmlparser","text":"Full name: midgard.parsers.galileo_constellation_html.GalileoConstellationHTMLParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=<built-in function print>, url:Union[str, NoneType]=None) -> None A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example","title":"GalileoConstellationHTMLParser"},{"location":"api/midgard-parsers/#midgardparsersgipsy_tdp","text":"A parser for reading NASA JPL Gipsy time dependent parameter (TDP) file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsy_tdp', file_path='final.tdp') data = p.as_dict() Description: Reads data from files in Gipsy time dependent parameter (TDP) format.","title":"midgard.parsers.gipsy_tdp"},{"location":"api/midgard-parsers/#gipsytdpparser","text":"Full name: midgard.parsers.gipsy_tdp.GipsyTdpParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Gipsy time dependent parameter (TDP) file Following data are available after reading Gipsy TDP output file: Key Description apriori_value Nominal value. This field contains the last value used by the model. name Parameter name. sigma The sigma associated with the value of the parameter. A negative value indicates it should be used for interpolation by the file reader read_time_variation in $GOA/libsrc/time_variation. If no sigmas are computed by the smapper, a 1.0 will be placed here. time_past_j2000 Time given in GPS seconds past J2000. value Accumulated value of the parameter at time and includes any nominal, or iterative correction. This is the only entry used by the model. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyTdpParser"},{"location":"api/midgard-parsers/#midgardparsersgnss_antex","text":"A parser for reading ANTEX format 1.4 data Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_antex', file_path='igs14.atx') data = p.as_dict() Description: Reads data from files in the GNSS Antenna Exchange (ANTEX) file format version 1.4 (see :cite: antex ).","title":"midgard.parsers.gnss_antex"},{"location":"api/midgard-parsers/#antexparser","text":"Full name: midgard.parsers.gnss_antex.AntexParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading ANTEX file The parser reads GNSS ANTEX format 1.4 (see :cite: antex ). The 'data' attribute is a dictionary with GNSS satellite PRN or receiver antenna as key. The GNSS satellite antenna corrections are time dependent and saved with \"valid from\" datetime object entry. The dictionary looks like: dout = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}} with following entries: Value Type Description azi numpy.ndarray Array with azimuth-elevation dependent antenna correction in [mm] with the shape: number of azimuth values x number of elevation values. azimuth numpy.ndarray List with azimuth values in [rad] corresponding to antenna corrections given in azi . cospar_id str COSPAR ID : yyyy -> year when the satellite was put in orbit, xxx -> sequential satellite number for that year, a -> alpha numeric sequence number within a launch elevation numpy.ndarray List with elevation values in [rad] corresponding to antenna corrections given in azi or noazi . str Frequency identifier (e.g. G01 - GPS L1) neu list North, East and Up eccentricities in [m]. The eccentricities of the mean antenna phase center is given relative to the antenna reference point (ARP) for receiver antennas or to the center of mass of the satellite in X-, Y- and Z-direction. noazi numpy.ndarray List with elevation dependent (non-azimuth-dependent) antenna correction in [mm]. str Satellite code e.g. GPS PRN, GLONASS slot or Galileo SVID number str Receiver antenna name together with radome code sat_code str Satellite code e.g. GPS SVN, GLONASS number or Galileo GSAT number sat_type str Satellite type (e.g. BLOCK IIA) valid_from datetime.datetime Start of validity period of satellite in GPS time valid_until datetime.datetime End of validity period of satellite in GPS time The 'meta' attribute is a dictionary with following entries: Value Type Description comment list Header commments given in list line by line pcv_type str Phase center variation type ref_antenna str Reference antenna type for relative antenna ref_serial_num str Serial number of the reference antenna sat_sys str Satellite system version str Format version Attributes: data : (dict), Contains the (observation) data read from file. data_available : (bool), Indicator of whether data are available. file_path : (pathlib.Path), File path. parser_name : (str), Parser name. meta : (dict), Contains metainformation read from file.","title":"AntexParser"},{"location":"api/midgard-parsers/#midgardparsersgnss_sinex_igs","text":"A parser for reading data from igs.snx file based on IGS sitelog files in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_sinex_igs', file_path='igs.snx') data = p.as_dict() Description: Reads station information (e.g. approximated station coordinates, receiver and antenna type, station eccentricities, ...) igs.snx file in SINEX format.","title":"midgard.parsers.gnss_sinex_igs"},{"location":"api/midgard-parsers/#igssnxparser","text":"Full name: midgard.parsers.gnss_sinex_igs.IgsSnxParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, header:bool=True) -> None A parser for reading data from igs.snx file based on IGS sitelog files in SINEX format site - Site dictionary, whereby keys are the site identifiers and values are a site entry dictionary with the keys 'site_antenna', 'site_eccentricity', 'site_id' and 'site_receiver'. The site dictionary has following strucuture: self.site[site] = { 'site_antenna': [], # SITE/ANTENNA SINEX block information 'site_eccentricity': [], # SITE/ECCENTRICITY block information 'site_id': {}, # SITE/ID block information 'site_receiver': [], # SITE/RECEIVER block information } with the site entry dictionary entries site_antenna[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'antenna_type': antenna_type, 'radome_type': radome_type, 'serial_number': serial_number } site_eccentricity[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'reference_system': reference_system, 'vector_1': vector_1, 'vector_2': vector_2, 'vector_3': vector_3, 'vector_type': UNE } site_id = { 'point_code': point_code, 'domes': domes, 'marker': marker, 'obs_code': obs_code, 'description': description, 'approx_lon': approx_lon, 'approx_lat': approx_lat, 'approx_height': approx_height } site_receiver[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'receiver_type': receiver_type, 'serial_number': serial_number, 'firmware': firmware } The counter 'ii' ranges from 0 to n and depends on how many antenna type, receiver type and antenna monument changes were done at each site. Note also, that time entries (e.g. start_time, end_time) are given in Modified Julian Date. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class.","title":"IgsSnxParser"},{"location":"api/midgard-parsers/#midgardparsersrinex2_nav_header","text":"RINEX navigation header classes for file format version 2.xx","title":"midgard.parsers.rinex2_nav_header"},{"location":"api/midgard-parsers/#rinex2navheadermixin","text":"Full name: midgard.parsers.rinex2_nav_header.Rinex2NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 2.xx","title":"Rinex2NavHeaderMixin"},{"location":"api/midgard-parsers/#rinex2navheaderparser","text":"Full name: midgard.parsers.rinex2_nav_header.Rinex2NavHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 2.xx navigation header The data in the rinex file will not be parsed.","title":"Rinex2NavHeaderParser"},{"location":"api/midgard-parsers/#midgardparsersrinex2_obs_header","text":"RINEX observation header classes for file format version 3.xx","title":"midgard.parsers.rinex2_obs_header"},{"location":"api/midgard-parsers/#rinex2obsheadermixin","text":"Full name: midgard.parsers.rinex2_obs_header.Rinex2ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 2.xx","title":"Rinex2ObsHeaderMixin"},{"location":"api/midgard-parsers/#rinex2obsheaderparser","text":"Full name: midgard.parsers.rinex2_obs_header.Rinex2ObsHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 2.xx observation header The data in the rinex file will not be parsed.","title":"Rinex2ObsHeaderParser"},{"location":"api/midgard-parsers/#midgardparsersrinex3_clk","text":"A parser for reading RINEX clock files with version 3.xx","title":"midgard.parsers.rinex3_clk"},{"location":"api/midgard-parsers/#rinex3clkparser","text":"Full name: midgard.parsers.rinex3_clk.Rinex3ClkParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX clock files with version 3.xx","title":"Rinex3ClkParser"},{"location":"api/midgard-parsers/#midgardparsersrinex3_clk_header","text":"RINEX clock header classes for file format version 3.xx","title":"midgard.parsers.rinex3_clk_header"},{"location":"api/midgard-parsers/#rinex3clkheadermixin","text":"Full name: midgard.parsers.rinex3_clk_header.Rinex3ClkHeaderMixin Signature: () A mixin defining which RINEX clock headers are mandatory and optional in RINEX version 3.xx","title":"Rinex3ClkHeaderMixin"},{"location":"api/midgard-parsers/#rinex3clkheaderparser","text":"Full name: midgard.parsers.rinex3_clk_header.Rinex3ClkHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 3.xx clock header The data in the rinex file will not be parsed.","title":"Rinex3ClkHeaderParser"},{"location":"api/midgard-parsers/#midgardparsersrinex3_nav_header","text":"RINEX navigation header classes for file format version 3.xx","title":"midgard.parsers.rinex3_nav_header"},{"location":"api/midgard-parsers/#rinex3navheadermixin","text":"Full name: midgard.parsers.rinex3_nav_header.Rinex3NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 3.xx","title":"Rinex3NavHeaderMixin"},{"location":"api/midgard-parsers/#rinex3navheaderparser","text":"Full name: midgard.parsers.rinex3_nav_header.Rinex3NavHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 3.xx navigation header The data in the rinex file will not be parsed.","title":"Rinex3NavHeaderParser"},{"location":"api/midgard-parsers/#midgardparsersrinex3_obs_header","text":"RINEX observation header classes for file format version 3.xx","title":"midgard.parsers.rinex3_obs_header"},{"location":"api/midgard-parsers/#rinex3obsheadermixin","text":"Full name: midgard.parsers.rinex3_obs_header.Rinex3ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 3.xx","title":"Rinex3ObsHeaderMixin"},{"location":"api/midgard-parsers/#rinex3obsheaderparser","text":"Full name: midgard.parsers.rinex3_obs_header.Rinex3ObsHeaderParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading just the RINEX version 3.xx observation header The data in the rinex file will not be parsed.","title":"Rinex3ObsHeaderParser"},{"location":"api/midgard-parsers/#midgardparsersterrapos_position","text":"A parser for reading Terrapos position output file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_position', file_path='Gal_C1X_brdc_land_30sec_24hrs_FNAV-file.txt') data = p.as_dict() Description: Reads data from files in Terrapos position output format.","title":"midgard.parsers.terrapos_position"},{"location":"api/midgard-parsers/#terrapospositionparser","text":"Full name: midgard.parsers.terrapos_position.TerraposPositionParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Terrapos position output file Following data are available after reading Terrapos position file: Key Description gpsweek GPS week gpssec Seconds of GPS week head Head in [deg] height Ellipsoidal height in [m] lat Latitude in [deg] lon Longitude in [deg] num_sat Number of satellites pdop Position Dilution of Precision (PDOP) pitch Pitch in [deg] reliability_east East position external reliability in [m] #TODO: Is that correct? reliability_height Height position external reliability in [m] #TODO: Is that correct? reliability_north North position external reliability in [m] #TODO: Is that correct? roll Roll in [deg] sigma_east Standard deviation of East position in [m] #TODO: Is that correct? sigma_height Standard deviation of Height position in [m] #TODO: Is that correct? sigma_north Standard deviation of North position in [m] #TODO: Is that correct? and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"TerraposPositionParser"},{"location":"api/midgard-parsers/#midgardparsersterrapos_residual","text":"A parser for reading Terrapos residual file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_residual', file_path='PPP-residuals.txt') data = p.as_dict() Description: Reads data from files in Terrapos residual format.","title":"midgard.parsers.terrapos_residual"},{"location":"api/midgard-parsers/#terraposresidualparser","text":"Full name: midgard.parsers.terrapos_residual.TerraposResidualParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading Terrapos residual file Following data are available after reading Terrapos residual file: Parameter Description azimuth Azimuth of satellites in [deg] elevation Elevation of satellites in [deg] gpsweek GPS week gpssec Seconds of GPS week residual_code Code (pseudorange) residuals in [m] residual_doppler Doppler residuals in [m] residual_phase Carrier-phase residuals in [m] satellite Satellite PRN number together with GNSS identifier (e.g. G07) system GNSS identifier and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"TerraposResidualParser"},{"location":"api/midgard-parsers/#midgardparserstimeseries_env","text":"A parser for reading timeseries files in ENV format Example: from midgard import parsers p = parsers.parse_file(parser_name='timeseries_env', file_path='stas.env') data = p.as_dict() Description: Reads data from files timeseries files in ENV (east, north, vertical) format","title":"midgard.parsers.timeseries_env"},{"location":"api/midgard-parsers/#timeseriesenvparser","text":"Full name: midgard.parsers.timeseries_env.TimeseriesEnvParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading timeseries files in ENV format Following data are available after reading timeseries ENV file: Key Description date Date in format yyMMMdd (e.g. 18MAY10). year Date in unit year. east East coordinate in [mm]. east_sigma Standard devication of east coordinate in [mm]. north North coordinate in [mm]. north_sigma Standard devication of north coordinate in [mm]. vertical Vertical coordinate in [mm]. vertical_sigma Standard devication of vertical coordinate in [mm]. and meta -data: Key Description __data_path__ File path __params__ np.genfromtxt parameters __parser_name__ Parser name","title":"TimeseriesEnvParser"},{"location":"api/midgard-parsers/#midgardparsersvlbi_source_names","text":"A parser for reading IVS source names translation table","title":"midgard.parsers.vlbi_source_names"},{"location":"api/midgard-parsers/#vlbisourcenamesparser","text":"Full name: midgard.parsers.vlbi_source_names.VlbiSourceNamesParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file","title":"VlbiSourceNamesParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex","text":"A parser for reading Rinex files","title":"midgard.parsers.wip_rinex"},{"location":"api/midgard-parsers/#rinex","text":"Full name: midgard.parsers.wip_rinex.rinex Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on Rinex file type","title":"rinex()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex2_nav","text":"A parser for reading RINEX navigation files with version 2.xx","title":"midgard.parsers.wip_rinex2_nav"},{"location":"api/midgard-parsers/#rinex2navparser","text":"Full name: midgard.parsers.wip_rinex2_nav.Rinex2NavParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX navigation files with version 2.xx","title":"Rinex2NavParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex2_obs","text":"A parser for reading RINEX observation files with version 2.xx","title":"midgard.parsers.wip_rinex2_obs"},{"location":"api/midgard-parsers/#rinex2obsparser","text":"Full name: midgard.parsers.wip_rinex2_obs.Rinex2ObsParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX observation files with version 2.xx","title":"Rinex2ObsParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_nav","text":"A parser for reading RINEX navigation files with version 3.xx","title":"midgard.parsers.wip_rinex3_nav"},{"location":"api/midgard-parsers/#rinex3navparser","text":"Full name: midgard.parsers.wip_rinex3_nav.Rinex3NavParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX navigation files with version 3.xx","title":"Rinex3NavParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_obs","text":"A parser for reading RINEX observation files with version 3.xx","title":"midgard.parsers.wip_rinex3_obs"},{"location":"api/midgard-parsers/#rinex3obsparser","text":"Full name: midgard.parsers.wip_rinex3_obs.Rinex3ObsParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None A parser for reading RINEX observation files with version 3.xx","title":"Rinex3ObsParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex_clk","text":"A parser for reading Rinex navigation files","title":"midgard.parsers.wip_rinex_clk"},{"location":"api/midgard-parsers/#rinexclkparser","text":"Full name: midgard.parsers.wip_rinex_clk.RinexClkParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None Class for defining common methods for RINEX clock parsers.","title":"RinexClkParser"},{"location":"api/midgard-parsers/#rinex_clk","text":"Full name: midgard.parsers.wip_rinex_clk.rinex_clk Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"rinex_clk()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex_nav","text":"A parser for reading Rinex navigation files","title":"midgard.parsers.wip_rinex_nav"},{"location":"api/midgard-parsers/#rinexnavparser","text":"Full name: midgard.parsers.wip_rinex_nav.RinexNavParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None Class for defining common methods for RINEX navigation parsers.","title":"RinexNavParser"},{"location":"api/midgard-parsers/#rinex_nav","text":"Full name: midgard.parsers.wip_rinex_nav.rinex_nav Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"rinex_nav()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex_obs","text":"A parser for reading Rinex observation files","title":"midgard.parsers.wip_rinex_obs"},{"location":"api/midgard-parsers/#rinexobsparser","text":"Full name: midgard.parsers.wip_rinex_obs.RinexObsParser Signature: (file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger=<built-in function print>, sampling_rate:Union[int, NoneType]=None, strict:bool=False) -> None Class for defining common methods for RINEX observation parsers.","title":"RinexObsParser"},{"location":"api/midgard-parsers/#rinex_obs","text":"Full name: midgard.parsers.wip_rinex_obs.rinex_obs Signature: (**parser_args:Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"rinex_obs()"},{"location":"api/midgard-plot/","text":"midgard.plot midgard.plot.matplotlib_extension get_statistic () Full name: midgard.plot.matplotlib_extension.get_statistic Signature: (data:'ndarray', funcs:List[str]=['rms', 'mean', 'std', 'min', 'max', 'percentile'], unit:str='') -> List[str] Get text string with statistical information List of statistical functions ( funcs ), which can be chosen: Function Description max Maximal value of data array min Minimal value of data array mean Mean value of data array percentile 95th percentile of data array rms Root mean square of data array std Standard deviation of data array Args: data: Array with data. funcs: List with statistical choices Returns: List with strings representing statistical information plot_scatter_subplot_row () Full name: midgard.plot.matplotlib_extension.plot_scatter_subplot_row Signature: (ax:'AxesSubplot', x_array:'ndarray', y_array:'ndarray', xlabel:str='', ylabel:str='', x_unit:str='', y_unit:str='', label:str='', color:Union[NoneType, _ForwardRef('ndarray')]=None, opt_args:Union[Dict[str, Any], NoneType]=None) -> None Generate single row of scatter subplot Example: Following options can be selected: Option Value Description alpha Blending values of markers (0: transparent, 1: opaque) fsize_subtitle Fontsize of subplot title (statistical information) marker <'.' '-'> markersize Marker size reg_line <True False> statistic Plot statistical information. Following function can be defined: 'max', 'mean', 'min', 'rms', 'std', 'percentile' (see function get_statistic for more information) Args: ax: Axes object needed for plotting subplot row. x_array: Array with x-axis data to plot. y_array: Array with y-axis data to plot. xlabel: X-axis label. ylabels: X-axis label. x_unit: X-axis unit. y_unit: Y-axis unit. label: Legend label. color: Marker color. opt_args: Dictionary with options, which overwrite default plot configuration. plot_scatter_subplots () Full name: midgard.plot.matplotlib_extension.plot_scatter_subplots Signature: (x_array:'ndarray', y_arrays:List[_ForwardRef('ndarray')], xlabel:str, ylabels:List[str], x_unit:str='', y_unit:str='', figure_path:str='plot_scatter_subplot.png', opt_args:Union[Dict[str, Any], NoneType]=None, events:Union[Tuple[Any, str, str], NoneType]=None) -> None Generate scatter subplot The subplot has only one column. The number of rows is defined via the chosen number of y-axis data. Example: Following opt_arg options can be selected: Option Value Description dpi Resolution of file in dots per inch figsize (num, num) Figure size fsize_subtitle Fontsize of subplot title (statistical information) marker <'.' '-'> plot_to <console file> reg_line <True False> sharex <True False> sharey <True False> statistic Plot statistical information. Following function can be defined: 'max', 'mean', 'min', 'rms', 'std', 'percentile' (see function _get_statistic for more information) title Main title of subplots Args: x_array: Array with x-axis data to plot. y_arrays: List of arrays with y-axis data to plot. xlabel: X-axis label. ylabels: List with y-axis labels. It should corresponds to given number of y-axis arrays. x_unit: X-axis unit. y_unit: Y-axis unit. figure_path: Figure path. opt_args: Dictionary with options, which overwrite default plot configuration.","title":"midgard.plot"},{"location":"api/midgard-plot/#midgardplot","text":"","title":"midgard.plot"},{"location":"api/midgard-plot/#midgardplotmatplotlib_extension","text":"","title":"midgard.plot.matplotlib_extension"},{"location":"api/midgard-plot/#get_statistic","text":"Full name: midgard.plot.matplotlib_extension.get_statistic Signature: (data:'ndarray', funcs:List[str]=['rms', 'mean', 'std', 'min', 'max', 'percentile'], unit:str='') -> List[str] Get text string with statistical information List of statistical functions ( funcs ), which can be chosen: Function Description max Maximal value of data array min Minimal value of data array mean Mean value of data array percentile 95th percentile of data array rms Root mean square of data array std Standard deviation of data array Args: data: Array with data. funcs: List with statistical choices Returns: List with strings representing statistical information","title":"get_statistic()"},{"location":"api/midgard-plot/#plot_scatter_subplot_row","text":"Full name: midgard.plot.matplotlib_extension.plot_scatter_subplot_row Signature: (ax:'AxesSubplot', x_array:'ndarray', y_array:'ndarray', xlabel:str='', ylabel:str='', x_unit:str='', y_unit:str='', label:str='', color:Union[NoneType, _ForwardRef('ndarray')]=None, opt_args:Union[Dict[str, Any], NoneType]=None) -> None Generate single row of scatter subplot Example: Following options can be selected: Option Value Description alpha Blending values of markers (0: transparent, 1: opaque) fsize_subtitle Fontsize of subplot title (statistical information) marker <'.' '-'> markersize Marker size reg_line <True False> statistic Plot statistical information. Following function can be defined: 'max', 'mean', 'min', 'rms', 'std', 'percentile' (see function get_statistic for more information) Args: ax: Axes object needed for plotting subplot row. x_array: Array with x-axis data to plot. y_array: Array with y-axis data to plot. xlabel: X-axis label. ylabels: X-axis label. x_unit: X-axis unit. y_unit: Y-axis unit. label: Legend label. color: Marker color. opt_args: Dictionary with options, which overwrite default plot configuration.","title":"plot_scatter_subplot_row()"},{"location":"api/midgard-plot/#plot_scatter_subplots","text":"Full name: midgard.plot.matplotlib_extension.plot_scatter_subplots Signature: (x_array:'ndarray', y_arrays:List[_ForwardRef('ndarray')], xlabel:str, ylabels:List[str], x_unit:str='', y_unit:str='', figure_path:str='plot_scatter_subplot.png', opt_args:Union[Dict[str, Any], NoneType]=None, events:Union[Tuple[Any, str, str], NoneType]=None) -> None Generate scatter subplot The subplot has only one column. The number of rows is defined via the chosen number of y-axis data. Example: Following opt_arg options can be selected: Option Value Description dpi Resolution of file in dots per inch figsize (num, num) Figure size fsize_subtitle Fontsize of subplot title (statistical information) marker <'.' '-'> plot_to <console file> reg_line <True False> sharex <True False> sharey <True False> statistic Plot statistical information. Following function can be defined: 'max', 'mean', 'min', 'rms', 'std', 'percentile' (see function _get_statistic for more information) title Main title of subplots Args: x_array: Array with x-axis data to plot. y_arrays: List of arrays with y-axis data to plot. xlabel: X-axis label. ylabels: List with y-axis labels. It should corresponds to given number of y-axis arrays. x_unit: X-axis unit. y_unit: Y-axis unit. figure_path: Figure path. opt_args: Dictionary with options, which overwrite default plot configuration.","title":"plot_scatter_subplots()"},{"location":"api/midgard-site_info/","text":"midgard.site_info midgard.site_info.antenna Antenna site information classes Description: The antenna module generates a antenna object based on site information from the SINEX file or other sources. Following steps are carried out for getting a antenna object: 1. Plugins modulen register AntennaHistory classes (e.g. AntennaHistorySinex) and updates the 'sources' attribute of the AntennaHistory class. 2. The Antenna object is initialized by calling the Antenna.get function. 3. The AntennaHistory.get function is called via the Antenna.get function. Here the correct AntennaHistory class is choosen by accessing the registered 'sources' attribute of the AntennaHistory class. 4. The AntennaBase.get function reads the antenna information via the _read_history() function of the AntennaHistorySinex or other calls. The antenna information is selected via a given date. Example: from midgard.site_info import antenna; from datetime import datetime antenna.Antenna.get(source=\"sinex\", station=\"zimm\", date=datetime(2018, 10, 1), source_path=\"igs.snx\") Antenna Full name: midgard.site_info.antenna.Antenna Signature: () Main antenna class for getting antenna object depending on site information source The site information source can be e.g. a SINEX file. AntennaBase Full name: midgard.site_info.antenna.AntennaBase Signature: (station:str, antenna_info:Dict[str, Any]) -> None Antenna base class defining common attributes and methods AntennaHistory Full name: midgard.site_info.antenna.AntennaHistory Signature: () AntennaHistoryBase Full name: midgard.site_info.antenna.AntennaHistoryBase Signature: (station:str, source_path:str) -> None History base class defining common attributes and methods from a specific site information (e.g. antenna, receiver) AntennaHistorySinex Full name: midgard.site_info.antenna.AntennaHistorySinex Signature: (station:str, source_path:str) -> None AntennaSinex Full name: midgard.site_info.antenna.AntennaSinex Signature: (station:str, antenna_info:Dict[str, Any]) -> None Antenna class handling SINEX file antenna station information midgard.site_info.receiver Receiver site information classes Description: The receiver module generates a receiver object based on site information from the SINEX file or other sources. Following steps are carried out for getting a receiver object: 1. Plugins modulen register ReceiverHistory classes (e.g. ReceiverHistorySinex) and updates the 'sources' attribute of the ReceiverHistory class. 2. The Receiver object is initialized by calling the Receiver.get function. 3. The ReceiverHistory.get function is called via the Receiver.get function. Here the correct ReceiverHistory class is choosen by accessing the registered 'sources' attribute of the ReceiverHistory class. 4. The ReceiverBase.get function reads the receiver information via the _read_history() function of the ReceiverHistorySinex or other calls. The receiver information is selected via a given date. Example: from midgard.site_info import receiver receiver.Receiver.get(source=\"sinex\", station=\"ales\", date=datetime(2018, 10, 1), source_path=\"igs.snx\") Receiver Full name: midgard.site_info.receiver.Receiver Signature: () Main receiver class for getting receiver object depending on site information source The site information source can be e.g. a SINEX file. ReceiverBase Full name: midgard.site_info.receiver.ReceiverBase Signature: (station:str, receiver_info:Dict[str, Any]) -> None Receiver base class defining common attributes and methods ReceiverHistory Full name: midgard.site_info.receiver.ReceiverHistory Signature: () ReceiverHistoryBase Full name: midgard.site_info.receiver.ReceiverHistoryBase Signature: (station:str, source_path:str) -> None History base class defining common attributes and methods from a specific site information (e.g. antenna, receiver) ReceiverHistorySinex Full name: midgard.site_info.receiver.ReceiverHistorySinex Signature: (station:str, source_path:str) -> None ReceiverSinex Full name: midgard.site_info.receiver.ReceiverSinex Signature: (station:str, receiver_info:Dict[str, Any]) -> None Receiver class handling SINEX file receiver station information midgard.site_info.site_info Basic functionality for parsing and saving site information Description: This module contains functions and classes for parsing site information. This file defines the general structure shared by site information types. More specific format details are implemented in subclasses. SiteInfoHistory Full name: midgard.site_info.site_info.SiteInfoHistory Signature: () SiteInfoHistoryBase Full name: midgard.site_info.site_info.SiteInfoHistoryBase Signature: (station:str, source_path:str) -> None History base class defining common attributes and methods from a specific site information (e.g. antenna, receiver)","title":"midgard.site_info"},{"location":"api/midgard-site_info/#midgardsite_info","text":"","title":"midgard.site_info"},{"location":"api/midgard-site_info/#midgardsite_infoantenna","text":"Antenna site information classes Description: The antenna module generates a antenna object based on site information from the SINEX file or other sources. Following steps are carried out for getting a antenna object: 1. Plugins modulen register AntennaHistory classes (e.g. AntennaHistorySinex) and updates the 'sources' attribute of the AntennaHistory class. 2. The Antenna object is initialized by calling the Antenna.get function. 3. The AntennaHistory.get function is called via the Antenna.get function. Here the correct AntennaHistory class is choosen by accessing the registered 'sources' attribute of the AntennaHistory class. 4. The AntennaBase.get function reads the antenna information via the _read_history() function of the AntennaHistorySinex or other calls. The antenna information is selected via a given date. Example: from midgard.site_info import antenna; from datetime import datetime antenna.Antenna.get(source=\"sinex\", station=\"zimm\", date=datetime(2018, 10, 1), source_path=\"igs.snx\")","title":"midgard.site_info.antenna"},{"location":"api/midgard-site_info/#antenna","text":"Full name: midgard.site_info.antenna.Antenna Signature: () Main antenna class for getting antenna object depending on site information source The site information source can be e.g. a SINEX file.","title":"Antenna"},{"location":"api/midgard-site_info/#antennabase","text":"Full name: midgard.site_info.antenna.AntennaBase Signature: (station:str, antenna_info:Dict[str, Any]) -> None Antenna base class defining common attributes and methods","title":"AntennaBase"},{"location":"api/midgard-site_info/#antennahistory","text":"Full name: midgard.site_info.antenna.AntennaHistory Signature: ()","title":"AntennaHistory"},{"location":"api/midgard-site_info/#antennahistorybase","text":"Full name: midgard.site_info.antenna.AntennaHistoryBase Signature: (station:str, source_path:str) -> None History base class defining common attributes and methods from a specific site information (e.g. antenna, receiver)","title":"AntennaHistoryBase"},{"location":"api/midgard-site_info/#antennahistorysinex","text":"Full name: midgard.site_info.antenna.AntennaHistorySinex Signature: (station:str, source_path:str) -> None","title":"AntennaHistorySinex"},{"location":"api/midgard-site_info/#antennasinex","text":"Full name: midgard.site_info.antenna.AntennaSinex Signature: (station:str, antenna_info:Dict[str, Any]) -> None Antenna class handling SINEX file antenna station information","title":"AntennaSinex"},{"location":"api/midgard-site_info/#midgardsite_inforeceiver","text":"Receiver site information classes Description: The receiver module generates a receiver object based on site information from the SINEX file or other sources. Following steps are carried out for getting a receiver object: 1. Plugins modulen register ReceiverHistory classes (e.g. ReceiverHistorySinex) and updates the 'sources' attribute of the ReceiverHistory class. 2. The Receiver object is initialized by calling the Receiver.get function. 3. The ReceiverHistory.get function is called via the Receiver.get function. Here the correct ReceiverHistory class is choosen by accessing the registered 'sources' attribute of the ReceiverHistory class. 4. The ReceiverBase.get function reads the receiver information via the _read_history() function of the ReceiverHistorySinex or other calls. The receiver information is selected via a given date. Example: from midgard.site_info import receiver receiver.Receiver.get(source=\"sinex\", station=\"ales\", date=datetime(2018, 10, 1), source_path=\"igs.snx\")","title":"midgard.site_info.receiver"},{"location":"api/midgard-site_info/#receiver","text":"Full name: midgard.site_info.receiver.Receiver Signature: () Main receiver class for getting receiver object depending on site information source The site information source can be e.g. a SINEX file.","title":"Receiver"},{"location":"api/midgard-site_info/#receiverbase","text":"Full name: midgard.site_info.receiver.ReceiverBase Signature: (station:str, receiver_info:Dict[str, Any]) -> None Receiver base class defining common attributes and methods","title":"ReceiverBase"},{"location":"api/midgard-site_info/#receiverhistory","text":"Full name: midgard.site_info.receiver.ReceiverHistory Signature: ()","title":"ReceiverHistory"},{"location":"api/midgard-site_info/#receiverhistorybase","text":"Full name: midgard.site_info.receiver.ReceiverHistoryBase Signature: (station:str, source_path:str) -> None History base class defining common attributes and methods from a specific site information (e.g. antenna, receiver)","title":"ReceiverHistoryBase"},{"location":"api/midgard-site_info/#receiverhistorysinex","text":"Full name: midgard.site_info.receiver.ReceiverHistorySinex Signature: (station:str, source_path:str) -> None","title":"ReceiverHistorySinex"},{"location":"api/midgard-site_info/#receiversinex","text":"Full name: midgard.site_info.receiver.ReceiverSinex Signature: (station:str, receiver_info:Dict[str, Any]) -> None Receiver class handling SINEX file receiver station information","title":"ReceiverSinex"},{"location":"api/midgard-site_info/#midgardsite_infosite_info","text":"Basic functionality for parsing and saving site information Description: This module contains functions and classes for parsing site information. This file defines the general structure shared by site information types. More specific format details are implemented in subclasses.","title":"midgard.site_info.site_info"},{"location":"api/midgard-site_info/#siteinfohistory","text":"Full name: midgard.site_info.site_info.SiteInfoHistory Signature: ()","title":"SiteInfoHistory"},{"location":"api/midgard-site_info/#siteinfohistorybase","text":"Full name: midgard.site_info.site_info.SiteInfoHistoryBase Signature: (station:str, source_path:str) -> None History base class defining common attributes and methods from a specific site information (e.g. antenna, receiver)","title":"SiteInfoHistoryBase"},{"location":"api/midgard-writers/","text":"midgard.writers Framework for writing output in different formats Description: Each output format / output destination should be defined in a separate .py-file. The function inside the .py-file that should be called need to be decorated with the :func: ~midgard.dev.plugins.register decorator as follows:: from midgard.dev import plugins @plugins.register def write_as_fancy_format(arg_1, arg_2): ... names () Full name: midgard.writers.names Signature: () -> List[str] List the names of the available writers Returns: List of strings with the names of the available writers. write () Full name: midgard.writers.write Signature: (writer:str, **writer_args:Any) -> None Call one writer Args: writer : Name of writer. writer_args : Arguments passed on to writer.","title":"midgard.writers"},{"location":"api/midgard-writers/#midgardwriters","text":"Framework for writing output in different formats Description: Each output format / output destination should be defined in a separate .py-file. The function inside the .py-file that should be called need to be decorated with the :func: ~midgard.dev.plugins.register decorator as follows:: from midgard.dev import plugins @plugins.register def write_as_fancy_format(arg_1, arg_2): ...","title":"midgard.writers"},{"location":"api/midgard-writers/#names","text":"Full name: midgard.writers.names Signature: () -> List[str] List the names of the available writers Returns: List of strings with the names of the available writers.","title":"names()"},{"location":"api/midgard-writers/#write","text":"Full name: midgard.writers.write Signature: (writer:str, **writer_args:Any) -> None Call one writer Args: writer : Name of writer. writer_args : Arguments passed on to writer.","title":"write()"},{"location":"api/midgard/","text":"midgard Midgard, the Python Geodesy library Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting. Midgard comes organized into different subpackages: data dev site_info files config ionosphere parsers math gnss writers plot collections Look for help inside each subpackage: >>> from midgard import subpackage # doctest: +SKIP >>> help(subpackage) # doctest: +SKIP Current maintainers: Michael D\u00e4hnn michael.daehnn@kartverket.no Ingrid Fausk ingrid.fausk@kartverket.no Ann-Silje Kirkvik ann-silje.kirkvik@kartverket.no Mohammed Ouassou mohammed.ouassou@kartverket.no Hans Sverre Smal\u00f8 hans.sverre.smalo@kartverket.no Geir Arne Hjelle geirarne@gmail.com","title":"midgard"},{"location":"howto/testing/","text":"Testing It will be shortly described how the source code testing is done in Midgard. pytest is used by Midgard for testing the library modules. All module tests of Midgard are located in directory ./midgard/tests . The tests directory mirrors the official directory structure under ./midgard/midgard . For example the test for the modul ./midgard/midgard/math/interpolation.py can be found under ./midgard/tests/math/test_interpolation.py . In Midgard the test files follow the naming convention test_<module name>.py (e.g. test_interpolation.py ). Information about how to write pytest tests can be found under https://pytest.org/ . The written test can be excecuted as follows: All Midgard tests can be excecuted by calling make test in main directory ./midgard . If no arguments are specified pytest searches recursively after test_*.py files starting from the current directory. A single modul test can be carried out for example by pytest tests/ionosphere/test_klobuchar.py . An overview over passed and failed tests are given after excecuting pytest .","title":"Testing"},{"location":"howto/testing/#testing","text":"It will be shortly described how the source code testing is done in Midgard. pytest is used by Midgard for testing the library modules. All module tests of Midgard are located in directory ./midgard/tests . The tests directory mirrors the official directory structure under ./midgard/midgard . For example the test for the modul ./midgard/midgard/math/interpolation.py can be found under ./midgard/tests/math/test_interpolation.py . In Midgard the test files follow the naming convention test_<module name>.py (e.g. test_interpolation.py ). Information about how to write pytest tests can be found under https://pytest.org/ . The written test can be excecuted as follows: All Midgard tests can be excecuted by calling make test in main directory ./midgard . If no arguments are specified pytest searches recursively after test_*.py files starting from the current directory. A single modul test can be carried out for example by pytest tests/ionosphere/test_klobuchar.py . An overview over passed and failed tests are given after excecuting pytest .","title":"Testing"}]}